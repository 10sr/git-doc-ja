Git User's Manual (for version 1.5.3 or newer)
______________________________________________
// = Git ユーザマニュアル (バージョン 1.5.3 以降用)

// (訳注：この資料は、http://www.kernel.org/pub/software/scm/git/docs/user-manual.html に掲載されている
// 内容を日本語訳したものです。
// 英語が得意でないので、誤訳があるかもしれません。
// 必要な場合は、原文を参照してください。)

Git is a fast distributed revision control system.
// git は高速な分散リビジョン管理システムです。

This manual is designed to be readable by someone with basic UNIX
command-line skills, but no previous knowledge of git.
// このマニュアルは、基本的な UNIX コマンドのスキルをもった人が読むことを想定していますが、
// git に関する前提知識は必要ありません。

<<repositories-and-branches>> and <<exploring-git-history>> explain how
to fetch and study a project using git--read these chapters to learn how
to build and test a particular version of a software project, search for
regressions, and so on.
// <<repositories-and-branches>> と <<exploring-git-history>> では
// git を使用してプロジェクトを取得・調査する方法を説明します。
// -- これらの章を読むことで、ソフトウェアプロジェクトの特定のバージョンをビルドして
// テストしたり、回帰点を探し出す方法などを習得してください。

People needing to do actual development will also want to read
<<Developing-With-git>> and <<sharing-development>>.
// 実際に開発する必要のある場合は、<<Developing-With-git>> と <<sharing-development>>
// も読んでください。

Further chapters cover more specialized topics.
// さらに後ろの章では、より特化したトピックスを取り上げます。

Comprehensive reference documentation is available through the man
pages, or linkgit:git-help[1] command.  For example, for the command
"git clone <repo>", you can either use:
// 包括的なリファレンスドキュメントは man ページ
// もしくはコマンドlinkgit:git-help[1]で確認できます。
// 例えば、"git clone　<repo>" のコマンドは次の
// どちらのようにしても確認できます。

------------------------------------------------
$ man git-clone
------------------------------------------------

or:

------------------------------------------------
$ git help clone
------------------------------------------------

With the latter, you can use the manual viewer of your choice; see
linkgit:git-help[1] for more information.
// 後者のやり方では、マニュアルビューワを選ぶことができます。
// 詳細はlinkgit:git-help[1]をご覧ください。

See also <<git-quick-start>> for a brief overview of git commands,
without any explanation.
// git コマンドの概要を知るには <<git-quick-start>> を参照してください。

Finally, see <<todo>> for ways that you can help make this manual more
complete.
// 最後に、<<todo>> では、このマニュアルをより完全にする為の情報を説明しています。


[[repositories-and-branches]]
Repositories and Branches
=========================
// == リポジトリとブランチ

[[how-to-get-a-git-repository]]
How to get a git repository
---------------------------
// === git リポジトリの取得方法

It will be useful to have a git repository to experiment with as you
read this manual.
// このマニュアルを読む際には、実験用のリポジトリを取得しておくと便利です。

The best way to get one is by using the linkgit:git-clone[1] command to
download a copy of an existing repository.  If you don't already have a
project in mind, here are some interesting examples:
// 実験用リポジトリを取得する一番良い方法は linkgit:git-clone[1] コマンドを使用し、
// 既存のリポジトリのコピーをダウンロードすることです。

------------------------------------------------
	# git itself (approx. 10MB download):
//	# git 自身 (ダウンロードサイズは約10MB)：
$ git clone git://git.kernel.org/pub/scm/git/git.git
	# the Linux kernel (approx. 150MB download):
//	# linux カーネル (ダウンロードサイズは150MB)：
$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git
------------------------------------------------

The initial clone may be time-consuming for a large project, but you
will only need to clone once.
// 初めてのclone(複製)では大きなプロジェクトの場合、時間をかなり消費するかもしれませんが、
// clone は１回行なうだけで良いです。

The clone command creates a new directory named after the project ("git"
or "linux-2.6" in the examples above).  After you cd into this
directory, you will see that it contains a copy of the project files,
called the <<def_working_tree,working tree>>, together with a special
top-level directory named ".git", which contains all the information
about the history of the project.
// clone コマンドはそのプロジェクトにちなんだ新しいディレクトリを作成します (上記例では "git" 又は "linux-2.6")。
// このディレクトリ内にはプロジェクトファイルのコピーが存在し
// (これは <<def_working_tree,作業ツリー>> といいます)、
// それと一緒に ".git" という特別なトップレベルディレクトリが存在します。
// ".git" ディレクトリにはプロジェクトの履歴の全てが含まれています。

[[how-to-check-out]]
How to check out a different version of a project
-------------------------------------------------
// === プロジェクトの他のバージョンのチェックアウト方法

Git is best thought of as a tool for storing the history of a collection
of files.  It stores the history as a compressed collection of
interrelated snapshots of the project's contents.  In git each such
version is called a <<def_commit,commit>>.
// git はファイル集合の履歴を格納するツールとして非常によく考えられたツールです。
// git は履歴を圧縮した集合として格納し、
// プロジェクトの内容を相互に関連したスナップショットとして格納します。
// git ではこれらのバージョンを <<def_commit,コミット>> と呼びます。

Those snapshots aren't necessarily all arranged in a single line from
oldest to newest; instead, work may simultaneously proceed along
parallel lines of development, called <<def_branch,branches>>, which may
merge and diverge.
// それらのスナップショットは必ずしもすべてが古いものから最新のものに
// 単線で並んでいるとは限りません；その代り、開発ラインが並行して
// 進むことがあります (これは <<def_branch,ブランチ>> といいます)。
// ブランチは分岐し統合されます。

A single git repository can track development on multiple branches.  It
does this by keeping a list of <<def_head,heads>> which reference the
latest commit on each branch; the linkgit:git-branch[1] command shows
you the list of branch heads:
// １つの git リポジトリは複数のブランチを追跡することができます。
// Git は 各ブランチの最新のコミットの参照を <<def_head,ヘッド>> の
// 一覧に保管することで複数のブランチを追跡します；
// linkgit:git-branch[1] コマンドはブランチの一覧を表示します：

------------------------------------------------
$ git branch
* master
------------------------------------------------

A freshly cloned repository contains a single branch head, by default
named "master", with the working directory initialized to the state of
the project referred to by that branch head.
// 新しく clone したリポジトリは、１つのブランチヘッド(デフォルトではその名前は "master"です)
// を持っており、作業ディレクトリは、そのブランチ head が参照するプロジェクトの状態で
// 初期化されています。

Most projects also use <<def_tag,tags>>.  Tags, like heads, are
references into the project's history, and can be listed using the
linkgit:git-tag[1] command:
// 多くのプロジェクトは <<def_tag,tags>> も使用しています。
// tag は head のようにプロジェクトの履歴を参照していて、
// linkgit:git-tag[1] コマンドを用いてリスト表示できます。

------------------------------------------------
$ git tag -l
v2.6.11
v2.6.11-tree
v2.6.12
v2.6.12-rc2
v2.6.12-rc3
v2.6.12-rc4
v2.6.12-rc5
v2.6.12-rc6
v2.6.13
...
------------------------------------------------

Tags are expected to always point at the same version of a project,
while heads are expected to advance as development progresses.
// tag は常にプロジェクトの特定のバージョンを指し示し、
// head は開発が進むに従い更新されていきます。

Create a new branch head pointing to one of these versions and check it
out using linkgit:git-checkout[1]:
// あるバージョンを指し示す新しいブランチの head を作成し、
// そのブランチの head をチェックアウトするには linkgit:git-checkout[1] を使用します：

------------------------------------------------
$ git checkout -b new v2.6.13
------------------------------------------------

The working directory then reflects the contents that the project had
when it was tagged v2.6.13, and linkgit:git-branch[1] shows two
branches, with an asterisk marking the currently checked-out branch:
// この時、作業ディレクトリは v2.6.13 の tag を付けた時に
// プロジェクトのもっていた内容が反映されています。
// そして、linkgit:git-branch[1] すると２つのブランチが表示され、
// 現在チェックアウトしているブランチのマークがアスタリスク(*)で表示されます。

------------------------------------------------
$ git branch
  master
* new
------------------------------------------------

If you decide that you'd rather see version 2.6.17, you can modify
the current branch to point at v2.6.17 instead, with
// もしバージョン 2.6.17 をむしろ参照したいと考えたなら、
// 現在のブランチを v2.6.17 を参照するように変更できます。次のようにして：

------------------------------------------------
$ git reset --hard v2.6.17
------------------------------------------------

Note that if the current branch head was your only reference to a
particular point in history, then resetting that branch may leave you
with no way to find the history it used to point to; so use this command
carefully.
// ある特定の履歴がを参照しているのが、現在のブランチのみの場合、
// ブランチをリセットすると、もやはその履歴を参照できなくなることに注意してください；
// ですから、このコマンドは注意して使用してください。

[[understanding-commits]]
Understanding History: Commits
------------------------------
// === 履歴の理解：コミット

Every change in the history of a project is represented by a commit.
The linkgit:git-show[1] command shows the most recent commit on the
current branch:
// プロジェクトの全ての変更履歴は、commit として表現されます。
// linkgit:git-show[1] コマンドは現在のブランチ上で最後にコミットした
// 履歴を表示します：

------------------------------------------------
$ git show
commit 17cf781661e6d38f737f15f53ab552f1e95960d7
Author: Linus Torvalds <torvalds@ppc970.osdl.org.(none)>
Date:   Tue Apr 19 14:11:06 2005 -0700

    Remove duplicate getenv(DB_ENVIRONMENT) call

    Noted by Tony Luck.

diff --git a/init-db.c b/init-db.c
index 65898fa..b002dc6 100644
--- a/init-db.c
+++ b/init-db.c
@@ -7,7 +7,7 @@
 
 int main(int argc, char **argv)
 {
-	char *sha1_dir = getenv(DB_ENVIRONMENT), *path;
+	char *sha1_dir, *path;
 	int len, i;
 
 	if (mkdir(".git", 0755) < 0) {
------------------------------------------------

As you can see, a commit shows who made the latest change, what they
did, and why.
// このように、コミットは誰が最後に変更したか、何を、何故変更したかを表示します。

Every commit has a 40-hexdigit id, sometimes called the "object name" or the
"SHA-1 id", shown on the first line of the "git show" output.  You can usually
refer to a commit by a shorter name, such as a tag or a branch name, but this
longer name can also be useful.  Most importantly, it is a globally unique
name for this commit: so if you tell somebody else the object name (for
example in email), then you are guaranteed that name will refer to the same
commit in their repository that it does in yours (assuming their repository
has that commit at all).  Since the object name is computed as a hash over the
contents of the commit, you are guaranteed that the commit can never change
without its name also changing.
// 全てのコミットは 40桁の16進数の ID ("オブジェクト名" 又は "SHA-1 id" と呼ぶこともあります)
// を持ち、"git show" の出力の１行目にその ID が表示されます。
// 通常、コミットはタグやブランチ名のような短い名前で参照できますが、
// この長い名前も役に立つことがあります。特に重要なのは、この ID がこのコミットを
// 大局的にユニークにしている点です：つまり、他のだれかにその ID を
// (例えば emailで)伝えた場合、その ID が彼らのリポジトリ内でもあなたのリポジトリ内でも
// 同じコミットを指し示すことを保障しています。
// (彼らのリポジトリにそのコミットが完全に含まれている場合にはです)。
// オブジェクト名はコミット対象のコンテンツのハッシュとして計算される為、
// 変更しない限りは、決して変わらないことが保障されています。

In fact, in <<git-concepts>> we shall see that everything stored in git
history, including file data and directory contents, is stored in an object
with a name that is a hash of its contents.
// 実際、<<git-concepts,gitのコンセプト>> では、git に格納されている全ての履歴が、
// ファイルデータとディレクトリの中身も含めて、その中身のハッシュの名前で
// オブジェクトが格納されていることを見るでしょう。

[[understanding-reachability]]
Understanding history: commits, parents, and reachability
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ==== 履歴の理解：コミット、親、到達可能性

Every commit (except the very first commit in a project) also has a
parent commit which shows what happened before this commit.
Following the chain of parents will eventually take you back to the
beginning of the project.
// 全てのコミットは(プロジェクトの最初のコミットを除き)、そのコミットの前に
// 行われた変更を示す親のコミットを持っています。
// 親のつながりは最終的にはプロジェクトの開始点まで繋がっています。

However, the commits do not form a simple list; git allows lines of
development to diverge and then reconverge, and the point where two
lines of development reconverge is called a "merge".  The commit
representing a merge can therefore have more than one parent, with
each parent representing the most recent commit on one of the lines
of development leading to that point.
// しかし、コミットは単純なリストの形式にはなりません；
// git は分散開発とその統合を許可しており、２つの開発ラインが統合する点は、
// "マージ" と呼ばれます。その為、マージを表現するコミットは１つ以上の親を持ち、
// 各親はその点につながる開発ラインの最新コミットを表現しています。

The best way to see how this works is using the linkgit:gitk[1]
command; running gitk now on a git repository and looking for merge
commits will help understand how the git organizes history.
// これがどのように作業するかを見る最良の方法は linkgit:gitk[1] コマンドを
// 使用することです；git リポジトリ上で gitk を実行し、マージコミットを
// 探すことで、git が履歴をどのように整理しているかを理解することができます。

In the following, we say that commit X is "reachable" from commit Y
if commit X is an ancestor of commit Y.  Equivalently, you could say
that Y is a descendant of X, or that there is a chain of parents
leading from commit Y to commit X.
// 以下では、コミット X がコミット Y の祖先である場合に、
// コミット X はコミット Y から "到達可能"(reachable) であると言うことにします。
// 同様に、Y は X の子孫である、あるいは、コミット Y から コミット X へ
// 繋がる親のチェーンがあると言うこともできます。

[[history-diagrams]]
Understanding history: History diagrams
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ==== 履歴の理解：履歴ダイアグラム

We will sometimes represent git history using diagrams like the one
below.  Commits are shown as "o", and the links between them with
lines drawn with - / and \.  Time goes left to right:
// 時々 git の履歴を以下のようなダイアグラムを使用して表現することがあります。
// コミットは "o" で、コミット間のリンクは - / \ です。
// 時間は左から右に流れます：


................................................
         o--o--o <-- Branch A
        /
 o--o--o <-- master
        \
         o--o--o <-- Branch B
................................................

If we need to talk about a particular commit, the character "o" may
be replaced with another letter or number.
// 特定のコミットについて話をする必要がある時は。記号 "o" は
// 他の文字や数字に置き換えられることもあります。

[[what-is-a-branch]]
Understanding history: What is a branch?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ==== 履歴の理解：ブランチとは？

When we need to be precise, we will use the word "branch" to mean a line
of development, and "branch head" (or just "head") to mean a reference
to the most recent commit on a branch.  In the example above, the branch
head named "A" is a pointer to one particular commit, but we refer to
the line of three commits leading up to that point as all being part of
"branch A".
// 正確さが必要な時は、用語 "ブランチ" は開発ラインという意味で使用し、
// "ブランチのヘッド" (あるいは単に "ヘッド") はブランチ上の最新のコミット
// という意味で使用します。上記例では、"A" というブランチヘッドは、
// ある特定コミットの点を指しますが、その点につながる３つのコミットの線は
// 全て "ブランチ A" を構成する部品です。

However, when no confusion will result, we often just use the term
"branch" both for branches and for branch heads.
// しかしながら、混乱が起きないようなときには、ブランチの場合にも
// ブランチのヘッドの場合にも単に "ブランチ" ということがあります。

[[manipulating-branches]]
Manipulating branches
---------------------
// === ブランチの運用

Creating, deleting, and modifying branches is quick and easy; here's
a summary of the commands:
// ブランチの作成/削除/変更はとても簡単です；
// 以下にコマンドのサマリを載せます：

git branch::
	list all branches
// git branch::
//	全てのブランチを一覧表示
git branch <branch>::
	create a new branch named <branch>, referencing the same
	point in history as the current branch
// git branch <branch>::
//	現在のブランチと同じ履歴点を参照する
//	新しいブランチ <branch> を作成
git branch <branch> <start-point>::
	create a new branch named <branch>, referencing
	<start-point>, which may be specified any way you like,
	including using a branch name or a tag name
// git branch <branch> <start-point>::
//	<start-point> を参照する新しいブランチ <branch> を作成。
//	<start-point> にはブランチ名又はタグ名を含む任意の名前を指定できます。
git branch -d <branch>::
	delete the branch <branch>; if the branch you are deleting
	points to a commit which is not reachable from the current
	branch, this command will fail with a warning.
// git branch -d <branch>::
//	ブランチ <branch> を削除；
//	現在のブランチから到達不可能なコミットを削除する場合、
//	このコマンドは警告を表示して終了します。
git branch -D <branch>::
	even if the branch points to a commit not reachable
	from the current branch, you may know that that commit
	is still reachable from some other branch or tag.  In that
	case it is safe to use this command to force git to delete
	the branch.
// git branch -D <branch>::
//	ブランチ <branch> を削除；
//	ブランチのコミットが現在のブランチから到達不可能な場合でも、
//	他のブランチ又はタグからそのコミットが到達可能な場合があります。
//	その場合にこのコマンドを使用すると、強制的にブランチを削除することができます。
git checkout <branch>::
	make the current branch <branch>, updating the working
	directory to reflect the version referenced by <branch>
// git checkout <branch>::
//	現在のブランチを <branch> に変更し、作業ディレクトリを <branch> が
//	参照するバージョンの状態にします。
git checkout -b <new> <start-point>::
	create a new branch <new> referencing <start-point>, and
	check it out.
// git checkout -b <new> <start-point>::
//	<start-point> を参照する新しいブランチ <new> を作成し、
//	そのブランチをチェックアウトします。

The special symbol "HEAD" can always be used to refer to the current
branch.  In fact, git uses a file named "HEAD" in the .git directory to
remember which branch is current:
// 特別なシンボル "HEAD" 使用すると、常に現在のブランチを参照することができます。
// 実際 git は .git ディレクトリにある "HEAD" という名前のファイルを使用して
// 現在のブランチの場所を記憶しています。

------------------------------------------------
$ cat .git/HEAD
ref: refs/heads/master
------------------------------------------------

[[detached-head]]
Examining an old version without creating a new branch
------------------------------------------------------
// === 新しいブランチを作成せずに古いバージョンを取得する方法

The `git checkout` command normally expects a branch head, but will also
accept an arbitrary commit; for example, you can check out the commit
referenced by a tag:
// `git checkout` コマンドは通常はブランチヘッドが引数で渡されることを期待していますが、
// 任意のコミットを指定することもできます；例えば、
// タグによって参照されるコミットをチェックアウトすることができます。

------------------------------------------------
$ git checkout v2.6.17
Note: moving to "v2.6.17" which isn't a local branch
If you want to create a new branch from this checkout, you may do so
(now or later) by using -b with the checkout command again. Example:
  git checkout -b <new_branch_name>
HEAD is now at 427abfa... Linux v2.6.17
------------------------------------------------

The HEAD then refers to the SHA-1 of the commit instead of to a branch,
and git branch shows that you are no longer on a branch:
// この時 HEAD はブランチの代わりにコミットの SHA-1 値を参照しており、
// git branch を実行するとブランチにいないことが分かります。

------------------------------------------------
$ cat .git/HEAD
427abfa28afedffadfca9dd8b067eb6d36bac53f
$ git branch
* (no branch)
  master
------------------------------------------------

In this case we say that the HEAD is "detached".
// この状態を HEAD が "切り離されている (detached)" と言います。

This is an easy way to check out a particular version without having to
make up a name for the new branch.   You can still create a new branch
(or tag) for this version later if you decide to.
// この方法は、新しいブランチを作成せずに特定のバージョンを
// チェックアウトする手軽な方法です。
// こうした後でも、後からこのバージョンに対して新しいブランチ(またはタグ)を
// 作成することができます。

[[examining-remote-branches]]
Examining branches from a remote repository
-------------------------------------------
// === リモートリポジトリのブランチの調査

The "master" branch that was created at the time you cloned is a copy
of the HEAD in the repository that you cloned from.  That repository
may also have had other branches, though, and your local repository
keeps branches which track each of those remote branches, which you
can view using the "-r" option to linkgit:git-branch[1]:
// 複製(clone)した時に作成される "master" ブランチは、
// 複製元リポジトリのヘッドのコピーです。
// しかし複製元リポジトリにはそれ以外にもブランチがあるかもしれません。
// ローカルリポジトリは、リモート(複製元)ブランチのそれぞれを追跡する為の
// ブランチを持っています。
// それらのブランチは "-r" オプションを付けて linkgit:git-branch[1] を実行すると
// 確認できます：

------------------------------------------------
$ git branch -r
  origin/HEAD
  origin/html
  origin/maint
  origin/man
  origin/master
  origin/next
  origin/pu
  origin/todo
------------------------------------------------

You cannot check out these remote-tracking branches, but you can
examine them on a branch of your own, just as you would a tag:
// それらリモート追跡ブランチを直接チェックアウトすることはできませんが、
// 自身のブランチを作成しそこで調べることはできます。

------------------------------------------------
$ git checkout -b my-todo-copy origin/todo
------------------------------------------------

Note that the name "origin" is just the name that git uses by default
to refer to the repository that you cloned from.
// "origin" という名前は、複製(clone)したリポジトリを参照する為に
// git がデフォルトで使用する名前にすぎないことに注意してください。

[[how-git-stores-references]]
Naming branches, tags, and other references
-------------------------------------------
// === ブランチ、タグ、その他リファレンスの命名法

Branches, remote-tracking branches, and tags are all references to
commits.  All references are named with a slash-separated path name
starting with "refs"; the names we've been using so far are actually
shorthand:
// ブランチ、リモート追跡ブランチ、タグは全てコミットを参照しています。
// 全ての参照は "refs" で始まるスラッシュ区切りのパス名が付けられています；
// これまで使用してきた名前は実のところ全て略記です。

	- The branch "test" is short for "refs/heads/test".
	- The tag "v2.6.18" is short for "refs/tags/v2.6.18".
	- "origin/master" is short for "refs/remotes/origin/master".
//	- ブランチ "test" は "refs/heads/test" の略記です。
//	- タグ "v2.6.18" は "refs/tags/v2.6.18" の略記です。
//	- "origin/master" は "refs/remotes/origin/master" の略記です。

The full name is occasionally useful if, for example, there ever
exists a tag and a branch with the same name.
// フルネームは時折役に立つことがあります。例えば、
// 同じ名前のタグとブランチがあるような場合です。

(Newly created refs are actually stored in the .git/refs directory,
under the path given by their name.  However, for efficiency reasons
they may also be packed together in a single file; see
linkgit:git-pack-refs[1]).
// (新しく作成された参照は .git/refs ディレクトリ内にその参照の
// 名前で格納されています。しかし、効率性の理由により、
// １つのファイルに纏めて圧縮されることもあります；linkgit:git-pack-refs[1] 参照)

As another useful shortcut, the "HEAD" of a repository can be referred
to just using the name of that repository.  So, for example, "origin"
is usually a shortcut for the HEAD branch in the repository "origin".
// もう一つ役に立つ略記として、あるリポジトリの "HEAD" は、単にそのリポジトリ名
// を使うだけで参照できるというのがあります。
// 例えば "origin" は通常、リポジトリ "origin" の HEAD ブランチの略記を表わします。

For the complete list of paths which git checks for references, and
the order it uses to decide which to choose when there are multiple
references with the same shorthand name, see the "SPECIFYING
REVISIONS" section of linkgit:git-rev-parse[1].
// 参照先として git がチェックするパスの完全なリストと、
// 同じ略記をもつ複数の参照がある場合の選択規則については
// linkgit:git-rev-parse[1] の "SPECIFYING REVISIONS" の節を
// 確認してください。

[[Updating-a-repository-With-git-fetch]]
Updating a repository with git fetch
------------------------------------
// === git fetch を用いたリポジトリの更新

Eventually the developer cloned from will do additional work in her
repository, creating new commits and advancing the branches to point
at the new commits.
// 複製(clone)元の開発者はいずれ自身のリポジトリに変更を加えたり、
// 新しいコミットを作成したり、新しいコミットを参照したブランチを作成するでしょう。


The command "git fetch", with no arguments, will update all of the
remote-tracking branches to the latest version found in her
repository.  It will not touch any of your own branches--not even the
"master" branch that was created for you on clone.
// "git fetch" コマンドは、引数なしの場合、全てのリモート追跡している
// ブランチを複製元リポジトリの最新バージョンの状態に更新します。
// この動作は、自分自身のブランチについては何も変更しません。
// -- "master"ブランチも同じです、それは複製時にあなたの開発用に
// 作られたものです。

[[fetching-branches]]
Fetching branches from other repositories
-----------------------------------------
// === 他のリポジトリからのブランチの取得

You can also track branches from repositories other than the one you
cloned from, using linkgit:git-remote[1]:
// 複製元以外のリポジトリにあるブランチを追跡することもできます。
// そうするには linkgit:git-remote[1] を使用します：

-------------------------------------------------
$ git remote add linux-nfs git://linux-nfs.org/pub/nfs-2.6.git
$ git fetch linux-nfs
* refs/remotes/linux-nfs/master: storing branch 'master' ...
  commit: bf81b46
-------------------------------------------------

New remote-tracking branches will be stored under the shorthand name
that you gave "git remote add", in this case linux-nfs:
// 新しいリモート追跡ブランチは "git remote add" で指定した
// 省略名で格納され、上記場合は linux-nfs です：

-------------------------------------------------
$ git branch -r
linux-nfs/master
origin/master
-------------------------------------------------

If you run "git fetch <remote>" later, the tracking branches for the
named <remote> will be updated.
// "git fetch <remote>" をその後に実行すると、<remote> という名前の
// 追跡ブランチが更新されます。

If you examine the file .git/config, you will see that git has added
a new stanza:
//  .git/config ファイルを見ると、git が新しい節を追加したことを
// 確認できます。

-------------------------------------------------
$ cat .git/config
...
[remote "linux-nfs"]
	url = git://linux-nfs.org/pub/nfs-2.6.git
	fetch = +refs/heads/*:refs/remotes/linux-nfs/*
...
-------------------------------------------------

This is what causes git to track the remote's branches; you may modify
or delete these configuration options by editing .git/config with a
text editor.  (See the "CONFIGURATION FILE" section of
linkgit:git-config[1] for details.)
// これは、git がリモートブランチを追跡する為に作成したものです；
// テキストエディタで .git/config を編集し、これらの設定オプションを
// 変更、削除することもできます。
// (詳細は linkgit:git-config[1] の "CONFIGURATION FILE" を参照してください)

[[exploring-git-history]]
Exploring git history
=====================
// == 履歴の探索

Git is best thought of as a tool for storing the history of a
collection of files.  It does this by storing compressed snapshots of
the contents of a file hierarchy, together with "commits" which show
the relationships between these snapshots.
// git はファイルの集合の履歴を格納するツールとして
// とても良く考慮されたツールです。
// ファイル階層の中身を圧縮したスナップショットと
// スナップショット間の関係を表す "commit" を格納することで
// これを実現しています。

Git provides extremely flexible and fast tools for exploring the
history of a project.
// git は非常に柔軟で高速に動作するプロジェクトの履歴探索ツールです。

We start with one specialized tool that is useful for finding the
commit that introduced a bug into a project.
// プロジェクトにバグを入れ込んだコミットを見つける為の便利な
// 特殊ツールの説明からはじめましょう。

[[using-bisect]]
How to use bisect to find a regression
--------------------------------------
// === リグレッションを見つける為の bisect の使用方法

Suppose version 2.6.18 of your project worked, but the version at
"master" crashes.  Sometimes the best way to find the cause of such a
regression is to perform a brute-force search through the project's
history to find the particular commit that caused the problem.  The
linkgit:git-bisect[1] command can help you do this:
// プロジェクトのバージョン 2.6.18 では動作するが、"master" ブランチの
// 最新バージョンではクラッシュするとしましょう。
// そのようなリグレッションの原因を探し出す最良の方法は
// プロジェクトの履歴を総当たりで検索し、問題を引き起こす特定のコミットを見つけることです。
// linkgit:git-bisect[1] コマンドはこの作業の手伝いをしてくれます：

-------------------------------------------------
$ git bisect start
$ git bisect good v2.6.18
$ git bisect bad master
Bisecting: 3537 revisions left to test after this
[65934a9a028b88e83e2b0f8b36618fe503349f8e] BLOCK: Make USB storage depend on SCSI rather than selecting it [try #6]
-------------------------------------------------

If you run "git branch" at this point, you'll see that git has
temporarily moved you in "(no branch)". HEAD is now detached from any
branch and points directly to a commit (with commit id 65934...) that
is reachable from "master" but not from v2.6.18. Compile and test it,
and see whether it crashes. Assume it does crash. Then:
// この時点で "git branch" を実行すると、git は一時的に "(no branch)"
// に移動していることが確認できます。
// HEADはいまやあらゆるブランチから分離されており、
// "master" からは到達可能だが、v2.6.18 からは到達できない
// コミット(id が 65934... のコミット)を指しています。
// コンパイルとテストをし、クラッシュするかを確認します。
// もしクラッシュするのなら、以下のように：

-------------------------------------------------
$ git bisect bad
Bisecting: 1769 revisions left to test after this
[7eff82c8b1511017ae605f0c99ac275a7e21b867] i2c-core: Drop useless bitmaskings
-------------------------------------------------

checks out an older version.  Continue like this, telling git at each
stage whether the version it gives you is good or bad, and notice
that the number of revisions left to test is cut approximately in
half each time.
// として、より古いバージョンを確認します。このように
// git に各段階でそのバージョンが good か bad かを伝える作業を続け、
// テストすべきリビジョンの残数は各回で約半分ずつに削られていきます。

After about 13 tests (in this case), it will output the commit id of
the guilty commit.  You can then examine the commit with
linkgit:git-show[1], find out who wrote it, and mail them your bug
report with the commit id.  Finally, run
// (今回の場合では)約13回テストした後、罪を犯したコミットの id を
// 見つけることができます。そのコミットに対して linkgit:git-show[1] を実行し、
// 誰がそのコミットを書いたかを見つけ出し、コミットの id を添えて、
// バグレポートをメールします。最後に、

-------------------------------------------------
$ git bisect reset
-------------------------------------------------

to return you to the branch you were on before.
// を実行し、以前いたブランチに戻ます。

Note that the version which `git bisect` checks out for you at each
point is just a suggestion, and you're free to try a different
version if you think it would be a good idea.  For example,
occasionally you may land on a commit that broke something unrelated;
run
// ここで注意すべきことは`git bisect` が各状態でチェックアウトする
// バージョンが単なる提案にすぎないことです。
// 違うバージョンをテストしてもかまわないのです。
// 例えば、関係のない変更をしているコミット上にいるかもしれません；
// その時は以下を実行してください。

-------------------------------------------------
$ git bisect visualize
-------------------------------------------------

which will run gitk and label the commit it chose with a marker that
says "bisect".  Choose a safe-looking commit nearby, note its commit
id, and check it out with:
// これはgitk が実行し、選択したコミットに"bisect"いうマーカーを付けます。
// 近くの安全そうなコミットを、コミットIDに注意して、
// 次のコマンドでチェックアウトします。

-------------------------------------------------
$ git reset --hard fb47ddb2db...
-------------------------------------------------

then test, run "bisect good" or "bisect bad" as appropriate, and
continue.
// そしてテストし、"bisect good" または "bisect bad" の適切な方を実行し、
// 作業を続けます。

Instead of "git bisect visualize" and then "git reset --hard
fb47ddb2db...", you might just want to tell git that you want to skip
the current commit:
// "git bisect visualize"を実行して"git reset --hard fb47ddb2db..."
// を実行するかわりに、単に現在のコミットをスキップしたいかもしれません。
// その場合は以下を実行してください。

-------------------------------------------------
$ git bisect skip
-------------------------------------------------

In this case, though, git may not eventually be able to tell the first
bad one between some first skipped commits and a later bad commit.
// しかしこの場合にgitは結果的いくつかの最初のスキップされたコミットと
// その後の悪いコミットの間にある最初の悪いコミットが
// わからなくなる可能性があります。

There are also ways to automate the bisecting process if you have a
test script that can tell a good from a bad commit. See
linkgit:git-bisect[1] for more information about this and other "git
bisect" features.
// もし良いコミットと悪いコミットを判断することが可能な
// テストスクリプトがあるなら、bisect作業の自動化には
// いくつかの方法があります。
// 詳細はlinkgit:git-bisect[1]をご覧ください。

[[naming-commits]]
Naming commits
--------------
// === コミットの指定方法

We have seen several ways of naming commits already:
// 既にコミットの指定方法をいくつか紹介してきました：

	- 40-hexdigit object name
//	- 40桁の16進数からなるオブジェクト名
	- branch name: refers to the commit at the head of the given
	  branch
//	- ブランチ名： 指定したブランチの head を参照します
	- tag name: refers to the commit pointed to by the given tag
	  (we've seen branches and tags are special cases of
	  <<how-git-stores-references,references>>).
//	- タグ名： 指定したタグが指し示すコミットを参照します
//	  (<<how-git-stores-references,references>> でブランチとタグの特殊な場合について
//	   見てきました)
	- HEAD: refers to the head of the current branch
//	- HEAD：現在のブランチの head を参照します

There are many more; see the "SPECIFYING REVISIONS" section of the
linkgit:git-rev-parse[1] man page for the complete list of ways to
name revisions.  Some examples:
// 他にもたくさんあります；リビジョンの呼び方の完全なリストは
// linkgit:git-rev-parse[1] の man ページにある "SPECIFYING REVISIONS" の節で
// 確認できます。

-------------------------------------------------
$ git show fb47ddb2 # the first few characters of the object name
// 		    # オブジェクト名の先頭の数文字は
		    # are usually enough to specify it uniquely
// 		    # そのコミットを特定するのに通常は十分です。
$ git show HEAD^    # the parent of the HEAD commit
//		    # HEAD コミットの親
$ git show HEAD^^   # the grandparent
//		    # 祖父母
$ git show HEAD~4   # the great-great-grandparent
//		    # 祖父母の祖父母
-------------------------------------------------

Recall that merge commits may have more than one parent; by default,
^ and ~ follow the first parent listed in the commit, but you can
also choose:
// マージコミットは１つ以上の親を持ちます；デフォルトでは
// ^ と ~ はコミットリストの１つ目の親を指しますが、
// 次のように指定することもできます；

-------------------------------------------------
$ git show HEAD^1   # show the first parent of HEAD
//		    # HEAD の１つ目の親
$ git show HEAD^2   # show the second parent of HEAD
//		    # HEAD の２つ目の親
-------------------------------------------------

In addition to HEAD, there are several other special names for
commits:
// HEAD の他にも、コミットを指す特殊な名前があります：

Merges (to be discussed later), as well as operations such as
`git reset`, which change the currently checked-out commit, generally
set ORIG_HEAD to the value HEAD had before the current operation.
// (後に説明する)マージは、`git reset` のような操作と同じように、
// 現在チェックアウトしているコミットを変更し、
// 一般的には ORIG_HEAD に現在の操作以前にもっていた HEAD の値をセットします。

The `git fetch` operation always stores the head of the last fetched
branch in FETCH_HEAD.  For example, if you run `git fetch` without
specifying a local branch as the target of the operation
// `git fetch` の操作は、常に最後にフェッチしたブランチのヘッドを FETCH_HEAD に
// 格納します。例えば、操作対象であるローカルブランチを指定せずに `git fetch` を
// 実行した場合、

-------------------------------------------------
$ git fetch git://example.com/proj.git theirbranch
-------------------------------------------------

the fetched commits will still be available from FETCH_HEAD.
// フェッチされるコミットは FETCH_HEAD 取得されます。

When we discuss merges we'll also see the special name MERGE_HEAD,
which refers to the other branch that we're merging in to the current
branch.
// マージについて議論するとき、MERGE_HEAD という特別な名前を目にします。
// これは、現在のブランチにマージしようとしているもう一方のブランチを
// 参照しています。

The linkgit:git-rev-parse[1] command is a low-level command that is
occasionally useful for translating some name for a commit to the object
name for that commit:
// linkgit:git-rev-parse[1] コマンドは、低レベルのコマンドであり
// コミットに対する名前をコミットのオブジェクト名に変換するのに役立ちます。

-------------------------------------------------
$ git rev-parse origin
e05db0fd4f31dde7005f075a84f96b360d05984b
-------------------------------------------------

[[creating-tags]]
Creating tags
-------------
// === タグの作成方法

We can also create a tag to refer to a particular commit; after
running
// 特定のコミットを参照する為にタグを作成することができます；
// 以下の操作を実行すると、

-------------------------------------------------
$ git tag stable-1 1b2e1d63ff
-------------------------------------------------

You can use stable-1 to refer to the commit 1b2e1d63ff.
// stable-1 という名前で 1b2e1d63ff のコミットを参照できるようになります。

This creates a "lightweight" tag.  If you would also like to include a
comment with the tag, and possibly sign it cryptographically, then you
should create a tag object instead; see the linkgit:git-tag[1] man page
for details.
// これは "軽量" タグと呼ばれるものです。
// タグにコメントを含めたい場合や、暗号化して署名したい場合には、
// その代わりにタグオブジェクトを作成することができます；詳細は
// linkgit:git-tag[1] の man ページを参照してください。

[[browsing-revisions]]
Browsing revisions
------------------
// === リビジョンの閲覧方法

The linkgit:git-log[1] command can show lists of commits.  On its
own, it shows all commits reachable from the parent commit; but you
can also make more specific requests:
// linkgit:git-log[1] コマンドはコミットの一覧を表示します。
// 現在のブランチ上にある親コミットから到達可能な全てのコミットを表示します。；
// しかし、さらに特定のリクエストをすることもできます：

-------------------------------------------------
$ git log v2.5..	# commits since (not reachable from) v2.5
//			# v2.5以降のコミット(v2.5から到達不能なコミット)
$ git log test..master	# commits reachable from master but not test
//			# master から到達可能だが、test からは到達可能でないコミット
$ git log master..test	# ...reachable from test but not master
//			# test から到達可能だが、master からは到達可能でないコミット
$ git log master...test	# ...reachable from either test or master,
//			# test または master から到達可能だが、
			#    but not both
//			# 両方からは到達可能でない...
$ git log --since="2 weeks ago" # commits from the last 2 weeks
//			# 最近２週間のコミット
$ git log Makefile      # commits which modify Makefile
//			# Makefile を修正しているコミット
$ git log fs/		# ... which modify any file under fs/
//			# fs/ 配下のファイルを修正している...
$ git log -S'foo()'	# commits which add or remove any file data
//			# 文字列 'foo()' に一致する全てのファイルを
			# matching the string 'foo()'
//			# 追加または削除しているコミット
-------------------------------------------------

And of course you can combine all of these; the following finds
commits since v2.5 which touch the Makefile or any file under fs:
// そしてもちろん、これら全てを組み合わせることもできます；
// 以下は v2.5 以降のコミットで、Makefile 又は fs 配下のファイルを変更している
// コミットを検索します。

-------------------------------------------------
$ git log v2.5.. Makefile fs/
-------------------------------------------------

You can also ask git log to show patches:
// git log を使用し、パッチを表示することもできます：

-------------------------------------------------
$ git log -p
-------------------------------------------------

See the "--pretty" option in the linkgit:git-log[1] man page for more
display options.
// 他の表示オプションについては linkgit:git-log[1] の man ページにある "--pretty" オプション
// を参照してください。

Note that git log starts with the most recent commit and works
backwards through the parents; however, since git history can contain
multiple independent lines of development, the particular order that
commits are listed in may be somewhat arbitrary.
// git log は最新のコミットから開始し、親を辿って後方に検索します；
// しかし、git の履歴は複数の独立した開発ラインを含むことができる為、
// 一覧表示されるコミットの順番はいくらか任意になります。

[[generating-diffs]]
Generating diffs
----------------
// === 差分の生成方法

You can generate diffs between any two versions using
linkgit:git-diff[1]:
// linkgit:git-diff[1] を使用すると２つのバージョン間の差分を
// 生成することができます：

-------------------------------------------------
$ git diff master..test
-------------------------------------------------

That will produce the diff between the tips of the two branches.  If
you'd prefer to find the diff from their common ancestor to test, you
can use three dots instead of two:
// これは２つのブランチの先端の間の差分を表示します。
// ２つのブランチの共通の祖先から test までの差分を表示したい場合は
// ドットを２つではなく３つとし、次のようにします：

-------------------------------------------------
$ git diff master...test
-------------------------------------------------

Sometimes what you want instead is a set of patches; for this you can
use linkgit:git-format-patch[1]:
// 時には差分ではなく各パッチの集合が必要な場合もあります；その際には
// linkgit:git-format-patch[1]: を使用します：

-------------------------------------------------
$ git format-patch master..test
-------------------------------------------------

will generate a file with a patch for each commit reachable from test
but not from master.
// このようにすると、test から到達可能だが、master からは到達できない各コミットの
// パッチを含むファイルを生成できます。

[[viewing-old-file-versions]]
Viewing old file versions
-------------------------
// === 古いファイルバージョンの参照

You can always view an old version of a file by just checking out the
correct revision first.  But sometimes it is more convenient to be
able to view an old version of a single file without checking
anything out; this command does that:
// 特定のリビジョンをチェックアウトすることで、ファイルの古いバージョンを表示させる
// ことができます。しかし時にはある１つのファイルの古いバージョンを
// チェックアウトせずに表示できると便利です；
// 次のコマンドでそれができます：

-------------------------------------------------
$ git show v2.5:fs/locks.c
-------------------------------------------------

Before the colon may be anything that names a commit, and after it
may be any path to a file tracked by git.
// コロン(:) の前はコミットを指す任意の名前で、その後ろは
// git が追跡しているファイルの任意のパスです。

[[history-examples]]
Examples
--------
// === 例

[[counting-commits-on-a-branch]]
Counting the number of commits on a branch
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ==== ブランチ上のコミット数のカウント

Suppose you want to know how many commits you've made on "mybranch"
since it diverged from "origin":
// "origin" から分岐した以降に "mybranch" 上で行ったコミットの数を知りたい
// とします：

-------------------------------------------------
$ git log --pretty=oneline origin..mybranch | wc -l
-------------------------------------------------

Alternatively, you may often see this sort of thing done with the
lower-level command linkgit:git-rev-list[1], which just lists the SHA-1's
of all the given commits:
// あるいは、下位レベルのコマンド linkgit:git-rev-list[1] を使用し、
// 指定したコミットすべての SHA-1 をリスト表示することで行うこともできます：

-------------------------------------------------
$ git rev-list origin..mybranch | wc -l
-------------------------------------------------

[[checking-for-equal-branches]]
Check whether two branches point at the same history
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ==== ２つのブランチが同じ履歴点にあるかの確認

Suppose you want to check whether two branches point at the same point
in history.
// ２つのブランチが同じ履歴点にいるかどうかを確認したいとします。

-------------------------------------------------
$ git diff origin..master
-------------------------------------------------

will tell you whether the contents of the project are the same at the
two branches; in theory, however, it's possible that the same project
contents could have been arrived at by two different historical
routes.  You could compare the object names:
// この操作により、プロジェクトの中身が２つのブランチで同じであるか
// どうかを確認できます；しかし、理論的には同じプロジェクト内容が
// ２つの異なる履歴ルートによって作られることもありえます。
// (訳注：コミットIDは違うが中身が一緒の場合もありえる)
// 従って、オブジェクト名を比較すべきです：

-------------------------------------------------
$ git rev-list origin
e05db0fd4f31dde7005f075a84f96b360d05984b
$ git rev-list master
e05db0fd4f31dde7005f075a84f96b360d05984b
-------------------------------------------------

Or you could recall that the ... operator selects all commits
contained reachable from either one reference or the other but not
both: so
// あるいは、"..." のオペレータを使用し、一方からのみ到達可能な
// 全てのコミットを表示してみることです：つまり、

-------------------------------------------------
$ git log origin...master
-------------------------------------------------

will return no commits when the two branches are equal.
// を行い、２つのブランチが等しい時は、コミットが全く表示されません。

[[finding-tagged-descendants]]
Find first tagged version including a given fix
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ==== 与えられた fix を含む最初にタグ付けしたバージョンを探す

Suppose you know that the commit e05db0fd fixed a certain problem.
You'd like to find the earliest tagged release that contains that
fix.
// e05db0fd がある問題を解決したコミットであるとし、
// その解決を含む最も早いタグ付けされたリリースを探したいとします。

Of course, there may be more than one answer--if the history branched
after commit e05db0fd, then there could be multiple "earliest" tagged
releases.
// もちろん、その答えは１つ以上あります--コミット e05db0fd 以降に
// 履歴が分岐しているなら、複数の "最も早い" タグ付けされたリリースが存在します。

You could just visually inspect the commits since e05db0fd:
// e05db0fd 以降のコミットを視覚的に調査することで行えます：

-------------------------------------------------
$ gitk e05db0fd..
-------------------------------------------------

Or you can use linkgit:git-name-rev[1], which will give the commit a
name based on any tag it finds pointing to one of the commit's
descendants:
// あるいは linkgit:git-name-rev[1] を使用し、あるタグに基づいた
// そのコミットの子孫の１つを指し示す名前を表示することができます：
// (訳注：訳が不正確かな)

-------------------------------------------------
$ git name-rev --tags e05db0fd
e05db0fd tags/v1.5.0-rc1^0~23
-------------------------------------------------

The linkgit:git-describe[1] command does the opposite, naming the
revision using a tag on which the given commit is based:
// linkgit:git-describe[1] コマンドはこれとは反対のことをします。
// 指定したコミットのベースになるタグ名を使用してそのリビジョンの名前を
// 表示します。

-------------------------------------------------
$ git describe e05db0fd
v1.5.0-rc0-260-ge05db0f
-------------------------------------------------

but that may sometimes help you guess which tags might come after the
given commit.
// しかし、それは時にはどのタグが指定したコミットの後に現れるかを
// 推測する手助けになります。

If you just want to verify whether a given tagged version contains a
given commit, you could use linkgit:git-merge-base[1]:
// 指定したタグ付けされたバージョンが特定のコミットを含むかどうかを
// 確認したい場合は、linkgit:git-merge-base[1] を使用します：

-------------------------------------------------
$ git merge-base e05db0fd v1.5.0-rc1
e05db0fd4f31dde7005f075a84f96b360d05984b
-------------------------------------------------

The merge-base command finds a common ancestor of the given commits,
and always returns one or the other in the case where one is a
descendant of the other; so the above output shows that e05db0fd
actually is an ancestor of v1.5.0-rc1.
// merge-base コマンドは指定したコミットの共通の祖先を検索し、
// 一方が他方の子孫である場合にはそのどちらかを表示します；
// 従って上記出力は e05db0fd が実際に v1.5.0-rc1 の祖先であることを
// 示しています。

Alternatively, note that
// 代わりに、

-------------------------------------------------
$ git log v1.5.0-rc1..e05db0fd
-------------------------------------------------

will produce empty output if and only if v1.5.0-rc1 includes e05db0fd,
because it outputs only commits that are not reachable from v1.5.0-rc1.
// とすると、v1.5.0-rc1 が e05db0fd を含んでいる場合に限り何も出力をしません、
// 何故なら v1.5.0-rc1 から到達できないコミットだけが表示されるからです。

As yet another alternative, the linkgit:git-show-branch[1] command lists
the commits reachable from its arguments with a display on the left-hand
side that indicates which arguments that commit is reachable from.  So,
you can run something like
// As yet another alternative, the linkgit:git-show-branch[1] command lists
// the commits reachable from its arguments with a display on the left-hand
// side that indicates which arguments that commit is reachable from.  So,
// you can run something like
// (訳注：訳せないので、原文のまま載せます)

-------------------------------------------------
$ git show-branch e05db0fd v1.5.0-rc0 v1.5.0-rc1 v1.5.0-rc2
! [e05db0fd] Fix warnings in sha1_file.c - use C99 printf format if
available
 ! [v1.5.0-rc0] GIT v1.5.0 preview
  ! [v1.5.0-rc1] GIT v1.5.0-rc1
   ! [v1.5.0-rc2] GIT v1.5.0-rc2
...
-------------------------------------------------

then search for a line that looks like
// then search for a line that looks like

-------------------------------------------------
+ ++ [e05db0fd] Fix warnings in sha1_file.c - use C99 printf format if
available
-------------------------------------------------

Which shows that e05db0fd is reachable from itself, from v1.5.0-rc1, and
from v1.5.0-rc2, but not from v1.5.0-rc0.
// Which shows that e05db0fd is reachable from itself, from v1.5.0-rc1, and
// from v1.5.0-rc2, but not from v1.5.0-rc0.

[[showing-commits-unique-to-a-branch]]
Showing commits unique to a given branch
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ==== 指定したブランチにだけ存在するコミットを表示する

Suppose you would like to see all the commits reachable from the branch
head named "master" but not from any other head in your repository.
// "master" という名前のブランチヘッドから到達可能だが自分のリポジトリ上の
// 他のヘッドからは到達できないコミットを全て参照したいとします。

We can list all the heads in this repository with
linkgit:git-show-ref[1]:
// linkgit:git-show-ref[1] を使用するとこのリポジトリの全てのヘッドを
// 一覧表示できます：

-------------------------------------------------
$ git show-ref --heads
bf62196b5e363d73353a9dcf094c59595f3153b7 refs/heads/core-tutorial
db768d5504c1bb46f63ee9d6e1772bd047e05bf9 refs/heads/maint
a07157ac624b2524a059a3414e99f6f44bebc1e7 refs/heads/master
24dbc180ea14dc1aebe09f14c8ecf32010690627 refs/heads/tutorial-2
1e87486ae06626c2f31eaa63d26fc0fd646c8af2 refs/heads/tutorial-fixes
-------------------------------------------------

We can get just the branch-head names, and remove "master", with
the help of the standard utilities cut and grep:
// ブランチヘッドの名前を取得し、"master" の行を削除しすることができます。
// 標準ユーティリティである cut と grep の助けを使用して：

-------------------------------------------------
$ git show-ref --heads | cut -d' ' -f2 | grep -v '^refs/heads/master'
refs/heads/core-tutorial
refs/heads/maint
refs/heads/tutorial-2
refs/heads/tutorial-fixes
-------------------------------------------------

And then we can ask to see all the commits reachable from master
but not from these other heads:
// そして、master から到達可能だがそれ以外のヘッドからは到達できない
// 全てのコミットをたずねることができます：

-------------------------------------------------
$ gitk master --not $( git show-ref --heads | cut -d' ' -f2 |
				grep -v '^refs/heads/master' )
-------------------------------------------------

Obviously, endless variations are possible; for example, to see all
commits reachable from some head but not from any tag in the repository:
// 明らかに、絶え間ない変形もありえます；例えば、いくつかのヘッドからは到達可能だが、
// リポジトリ内のどのタグからも到達できないコミットを全て表示するには：

-------------------------------------------------
$ gitk $( git show-ref --heads ) --not  $( git show-ref --tags )
-------------------------------------------------

(See linkgit:git-rev-parse[1] for explanations of commit-selecting
syntax such as `--not`.)
// (`--not` のようなコミットを選択する構文の説明は linkgit:git-rev-parse[1]
// を参照してください)

[[making-a-release]]
Creating a changelog and tarball for a software release
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ==== チェンジログとソフトウェアリリース用の tarball を作成する

The linkgit:git-archive[1] command can create a tar or zip archive from
any version of a project; for example:
// linkgit:git-archive[1] コマンドはどのプロジェクトのバージョンからも
// tar 又は zip アーカイブを作成できます；例えば：

-------------------------------------------------
$ git archive --format=tar --prefix=project/ HEAD | gzip >latest.tar.gz
-------------------------------------------------

will use HEAD to produce a tar archive in which each filename is
preceded by "project/".
// これは HEAD を使用し、各ファイルが "project/" が先行する tar アーカイブを
// 生成します。

If you're releasing a new version of a software project, you may want
to simultaneously make a changelog to include in the release
announcement.
// ソフトウェアプロジェクトの新しいバージョンをリリースする場合、
// リリースアナウンスを含める為、チェンジログを同時に作成したいかもしれません。

Linus Torvalds, for example, makes new kernel releases by tagging them,
then running:
// Linux Torvalds は例えば、それらにタグを付け、以下を実行することで
// 新しいカーネルリリースを作ります：

-------------------------------------------------
$ release-script 2.6.12 2.6.13-rc6 2.6.13-rc7
-------------------------------------------------

where release-script is a shell script that looks like:
// ここで、release-script はシェルスクリプトで、以下のような内容です：

-------------------------------------------------
#!/bin/sh
stable="$1"
last="$2"
new="$3"
echo "# git tag v$new"
echo "git archive --prefix=linux-$new/ v$new | gzip -9 > ../linux-$new.tar.gz"
echo "git diff v$stable v$new | gzip -9 > ../patch-$new.gz"
echo "git log --no-merges v$new ^v$last > ../ChangeLog-$new"
echo "git shortlog --no-merges v$new ^v$last > ../ShortLog"
echo "git diff --stat --summary -M v$last v$new > ../diffstat-$new"
-------------------------------------------------

and then he just cut-and-pastes the output commands after verifying that
they look OK.
// そして、彼はそれらを確認してOKであることを見た後、単に出力されたコマンドを
// カット＆ペーストします。

[[Finding-comments-With-given-Content]]
Finding commits referencing a file with given content
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ==== 指定した中身をもつファイルを参照するコミットを検索する

Somebody hands you a copy of a file, and asks which commits modified a
file such that it contained the given content either before or after the
commit.  You can find out with this:
// 誰かがあなたにファイルのコピーを手渡し、どのコミットがそのように修正し、
// コミットの前または後にそのような内容を含んだのかを問い合わせたとします。
// その場合、次のようにしてそれを見つけ出します：

-------------------------------------------------
$  git log --raw --abbrev=40 --pretty=oneline |
	grep -B 1 `git hash-object filename`
-------------------------------------------------

Figuring out why this works is left as an exercise to the (advanced)
student.  The linkgit:git-log[1], linkgit:git-diff-tree[1], and
linkgit:git-hash-object[1] man pages may prove helpful.
// これが何故動作するかの説明は、(上級の)学生の演習として残しておきます。
// linkgit:git-log[1]、linkgit:git-diff-tree[1] そして、linkgit:git-hash-object[1]
// の man ページが理解の助けになります。

[[Developing-With-git]]
Developing with git
===================
// == git を使用した開発

[[telling-git-your-name]]
Telling git your name
---------------------
// === git に自分の名前を教える

Before creating any commits, you should introduce yourself to git.  The
easiest way to do so is to make sure the following lines appear in a
file named .gitconfig in your home directory:
// コミットをする前に、git に自己紹介をすべきです。
// 一番簡単な方法はホームディレクトリ下にある .gitconfig というファイルに
// 次の行が表示されていることを確認することです。

------------------------------------------------
[user]
	name = Your Name Comes Here
	email = you@yourdomain.example.com
------------------------------------------------

(See the "CONFIGURATION FILE" section of linkgit:git-config[1] for
details on the configuration file.)
// (設定ファイルの詳細は linkgit:git-config[1] の "CONFIGURATION FILE" 節を
// 参照してください)


[[creating-a-new-repository]]
Creating a new repository
-------------------------
// === 新規リポジトリの作成

Creating a new repository from scratch is very easy:
// ゼロから新規リポジトリを作成するのはとても簡単です：

-------------------------------------------------
$ mkdir project
$ cd project
$ git init
-------------------------------------------------

If you have some initial content (say, a tarball):
// 最初に登録したいものがある場合は (tarball の場合)：

-------------------------------------------------
$ tar xzvf project.tar.gz
$ cd project
$ git init
$ git add . # include everything below ./ in the first commit:
// 	    # ./ 以下にある全てを最初のコミットに含めます
$ git commit
-------------------------------------------------

[[how-to-make-a-commit]]
How to make a commit
--------------------
// === コミットの方法

Creating a new commit takes three steps:
// 新しいコミットを作成するには３つのステップが必要です：

	1. Making some changes to the working directory using your
	   favorite editor.
	2. Telling git about your changes.
	3. Creating the commit using the content you told git about
	   in step 2.
//	1. 好きなエディタを使用し、作業ディレクトリに変更を加えます。
//	2. 変更したことを git に伝えます。
//	3. ステップ２で git に伝えた内容を使用してコミットを作成します。

In practice, you can interleave and repeat steps 1 and 2 as many
times as you want: in order to keep track of what you want committed
at step 3, git maintains a snapshot of the tree's contents in a
special staging area called "the index."
// 実際には、ステップ１と２を相互に好きなだけ繰り返すことができます：
// ステップ３でコミットしたいものの追跡を保つ為、git は "索引(index)" と呼ばれる
// 特別なエリア内にツリーの中身のスナップショットを保管しています。

At the beginning, the content of the index will be identical to
that of the HEAD.  The command "git diff --cached", which shows
the difference between the HEAD and the index, should therefore
produce no output at that point.
// 最初は索引の中身は HEAD の中身と同じです。
// コマンド "git diff --cached" は HEAD と索引間の差分を表示する為、
// この時点では何も出力しません。

Modifying the index is easy:
// 索引を変更するのは容易です：

To update the index with the new contents of a modified file, use
// 索引を新しく修正したファイルの中身で更新するには、以下のようにします。

-------------------------------------------------
$ git add path/to/file
-------------------------------------------------

To add the contents of a new file to the index, use
// 新しいファイルの中身を索引に追加するにも、以下のようにします。

-------------------------------------------------
$ git add path/to/file
-------------------------------------------------

To remove a file from the index and from the working tree,
// 索引と作業ツリー上からファイルを削除するには、

-------------------------------------------------
$ git rm path/to/file
-------------------------------------------------

After each step you can verify that
// 各ステップを行った後には、

-------------------------------------------------
$ git diff --cached
-------------------------------------------------

always shows the difference between the HEAD and the index file--this
is what you'd commit if you created the commit now--and that
// を行うことで HEAD と索引ファイル間の差分を確認することができます。--
// これはコミットした時に作成される内容です。-- そして

-------------------------------------------------
$ git diff
-------------------------------------------------

shows the difference between the working tree and the index file.
// は、作業ツリーと索引ファイル間の差分を表示します。

Note that "git add" always adds just the current contents of a file
to the index; further changes to the same file will be ignored unless
you run `git add` on the file again.
// "git add" は常に現在のファイルの中身を索引に追加することに注意
// してください；さらに同じファイルに変更を加えても再度 `git add` をそのファイルに
// 行わない限りは無視されます。

When you're ready, just run
// 準備ができたら、

-------------------------------------------------
$ git commit
-------------------------------------------------

and git will prompt you for a commit message and then create the new
commit.  Check to make sure it looks like what you expected with
// を実行します。git はコミットのメッセージの入力を促してから
// 新しいコミットを作成します。意図した結果になっているかを確認するには、以下のようにします。

-------------------------------------------------
$ git show
-------------------------------------------------

As a special shortcut,
// 特別なショートカットとして

-------------------------------------------------
$ git commit -a
-------------------------------------------------

will update the index with any files that you've modified or removed
and create a commit, all in one step.
// というのがあります。これは変更又は削除した全てのファイルの索引を更新し
// コミットを作成する操作を、１回のステップで全て行います。

A number of commands are useful for keeping track of what you're
about to commit:
// たくさんのコマンドがコミットしようとしているものの追跡を保つ為に
// 役に立ちます：

-------------------------------------------------
$ git diff --cached # difference between HEAD and the index; what
//		    # HEAD と索引間の差分；
		    # would be committed if you ran "commit" now.
//		    # つまり、"commit" を実行したときにコミットされる内容
$ git diff	    # difference between the index file and your
//		    # 索引と作業ディレクトリ間の差分；
		    # working directory; changes that would not
//		    # つまり、"commit" を実行したときに含まれない
		    # be included if you ran "commit" now.
//		    # 変更内容
$ git diff HEAD	    # difference between HEAD and working tree; what
//		    # HEAD と作業ツリー間の差分：
		    # would be committed if you ran "commit -a" now.
//		    # つまり、"commit -a" を実行したときにコミットされる内容
$ git status	    # a brief per-file summary of the above.
//		    # 上記のサマリをファイル毎に簡潔に表示
-------------------------------------------------

You can also use linkgit:git-gui[1] to create commits, view changes in
the index and the working tree files, and individually select diff hunks
for inclusion in the index (by right-clicking on the diff hunk and
choosing "Stage Hunk For Commit").
// これらのことをするために linkgit:git-gui[1] を使用することもできます。
// git-gui は コミットの作成や、索引と作業ツリー間の差分の参照、
// 索引に含めるべき差分ハンクを個々に選択する(差分ハンクを右クリックして、
// "Stage Hunk For Commit" を選択する) ことができます。

[[creating-good-commit-messages]]
Creating good commit messages
-----------------------------
// === 良いコミットメッセージの書き方

Though not required, it's a good idea to begin the commit message
with a single short (less than 50 character) line summarizing the
change, followed by a blank line and then a more thorough
description.  Tools that turn commits into email, for example, use
the first line on the Subject line and the rest of the commit in the
body.
// 必須ではありませんが、格納メッセージを
// 次のようにするのは良い考えです。１行の短文(50文字未満)で変更のサマリを書き、
// その後に空白行を挟んで、最後により綿密な記述をまとめる。
// そうすることで、例えばコミットした内容を E-Mail に変更するツールにて、
// Subjectに最初の行を使用し、残りの行を本文にすることができます。

[[ignoring-files]]
Ignoring files
--------------
// === 無視するファイル

A project will often generate files that you do 'not' want to track with git.
This typically includes files generated by a build process or temporary
backup files made by your editor. Of course, 'not' tracking files with git
is just a matter of 'not' calling `git add` on them. But it quickly becomes
annoying to have these untracked files lying around; e.g. they make
`git add .` practically useless, and they keep showing up in the output of
`git status`.
// プロジェクトはよく git に追跡してほしく'ない'ファイルを生成します。
// 典型的なものとしては、ビルドプロセッサーが生成するファイルや、
// エディタが生成するバックアップファイルなどです。もちろん、
// git が追跡しないファイルに対して `git add`をしなければ良いだけの問題です。
// しかし、これら追跡しないファイルがいることでイライラさせられることがあります；
// 例えば、それらファイルに対しての `git add .` は実際に不要であるにも、
// 関わらず、 `git status` の出力でそれらが表示されてしまいます。

You can tell git to ignore certain files by creating a file called .gitignore
in the top level of your working directory, with contents such as:
// 作業ディレクトリのトップレベルに .gitignore という名前のファイルを作成することで、
// 無視するファイルを git に伝えることができます。

-------------------------------------------------
# Lines starting with '#' are considered comments.
// # '#' で始まる行は無視されます
# Ignore any file named foo.txt.
// # foo.txt という名前の全てのファイルを無視する
foo.txt
# Ignore (generated) html files,
// # (生成された) html ファイルは無視する
*.html
# except foo.html which is maintained by hand.
// # foo.html は例外とし、手でメンテナンスします
!foo.html
# Ignore objects and archives.
// # object と archive ファイルは無視する
*.[oa]
-------------------------------------------------

See linkgit:gitignore[5] for a detailed explanation of the syntax.  You can
also place .gitignore files in other directories in your working tree, and they
will apply to those directories and their subdirectories.  The `.gitignore`
files can be added to your repository like any other files (just run `git add
.gitignore` and `git commit`, as usual), which is convenient when the exclude
patterns (such as patterns matching build output files) would also make sense
for other users who clone your repository.
// 記述形式の詳細は linkgit:gitignore[5] を参照してください。
// 作業ツリーの他のディレクトリに .gitignore を置くこともできます。
// その場合、そのディレクトリとサブディレクトリに適用されます。
// `.gitignore` ファイルは他のファイルと同様、リポジトリに追加することができます
// (通常と同じで `git add .gitignore` と `git commit` を実行するだけです)。
// (ビルド時の出力ファイルに一致するパターンのような) 除外パターンを
// git で管理することは、
// あなたのリポジトリを複製する他のユーザにとっても便利なことです。

If you wish the exclude patterns to affect only certain repositories
(instead of every repository for a given project), you may instead put
them in a file in your repository named .git/info/exclude, or in any file
specified by the `core.excludesfile` configuration variable.  Some git
commands can also take exclude patterns directly on the command line.
See linkgit:gitignore[5] for the details.
// (プロジェクトの全てのリポジトリの代わりに)ある特定のリポジトリでだけ
// 除外パターンを適用したい場合は、リポジトリ内の .git/info/exclude という場所に
// それらを置くか、コンフィグレーション変数 `core.excludesfile` によって
// 指定することができます。git コマンドによってはコマンドラインで除外するパターンを
// 直接指定することもできます。
// 詳細は linkgit:gitignore[5] を参照してください。

[[how-to-merge]]
How to merge
------------
// === マージの方法

You can rejoin two diverging branches of development using
linkgit:git-merge[1]:
// ２つの分散した開発ブランチは linkgit:git-merge[1] を使用して
// マージできます：

-------------------------------------------------
$ git merge branchname
-------------------------------------------------

merges the development in the branch "branchname" into the current
branch.  If there are conflicts--for example, if the same file is
modified in two different ways in the remote branch and the local
branch--then you are warned; the output may look something like this:
// 上記はブランチ "branchname" の開発を現在のブランチにマージします。
// コンフリクトが発生した場合は -- 例えば、リモートブランチとローカルブランチで
// 同じファイルが２つの異なる方法で変更された場合 -- 警告が表示されます；
// 出力される内容は以下のようなものです：

-------------------------------------------------
$ git merge next
 100% (4/4) done
Auto-merged file.txt
CONFLICT (content): Merge conflict in file.txt
Automatic merge failed; fix conflicts and then commit the result.
-------------------------------------------------

Conflict markers are left in the problematic files, and after
you resolve the conflicts manually, you can update the index
with the contents and run git commit, as you normally would when
creating a new file.
// コンフリクトマーカーは問題のあるファイルに残り、コンフリクトを
// 手作業で解消した後は、索引をそのファイルの中身で更新し、
// git commit を実行することができます。通常の新しいファイルを作成するときと
// 同じようにです。

If you examine the resulting commit using gitk, you will see that it
has two parents, one pointing to the top of the current branch, and
one to the top of the other branch.
// gitk を使用しコミット結果を確認すると、それが２つの親を持っていて、
// 現在のブランチの先頭と、もうひとつのブランチの先頭とを位置している
// ことが分かります。

[[resolving-a-merge]]
Resolving a merge
-----------------
// === マージの解決

When a merge isn't resolved automatically, git leaves the index and
the working tree in a special state that gives you all the
information you need to help resolve the merge.
// マージが自動的に解決されない場合、git は索引と作業ツリーを
// 特別な状態にし、マージの解決を手助けするのに必要な全ての情報を与えて
// くれます。

Files with conflicts are marked specially in the index, so until you
resolve the problem and update the index, linkgit:git-commit[1] will
fail:
// コンフリクトしたファイルは、索引内で特別なマージが付けられ、
// その為問題を解決し索引を更新するまで、linkgit:git-commit[1] は
// 失敗します：

-------------------------------------------------
$ git commit
file.txt: needs merge
-------------------------------------------------

Also, linkgit:git-status[1] will list those files as "unmerged", and the
files with conflicts will have conflict markers added, like this:
// また、linkgit:git-status[1] はそれらのファイルを "unmerged" として表示し、
// コンフリクトしたファイルには以下のようなコンフリクトマーカーが追加されています：

-------------------------------------------------
<<<<<<< HEAD:file.txt
Hello world
=======
Goodbye
>>>>>>> 77976da35a11db4580b80ae27e8d65caf5208086:file.txt
-------------------------------------------------

All you need to do is edit the files to resolve the conflicts, and then
// すべきことは、ファイルを編集してコンフリクトを解決し以下のようにすることです。

-------------------------------------------------
$ git add file.txt
$ git commit
-------------------------------------------------

Note that the commit message will already be filled in for you with
some information about the merge.  Normally you can just use this
default message unchanged, but you may add additional commentary of
your own if desired.
// コミットメッセージは既にマージに関する情報が埋められていることに
// 注意してください。通常このデフォルトのメッセージは変更せずに使用できますが、
// 必要であれば自身のコメントを追加することもできます。

The above is all you need to know to resolve a simple merge.  But git
also provides more information to help resolve conflicts:
// 上記は単純なマージを解決する為に知る必要のある全てです。
// しかし、git はコンフリクトの解決を手助けするさらなる情報を与えてくれます。

[[conflict-resolution]]
Getting conflict-resolution help during a merge
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// === コンフリクトを解消する為の助けを得る

All of the changes that git was able to merge automatically are
already added to the index file, so linkgit:git-diff[1] shows only
the conflicts.  It uses an unusual syntax:
// git が自動的にマージできた全ての変更は既に索引ファイルに
// 追加されています。そして linkgit:git-diff[1] はコンフリクトだけを
// 表示します。そうするには通常の構文を使用します：

-------------------------------------------------
$ git diff
diff --cc file.txt
index 802992c,2b60207..0000000
--- a/file.txt
+++ b/file.txt
@@@ -1,1 -1,1 +1,5 @@@
++<<<<<<< HEAD:file.txt
 +Hello world
++=======
+ Goodbye
++>>>>>>> 77976da35a11db4580b80ae27e8d65caf5208086:file.txt
-------------------------------------------------

Recall that the commit which will be committed after we resolve this
conflict will have two parents instead of the usual one: one parent
will be HEAD, the tip of the current branch; the other will be the
tip of the other branch, which is stored temporarily in MERGE_HEAD.
// このコンフリクトを解決した後、コミットされる予定の内容は
// 通常と違って２つの親を持っていることを思い出してください；一方は
// HEAD、つまり現在のブランチの先端；もう一方はもうひとつのブランチの先端で
// MERGE_HEAD に格納されています。

During the merge, the index holds three versions of each file.  Each of
these three "file stages" represents a different version of the file:
// マージしている間、索引は各ファイルの３つのバージョンを持っています。
// この３つはそれぞれファイルの異なる３つの "ファイルステージ" を表現しています：

-------------------------------------------------
$ git show :1:file.txt	# the file in a common ancestor of both branches
// 			# 両方のブランチの共通祖先のファイル
$ git show :2:file.txt	# the version from HEAD.
// 			# HEAD にあるバージョン
$ git show :3:file.txt	# the version from MERGE_HEAD.
// 			# MERGE_HEAD にあるバージョン
-------------------------------------------------

When you ask linkgit:git-diff[1] to show the conflicts, it runs a
three-way diff between the conflicted merge results in the work tree with
stages 2 and 3 to show only hunks whose contents come from both sides,
mixed (in other words, when a hunk's merge results come only from stage 2,
that part is not conflicting and is not shown.  Same for stage 3).
// コンフリクトが起こっている箇所を表示するために
// linkgit:git-diff[1]を実行すると、
// コンフリクトが起こったマージ結果の間の
// 三方向の差分(three-way diff)が表示されます。
// 差分にはステージ2と3双方からきたコンテンツ
// が混ざった状態で含まれています。
// (言い換えるとハンクのマージ結果が
// ステージ2だけからなされる場合その部分ではコンフリクトは起こらず
// 表示されません。ステージ3についても同じです)

The diff above shows the differences between the working-tree version of
file.txt and the stage 2 and stage 3 versions.  So instead of preceding
each line by a single "+" or "-", it now uses two columns: the first
column is used for differences between the first parent and the working
directory copy, and the second for differences between the second parent
and the working directory copy.  (See the "COMBINED DIFF FORMAT" section
of linkgit:git-diff-files[1] for a details of the format.)
// 上記の差分は file.txt の作業ツリーのバージョンとステージ２とステージ３の
// バージョン間の差分を表示します。その為、各行の先頭に１つの "+" または "-" が
// 付けられるかわりに、２つの列が使用されます：１つ目は
// １つ目の親と作業ディレクトリコピーの間の差分を表すのに利用され、
// ２つ目は２つ目の親と作業ディレクトリコピーの間の差分を表示するのに利用されます。
// (このフォーマットの詳細は linkgit:git-diff-files[1] の "COMBINED DIFF FORMAT" の
// 節を参照してください)

After resolving the conflict in the obvious way (but before updating the
index), the diff will look like:
// コンフリクトを通常と同じ方法で解決した後、(indexの更新前に) diff を
// 実行すると次のように表示されます：

-------------------------------------------------
$ git diff
diff --cc file.txt
index 802992c,2b60207..0000000
--- a/file.txt
+++ b/file.txt
@@@ -1,1 -1,1 +1,1 @@@
- Hello world
 -Goodbye
++Goodbye world
-------------------------------------------------

This shows that our resolved version deleted "Hello world" from the
first parent, deleted "Goodbye" from the second parent, and added
"Goodbye world", which was previously absent from both.
// これは、解決済みのバージョンが 一つ目の親から "Hello world" を削除し、
// ２つ目の親から "Goodbye" を削除し、
// 両方の親に存在しない "Goodbye world" を追加したことを表しています。

Some special diff options allow diffing the working directory against
any of these stages:
// 他の特別な diff オプションを使用すると、これら任意のステージと
// 作業ディレクトリとの差分を表示することができます。

-------------------------------------------------
$ git diff -1 file.txt		# diff against stage 1
// 				# ステージ１との diff
$ git diff --base file.txt	# same as the above
// 				# 上記と同じ
$ git diff -2 file.txt		# diff against stage 2
// 				# ステージ２との diff
$ git diff --ours file.txt	# same as the above
// 				# 上記と同じ
$ git diff -3 file.txt		# diff against stage 3
// 				# ステージ３との diff
$ git diff --theirs file.txt	# same as the above.
// 				# 上記と同じ
-------------------------------------------------

The linkgit:git-log[1] and linkgit:gitk[1] commands also provide special help
for merges:
// linkgit:git-log[1] と linkgit:gitk[1] コマンドもまた
// merge の手助けをしてくれます。

-------------------------------------------------
$ git log --merge
$ gitk --merge
-------------------------------------------------

These will display all commits which exist only on HEAD or on
MERGE_HEAD, and which touch an unmerged file.
// これらは、HEAD または MERGE_HEAD にだけ存在する全てのコミットを表示し、
// マージされていないファイルを表示します。

You may also use linkgit:git-mergetool[1], which lets you merge the
unmerged files using external tools such as Emacs or kdiff3.
// linkgit:git-mergetool を利用することもできます。これを利用すると
// Emacs や kdiff3 のような外部ツールを使用してマージを行うことができます。

Each time you resolve the conflicts in a file and update the index:
// ファイルのコンフリクトを解決した後には、索引を更新してください：

-------------------------------------------------
$ git add file.txt
-------------------------------------------------

the different stages of that file will be "collapsed", after which
`git diff` will (by default) no longer show diffs for that file.
// すると、そのファイルの各ステージは "崩壊" され、
// `git diff` はもはや (デフォルトでは) そのファイルに対する差分を表示しません。

[[undoing-a-merge]]
Undoing a merge
---------------
// === マージの取り消し

If you get stuck and decide to just give up and throw the whole mess
away, you can always return to the pre-merge state with
// マージ作業に行き詰まり、全ての処置を捨て去る場合には、
// いつでもマージ前の状態に戻ることができます。次のようにします。

-------------------------------------------------
$ git reset --hard HEAD
-------------------------------------------------

Or, if you've already committed the merge that you want to throw away,
// あるいは、既に削除したいマージ結果をコミット済みの場合には、次のようにします。

-------------------------------------------------
$ git reset --hard ORIG_HEAD
-------------------------------------------------

However, this last command can be dangerous in some cases--never
throw away a commit you have already committed if that commit may
itself have been merged into another branch, as doing so may confuse
further merges.
// しかし、最後のコマンドは、幾つかの場合に危険となりえます。-- そのコミットが
// 他のブランチにマージされている場合は、決してそのコミットを削除しないでください。
// もしそうしたなら、さらにマージする場合に混乱が起きます。

[[fast-forwards]]
Fast-forward merges
-------------------
// === 高速前進(Fast-forward)マージ

There is one special case not mentioned above, which is treated
differently.  Normally, a merge results in a merge commit, with two
parents, one pointing at each of the two lines of development that
were merged.
// 上記で説明してこなかった特別なケースがあります。
// 通常マージコミットにおけるマージ結果は２つの親を持ち、
// 各親はマージした２つの開発ラインのそれぞれを指し示しています。

However, if the current branch is a descendant of the other--so every
commit present in the one is already contained in the other--then git
just performs a "fast forward"; the head of the current branch is moved
forward to point at the head of the merged-in branch, without any new
commits being created.
// そのため、現在のブランチが他方の子孫である場合には -- つまり
// 全てのコミットが既に他方のコミットに含まれている場合には -- git は
// "fast forward" を行います；現在のブランチの先頭はマージされるブランチの
// 先頭の位置に進められ、新しいコミットは作成されません。

[[fixing-mistakes]]
Fixing mistakes
---------------
// === 修正間違い

If you've messed up the working tree, but haven't yet committed your
mistake, you can return the entire working tree to the last committed
state with
// 作業ツリーに手を入れたが、間違いをまだコミットしていない場合は、
// 以下のようにして作業ツリーを最後にコミットした状態に戻すことができます。

-------------------------------------------------
$ git reset --hard HEAD
-------------------------------------------------

If you make a commit that you later wish you hadn't, there are two
fundamentally different ways to fix the problem:
// コミットした後ですべきではなかったと気が付いた時は、
// ２つの異なる解決方法があります：

	1. You can create a new commit that undoes whatever was done
	by the old commit.  This is the correct thing if your
	mistake has already been made public.
//	1. 変更を取り消す新しいコミットを作成する。
//	既に間違いを公開してしまった場合にはこれは正しいやり方です。

	2. You can go back and modify the old commit.  You should
	never do this if you have already made the history public;
	git does not normally expect the "history" of a project to
	change, and cannot correctly perform repeated merges from
	a branch that has had its history changed.
//	2. 元に戻して古いコミットを修正する。
//	履歴を公開した後の場合は、決してこれをしてはいけません；
//	通常、git は プロジェクトの履歴が変更されないことを想定しています。
//	そして、履歴が変更されたブランチからは正しくマージを繰り返すことが
//	できません。

[[reverting-a-commit]]
Fixing a mistake with a new commit
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ==== 新しいコミットで間違いを修正する

Creating a new commit that reverts an earlier change is very easy;
just pass the linkgit:git-revert[1] command a reference to the bad
commit; for example, to revert the most recent commit:
// 前の変更を取り消す新しいコミットを作成するのはとても簡単です；
// 単に linkgit:git-revert[1] コマンドに間違ったコミットへの参照を
// 渡すだけです；例えば、直前のコミットを元に戻すには：

-------------------------------------------------
$ git revert HEAD
-------------------------------------------------

This will create a new commit which undoes the change in HEAD.  You
will be given a chance to edit the commit message for the new commit.
// この操作により、HEAD の変更を取り消す新しいコミットが作成されます。
// また、新しいコミットに対するコミットメッセージが促されます。

You can also revert an earlier change, for example, the next-to-last:
// より過去の変更を取り消すこともできます、例えば、２つ前の場合：

-------------------------------------------------
$ git revert HEAD^
-------------------------------------------------

In this case git will attempt to undo the old change while leaving
intact any changes made since then.  If more recent changes overlap
with the changes to be reverted, then you will be asked to fix
conflicts manually, just as in the case of <<resolving-a-merge,
resolving a merge>>.
// この場合 git はそれ以前の変更はそのまま残し、指定したコミットの変更だけを
// 取り消そうとします。指定コミットより後の変更内容が取り消す変更内容とオーバーラップ
// している場合は、<<resolving-a-merge,マージの解決>> の場合と同じく、
// コンフリクトを手動で解決するよう促されます。

[[fixing-a-mistake-by-rewriting-history]]
Fixing a mistake by rewriting history
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ==== 履歴を再編集して間違いを訂正する

If the problematic commit is the most recent commit, and you have not
yet made that commit public, then you may just
<<undoing-a-merge,destroy it using `git reset`>>.
// 問題のあるコミットが直前のコミットであり、まだ公開していない場合は、
// 単に<<undoing-a-merge,`git reset`を使用した削除>>を行うと良いです。

Alternatively, you
can edit the working directory and update the index to fix your
mistake, just as if you were going to <<how-to-make-a-commit,create a
new commit>>, then run
// また、代わりに、作業ディレクトリを編集し間違いを訂正した後、索引を更新
// することもできます。<<how-to-make-a-commit,新しいコミットの作成>> で
// 示した手順で作業していたなら、次のようにします。

-------------------------------------------------
$ git commit --amend
-------------------------------------------------

which will replace the old commit by a new commit incorporating your
changes, giving you a chance to edit the old commit message first.
// これにより、古いコミットが変更内容が記録された新しいコミットに置き換わり、
// 過去にコミットしたメッセージを編集することもできます。

Again, you should never do this to a commit that may already have
been merged into another branch; use linkgit:git-revert[1] instead in
that case.
// 再注意となりますが、他のブランチに既にマージしているコミットに対しては
// 決してこの操作を行わないでください；その場合は、linkgit:git-revert[1]
// を使用してください。

It is also possible to replace commits further back in the history, but
this is an advanced topic to be left for
<<cleaning-up-history,another chapter>>.
// 履歴内のさらに過去のコミットを置き換えることもできますが、
// <<cleaning-up-history,次章>> の上級トピックスとして残しておきます。

[[checkout-of-path]]
Checking out an old version of a file
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ==== 古いバージョンファイルのチェックアウト

In the process of undoing a previous bad change, you may find it
useful to check out an older version of a particular file using
linkgit:git-checkout[1].  We've used `git checkout` before to switch
branches, but it has quite different behavior if it is given a path
name: the command
// 以前の間違った変更を取消作業の中で、linkgit:git-checkout[1] を使用して
// 特定ファイルの古いバージョンをチェックアウトすると便利な場合があるかもしれません。
// これまで branch を切り替える際に `git checkout` を使用してきましたが、
// パス名が与えられた場合には全くことなる動作をします：
// 次のコマンド

-------------------------------------------------
$ git checkout HEAD^ path/to/file
-------------------------------------------------

replaces path/to/file by the contents it had in the commit HEAD^, and
also updates the index to match.  It does not change branches.
// は、path/to/file をコミット HEAD^ の時の内容で置き換え、
// 索引の更新も行ないます。ブランチは変更しません。

If you just want to look at an old version of the file, without
modifying the working directory, you can do that with
linkgit:git-show[1]:
// 単にそのファイルの古いバージョンを参照したいだけの時は、
// linkgit:git-show[1] を使用すると、作業ディレクトリを修正せずに
// そのバージョンのファイルを表示できます：

-------------------------------------------------
$ git show HEAD^:path/to/file
-------------------------------------------------

which will display the given version of the file.

[[interrupted-work]]
Temporarily setting aside work in progress
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ==== 作業中の仕事を一時的に脇に片付ける

While you are in the middle of working on something complicated, you
find an unrelated but obvious and trivial bug.  You would like to fix it
before continuing.  You can use linkgit:git-stash[1] to save the current
state of your work, and after fixing the bug (or, optionally after doing
so on a different branch and then coming back), unstash the
work-in-progress changes.
// あなたが何か複雑な作業をしている途中に、今の作業とは関係のない明らかなバグを
// みつけたとします。作業を中断してそのバグを処置したいとします。
// linkgit:git-stash[1] を使用すると、現在の作業状態を保存し、
// バグ処置をした後 (あるいは、異なるブランチ上で処置を行い、元に戻り)、
// 作業中の状態に戻すことができます。

------------------------------------------------
$ git stash save "work in progress for foo feature"
------------------------------------------------

This command will save your changes away to the `stash`, and
reset your working tree and the index to match the tip of your
current branch.  Then you can make your fix as usual.
// このコマンドはあなたの変更を `stash` に保存し、
// 作業ディレクトリをリセットし、索引を現在のブランチの tip に一致
// させます。通常の手順でバグの処置をしてください。

------------------------------------------------
... edit and test ...
$ git commit -a -m "blorpl: typofix"
------------------------------------------------

After that, you can go back to what you were working on with
`git stash apply`:
// その後、`git stash apply` を用いて作業していた時の状態に
// 戻ることができます。

------------------------------------------------
$ git stash apply
------------------------------------------------


[[ensuring-good-performance]]
Ensuring good performance
-------------------------
// === パフォーマンスを確保する

On large repositories, git depends on compression to keep the history
information from taking up too much space on disk or in memory.
// 大きなリポジトリでは、git はディスクとメモリの使用量を節約するため、
// 履歴の情報を圧縮して管理することができます。

This compression is not performed automatically.  Therefore you
should occasionally run linkgit:git-gc[1]:
// この圧縮は自動的には行なわれません。従って
// 時々 linkgit:git-gc[1] を実行する必要があります：

-------------------------------------------------
$ git gc
-------------------------------------------------

to recompress the archive.  This can be very time-consuming, so
you may prefer to run `git gc` when you are not doing other work.
// アーカイブを圧縮する処理はたくさんの時間がかかるため、
// `git gc` をするときは、他の作業をしない方が良いでしょう。


[[ensuring-reliability]]
Ensuring reliability
--------------------
// === 信頼性の確保

[[checking-for-corruption]]
Checking the repository for corruption
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ==== リポジトリの不正を確認する

The linkgit:git-fsck[1] command runs a number of self-consistency checks
on the repository, and reports on any problems.  This may take some
time.  The most common warning by far is about "dangling" objects:
// linkgit:git-fsck[1] コマンドはリポジトリに対してたくさんの自己一貫性チェックを
// 実行し、あらゆる問題を報告します。この作業にはいくらかの時間が
// かかります。最も多い警告は "dangling" オブジェクトに関するものです：

-------------------------------------------------
$ git fsck
dangling commit 7281251ddd2a61e38657c827739c57015671a6b3
dangling commit 2706a059f258c6b245f298dc4ff2ccd30ec21a63
dangling commit 13472b7c4b80851a1bc551779171dcb03655e9b5
dangling blob 218761f9d90712d37a9c5e36f406f92202db07eb
dangling commit bf093535a34a4d35731aa2bd90fe6b176302f14f
dangling commit 8e4bec7f2ddaa268bef999853c25755452100f8e
dangling tree d50bb86186bf27b681d25af89d3b5b68382e4085
dangling tree b24c2473f1fd3d91352a624795be026d64c8841f
...
-------------------------------------------------

Dangling objects are not a problem.  At worst they may take up a little
extra disk space.  They can sometimes provide a last-resort method for
recovering lost work--see <<dangling-objects>> for details.
// Dangling オブジェクトは無害です。悪くとも幾らかのディスクスペースを
// 余計に消費するだけです。これらは時に紛失した作業内容を復旧させる
// 最後の機会を与えてくれます -- 詳細は <<dangling-objects>> を参照してください。

[[recovering-lost-changes]]
Recovering lost changes
~~~~~~~~~~~~~~~~~~~~~~~
// ==== 過去の変更を復旧させる

[[reflogs]]
Reflogs
^^^^^^^
// ===== 参照ログ(Reflogs)

Say you modify a branch with `linkgit:git-reset[1] --hard`, and then
realize that the branch was the only reference you had to that point in
history.
// `linkgit:git-reset[1] --hard` を使用してブランチを修正した後に
// 履歴上でそれを参照しているのがそのブランチであることに気がついたと
// します。

Fortunately, git also keeps a log, called a "reflog", of all the
previous values of each branch.  So in this case you can still find the
old history using, for example,
// 幸運なことに、git は "reflog" と呼ばれるログを保持しており、
// 各ブランチの過去全ての値を保持しています。従ってこの場合
// 古い履歴を例えば次のようにして見つけ出すことができます：

-------------------------------------------------
$ git log master@{1}
-------------------------------------------------

This lists the commits reachable from the previous version of the
"master" branch head.  This syntax can be used with any git command
that accepts a commit, not just with git log.  Some other examples:
// このコマンドは "master" ブランチヘッドの１つ前のバージョンから到達可能なコミットの一覧を表示します。
// この構文は git log 以外にもコミットを引数に持つ任意の git コマンドに利用
// できます。以下は例です：

-------------------------------------------------
$ git show master@{2}		# See where the branch pointed 2,
// 				# ２つ前のブランチの状態を表示
$ git show master@{3}		# 3, ... changes ago.
// 				# ３つ前のブランチの状態を表示
$ gitk master@{yesterday}	# See where it pointed yesterday,
// 				# 昨日の状態を表示
$ gitk master@{"1 week ago"}	# ... or last week
// 				# １週間前の状態を表示
$ git log --walk-reflogs master	# show reflog entries for master
// 				# master に対する reflog エントリを表示します
-------------------------------------------------

A separate reflog is kept for the HEAD, so
// 分割された reflog は HEAD を保つため、

-------------------------------------------------
$ git show HEAD@{"1 week ago"}
-------------------------------------------------

will show what HEAD pointed to one week ago, not what the current branch
pointed to one week ago.  This allows you to see the history of what
you've checked out.
// は、１週間前に現在のブランチが指していた場所を指すのではなく、
// １週間前に HEAD が指していた場所を表示します。
// これにより、チェックアウトしていた場所の履歴を確認することができます。

The reflogs are kept by default for 30 days, after which they may be
pruned.  See linkgit:git-reflog[1] and linkgit:git-gc[1] to learn
how to control this pruning, and see the "SPECIFYING REVISIONS"
section of linkgit:git-rev-parse[1] for details.
// reflog はデフォルトでは30日間保存され、その後削除されます。
// linkgit:git-reflog[1] と linkgit:git-gc[1] を参照すると、
// reflog がどのように削除されるかを学ぶことができます。
// 詳細は linkgit:git-rev-parse[1] の "SPECIFYING REVISIONS" の節を参照してください。

Note that the reflog history is very different from normal git history.
While normal history is shared by every repository that works on the
same project, the reflog history is not shared: it tells you only about
how the branches in your local repository have changed over time.
// reflog の履歴は通常の git の履歴と大きく違うことに注意してください。
// 通常の履歴は同じプロジェクトの各リポジトリ間で共有されますが、
// reflog は共有されません：あなたのローカルリポジトリのブランチが時間と
// ともにどのように変更されたかを説明するだけです。

[[dangling-object-recovery]]
Examining dangling objects
^^^^^^^^^^^^^^^^^^^^^^^^^^
// ==== dangling オブジェクトを試す

In some situations the reflog may not be able to save you.  For example,
suppose you delete a branch, then realize you need the history it
contained.  The reflog is also deleted; however, if you have not yet
pruned the repository, then you may still be able to find the lost
commits in the dangling objects that `git fsck` reports.  See
<<dangling-objects>> for the details.
// いくつかの場面で、reflog を用いても救済できない場合があります。例えば、
// ブランチを削除した後に、そこにあった履歴が必要になったような場合です。
// この時は reflog もまた削除されます；しかし、リポジトリをまだ削除していない場合は、
// `git fsck` がリポートする dangling オブジェクト内に削除したコミットを見つけられる
// 場合があります。詳細は <<dangling-objects>> を参照してください。

-------------------------------------------------
$ git fsck
dangling commit 7281251ddd2a61e38657c827739c57015671a6b3
dangling commit 2706a059f258c6b245f298dc4ff2ccd30ec21a63
dangling commit 13472b7c4b80851a1bc551779171dcb03655e9b5
...
-------------------------------------------------

You can examine
one of those dangling commits with, for example,
// これら dangling コミットの一つを例えば以下のようにして見ることができます。

------------------------------------------------
$ gitk 7281251ddd --not --all
------------------------------------------------

which does what it sounds like: it says that you want to see the commit
history that is described by the dangling commit(s), but not the
history that is described by all your existing branches and tags.  Thus
you get exactly the history reachable from that commit that is lost.
(And notice that it might not be just one commit: we only report the
"tip of the line" as being dangling, but there might be a whole deep
and complex commit history that was dropped.)
// これは見たままのことをします：つまり、dangling コミットが表示する
// コミット履歴のうち、存在する全てのブランチとタグに含まれていないコミットを
// 表示します。従って、紛失したそのコミットから到達可能な履歴を全て
// 得ることができます。
// (それは単に１つのコミットではないかもしれない点に注意してください：
// "ラインの先端(tip)"を dangling として報告するだけであり、捨てられた深く複雑な
// コミットの全てであるかもしれないからです)

If you decide you want the history back, you can always create a new
reference pointing to it, for example, a new branch:
// 履歴を元に戻したい時は、それを参照する新しいブランチを作成してください。
// 例えば、次のようにします：

------------------------------------------------
$ git branch recovered-branch 7281251ddd
------------------------------------------------

Other types of dangling objects (blobs and trees) are also possible, and
dangling objects can arise in other situations.
// dangling オブジェクトの他の型 (blob や tree)も存在します。
// それらは他の状況で発生します。


[[sharing-development]]
Sharing development with others
===============================
// == 他のユーザと開発を共有する

[[getting-updates-With-git-pull]]
Getting updates with git pull
-----------------------------
// === git pull を使用して更新する

After you clone a repository and make a few changes of your own, you
may wish to check the original repository for updates and merge them
into your own work.
// リポジトリを複製し、自分でソースを変更した後には、
// 元のリポジトリが更新されているかを確認し、自分の作業ディレクトリ上に
// マージしたいと思うでしょう。

We have already seen <<Updating-a-repository-With-git-fetch,how to
keep remote tracking branches up to date>> with linkgit:git-fetch[1],
and how to merge two branches.  So you can merge in changes from the
original repository's master branch with:
// 既に linkgit:git-fetch[1] を用いて
// <<Updating-a-repository-With-git-fetch,外部追跡ブランチを最新に保つ方法>>
// と２つのブランチをマージする方法を見てきました。
// 従って、元のリポジトリのマスターブランチの変更をマージすることができます：

-------------------------------------------------
$ git fetch
$ git merge origin/master
-------------------------------------------------

However, the linkgit:git-pull[1] command provides a way to do this in
one step:
// しかし、linkgit:git-pull[1] コマンドを使用すれば、１回のステップで
// この操作を行うことができます。

-------------------------------------------------
$ git pull origin master
-------------------------------------------------

In fact, if you have "master" checked out, then by default "git pull"
merges from the HEAD branch of the origin repository.  So often you can
accomplish the above with just a simple
// 実際のところ、あなたが "master" をチェックアウトしていたなら、"git pull" はデフォルトでは
// 元のリポジトリの HEAD ブランチからマージを行ないます。従って
// たいていは単に以下のようにするだけで、上記のことが出来ます。

-------------------------------------------------
$ git pull
-------------------------------------------------

More generally, a branch that is created from a remote branch will pull
by default from that branch.  See the descriptions of the
branch.<name>.remote and branch.<name>.merge options in
linkgit:git-config[1], and the discussion of the `--track` option in
linkgit:git-checkout[1], to learn how to control these defaults.
// より一般的には、リモートブランチで作成されたブランチは、
// デフォルトではそのブランチから pull されます。
// それらデフォルト値のコントロール方法を理解するには、
// linkgit:git-config[1] の branch.<name>.remote と branch.<name>.merge のオプション
// の記述と、linkgit:git-checkout[1] の `--track` オプションの説明を参照してください。

In addition to saving you keystrokes, "git pull" also helps you by
producing a default commit message documenting the branch and
repository that you pulled from.
// さらに、キータイプを省略する為に "git pull" は
// pull 元のブランチとリポジトリを説明したデフォルトのコミットメッセージを
// 生成してくれます。

(But note that no such commit will be created in the case of a
<<fast-forwards,fast forward>>; instead, your branch will just be
updated to point to the latest commit from the upstream branch.)
// (しかし、<<fast-forwards,fast forward>> の場合にはそのようなコミットは
// 作成されないことに注意してください；その代わり、あなたのブランチには
// 上流のブランチの最新のコミット位置に更新されます。)

The `git pull` command can also be given "." as the "remote" repository,
in which case it just merges in a branch from the current repository; so
the commands
// `git pull` コマンドは "." を "remote" のリポジトリとして扱い、
// その場合、単に現在のリポジトリからブランチにマージを行います；
// 従って次のコマンド

-------------------------------------------------
$ git pull . branch
$ git merge branch
-------------------------------------------------

are roughly equivalent.  The former is actually very commonly used.
// は、大雑把に言えば同じです。前者は実際に広く一般に使われています。

[[submitting-patches]]
Submitting patches to a project
-------------------------------
// プロジェクトにパッチを投稿する

If you just have a few changes, the simplest way to submit them may
just be to send them as patches in email:
// 行なった変更を投稿する一番簡単な方法は email でパッチとして
// それらの変更を送信することです。

First, use linkgit:git-format-patch[1]; for example:
// 初めに、linkgit:git-format-patch[1] を使用します。；例えば：

-------------------------------------------------
$ git format-patch origin
-------------------------------------------------

will produce a numbered series of files in the current directory, one
for each patch in the current branch but not in origin/HEAD.
// により、カレントディレクトリ内に番号付けされた一連のファイルが生成されます。
// それらはカレントブランチには含まれるが origin/HEAD には含まれないパッチです。

You can then import these into your mail client and send them by
hand.  However, if you have a lot to send at once, you may prefer to
use the linkgit:git-send-email[1] script to automate the process.
Consult the mailing list for your project first to determine how they
prefer such patches be handled.
// これらをあなたのメールクライアントにインポートし、手作業でそれらを
// 送信できます。しかし、一度にたくさん送信したい時は、むしろ
// linkgit:git-send-email[1] スクリプトを使用してこの作業を自動化させたいでしょう。
// メーリングリストで助言を求め、あなたのプロジェクトがそのようなパッチを
// どのように扱うことを望むのか決定すると良いでしょう。

[[importing-patches]]
Importing patches to a project
------------------------------
// === プロジェクトにパッチをインポートする

Git also provides a tool called linkgit:git-am[1] (am stands for
"apply mailbox"), for importing such an emailed series of patches.
Just save all of the patch-containing messages, in order, into a
single mailbox file, say "patches.mbox", then run
// Git は linkgit:git-am[1] (am は "apply mailbox(メールボックスを適用する" という意味です)
// と呼ばれるツールを提供しており、このようなメールされた一連のパッチを
// インポートすることができます。
// パッチが含まれるメッセージ全部を順番に１つの mailbox ファイル、"patches.mbox" と言います、
// に保存してください。そして、以下を実行します。

-------------------------------------------------
$ git am -3 patches.mbox
-------------------------------------------------

Git will apply each patch in order; if any conflicts are found, it
will stop, and you can fix the conflicts as described in
"<<resolving-a-merge,Resolving a merge>>".  (The "-3" option tells
git to perform a merge; if you would prefer it just to abort and
leave your tree and index untouched, you may omit that option.)
// Git は各パッチを順番に適用します；もしコンフリクトが見つかった場合は、
// 適用は中止され、"<<resolving-a-merge,マージの解決>>" で説明されているように
// コンフリクトを解決してください。( "-3" のオプションは git に
// マージすることを伝えます；もし単純に変更を取り消し、
// ツリーと索引を変更したくない場合は、"-3" のオプションを省略してください。)

Once the index is updated with the results of the conflict
resolution, instead of creating a new commit, just run
// コンフリクトを解消して索引を更新した後は、
// 新しいコミットを作成する変わりに、

-------------------------------------------------
$ git am --resolved
-------------------------------------------------

and git will create the commit for you and continue applying the
remaining patches from the mailbox.
// を実行すると、コミットが生成され、mailbox にある残りのパッチの適用が
// 再開されます。

The final result will be a series of commits, one for each patch in
the original mailbox, with authorship and commit log message each
taken from the message containing each patch.
// 最終的には、一連のコミットとなり、一つ一つが元の mailbox の
// パッチに対応し、各パッチに含まれているメッセージから取得された
// 著者とコミットログメッセージが利用されます。

[[public-repositories]]
Public git repositories
-----------------------
// === git リポジトリの公開

Another way to submit changes to a project is to tell the maintainer
of that project to pull the changes from your repository using
linkgit:git-pull[1].  In the section "<<getting-updates-With-git-pull,
Getting updates with `git pull`>>" we described this as a way to get
updates from the "main" repository, but it works just as well in the
other direction.
// プロジェクトに変更を投稿するもう一つの方法はプロジェクトの管理者に
// あなたのリポジトリから linkgit:git-pull[1] を使用して変更を pull してもらうことです。
// "<<getting-updates-With-git-pull, `git pull` を使用して更新する>>" のセクションで
// 我々は "main" リポジトリから更新を取得する方法を説明してきましたが、
// 逆の方向についても同じことができます。

If you and the maintainer both have accounts on the same machine, then
you can just pull changes from each other's repositories directly;
commands that accept repository URLs as arguments will also accept a
local directory name:
// あなたと管理者が同じマシン上にアカウントを持っている場合は、
// 互いのリポジトリから直接変更を pull することができます；
// リポジトリの URL を引数として受け取ることのできるコマンドは
// ローカルのディレクトリ名もまた受け取ることができます：

-------------------------------------------------
$ git clone /path/to/repository
$ git pull /path/to/other/repository
-------------------------------------------------

or an ssh URL:
// 又は、ssh の URL :

-------------------------------------------------
$ git clone ssh://yourhost/~you/repository
-------------------------------------------------

For projects with few developers, or for synchronizing a few private
repositories, this may be all you need.
// 開発者の少ないプロジェクトや、少ないプライベートなリポジトリを同期
// するような場合、これらが必要な全てとなりえます。

However, the more common way to do this is to maintain a separate public
repository (usually on a different host) for others to pull changes
from.  This is usually more convenient, and allows you to cleanly
separate private work in progress from publicly visible work.
// しかしながら、より一般的にこれを行なうには、
// 他のユーザが変更を pull する為の独立した公開リポジトリを(通常は別のホスト上に)
// 準備する必要があります。このほうが通常はより便利で、こうすることで
// 個人の作業中の変更と公開する変更とをきれいに分けることができます。

You will continue to do your day-to-day work in your personal
repository, but periodically "push" changes from your personal
repository into your public repository, allowing other developers to
pull from that repository.  So the flow of changes, in a situation
where there is one other developer with a public repository, looks
like this:
// 日々の作業は自分の個人用リポジトリ上で行い、
// 定期的に個人用リポジトリから公開リポジトリに変更を "push" することで
// 他の開発者は公開リポジトリから変更を pull できるようになります。
// 従って、変更のフローは、公開リポジトリを持つ別の開発者が１人いるような場合には、
// 次のようになります：

                        you push
  your personal repo ------------------> your public repo
	^                                     |
	|                                     |
	| you pull                            | they pull
	|                                     |
	|                                     |
        |               they push             V
  their public repo <------------------- their repo
//                               あなたが push
//  あなたの個人リポジトリ --------------------------> あなたの公開リポジトリ
//                                                            |
//        |                                                   |
//        | あなたが pull                                     | 彼らが pull
//        |                                                   |
//        |                                                   |
//        |                      彼らが push                  V
//  彼らの公開リポジトリ <--------------------------- 彼らのリポジトリ

We explain how to do this in the following sections.
// 次のセクションでどのようにこれを行なうかを説明します。

[[setting-up-a-public-repository]]
Setting up a public repository
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ==== 公開リポジトリの設定

Assume your personal repository is in the directory ~/proj.  We
first create a new clone of the repository and tell `git daemon` that it
is meant to be public:
// ~/proj ディレクトリにあなたの個人用リポジトリがあるとします。
// 初めにリポジトリのクローンを新規作成し、`git daemon` にそれを公開することを
// 伝えます；

-------------------------------------------------
$ git clone --bare ~/proj proj.git
$ touch proj.git/git-daemon-export-ok
-------------------------------------------------

The resulting directory proj.git contains a "bare" git repository--it is
just the contents of the ".git" directory, without any files checked out
around it.
// 作成される ディレクトリ proj.git は "裸の(bare)" git リポジトリが含まれています。--
// すなわち、".git" ディレクトリの中身だけが含まれ、チェックアウトされたファイルは含みません。

Next, copy proj.git to the server where you plan to host the
public repository.  You can use scp, rsync, or whatever is most
convenient.
// 次に、proj.git を公開リポジトリのホストとするサーバにコピーします。
// scp, rsync その他使いやすいもの何を使っても良いです。

[[exporting-via-git]]
Exporting a git repository via the git protocol
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ==== git プロトコル経由での git リポジトリのエクスポート

This is the preferred method.
// これは好ましい方法です。

If someone else administers the server, they should tell you what
directory to put the repository in, and what git:// URL it will appear
at.  You can then skip to the section
"<<pushing-changes-to-a-public-repository,Pushing changes to a public
repository>>", below.
// 他のだれかがサーバ管理をしている場合は、その人に
// どこのディレクトリにリポジトリを置くと、git:// URL のどこに現れるかを
// 教えてもらってください。その場合は以下の説明はスキップして
// "<<pushing-changes-to-a-public-repository,公開リポジトリへ変更を push する>>"
// のセクションに進んでください。

Otherwise, all you need to do is start linkgit:git-daemon[1]; it will
listen on port 9418.  By default, it will allow access to any directory
that looks like a git directory and contains the magic file
git-daemon-export-ok.  Passing some directory paths as `git daemon`
arguments will further restrict the exports to those paths.
// そうでない場合にあなたがすべき事は linkgit:git-daemon[1] を開始することだけです；
// このデーモンは 9418 ポートを使用します。デフォルトでは、git ディレクトリと思われ、
// git-daemon-export-ok ファイルが存在する全てのディレクトリへのアクセスを許可します。
// `git daemon` の引数にディレクトリのパスを与えることで、
// それらパスに対してさらに制限をかけることができます。

You can also run `git daemon` as an inetd service; see the
linkgit:git-daemon[1] man page for details.  (See especially the
examples section.)
// `git daemon` は inetd サービスで動かすこともできます；
// 詳細は linkgit:git-daemon[1] を参照してください。
// (特に、例 のセクションを参照)

[[exporting-via-http]]
Exporting a git repository via http
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ==== http経由での git リポジトリのエクスポート

The git protocol gives better performance and reliability, but on a
host with a web server set up, http exports may be simpler to set up.
// git プロトコルはパフォーマンスと信頼性の面でより良いですが、
// web サーバが設定されているホストでは、http によるエクスポートの方がより簡単に設定
// できるかもしれません。

All you need to do is place the newly created bare git repository in
a directory that is exported by the web server, and make some
adjustments to give web clients some extra information they need:
// その場合に行なうべきことは、web サーバが export できるディレクトリ内に
// 裸の git リポジトリを新規作成し、webクライアントがアクセスする際に必要となる
// いくつかの追加情報を設定することだけです。：

-------------------------------------------------
$ mv proj.git /home/you/public_html/proj.git
$ cd proj.git
$ git --bare update-server-info
$ mv hooks/post-update.sample hooks/post-update
-------------------------------------------------

(For an explanation of the last two lines, see
linkgit:git-update-server-info[1] and linkgit:githooks[5].)
// (最後の２行の説明は、linkgit:git-update-server-info[1] と、
// linkgit:githooks[5] のドキュメントを参照してください。)

Advertise the URL of proj.git.  Anybody else should then be able to
clone or pull from that URL, for example with a command line like:
// proj.git の URL を通知してください。
// 他のユーザがそのURLから clone 又は pull できるようになっているはずです。
// 例えば、次のように実行します：

-------------------------------------------------
$ git clone http://yourserver.com/~you/proj.git
-------------------------------------------------

(See also
link:howto/setup-git-server-over-http.txt[setup-git-server-over-http]
for a slightly more sophisticated setup using WebDAV which also
allows pushing over http.)
// (WebDAV を使用することで http で push を行なえるようにすることもできます。
// 詳細は link:howto/setup-git-server-over-http.txt[setup-git-server-over-http]
// を参照してください)

[[pushing-changes-to-a-public-repository]]
Pushing changes to a public repository
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ==== 公開リポジトリへ変更を送信する

Note that the two techniques outlined above (exporting via
<<exporting-via-http,http>> or <<exporting-via-git,git>>) allow other
maintainers to fetch your latest changes, but they do not allow write
access, which you will need to update the public repository with the
latest changes created in your private repository.
// 上記で説明した技術(<<exporting-via-http,http>> または <<exporting-via-git,git>>
// 経由でのエクスポート) により、他の管理者があなたの最後の変更を取得できるようにはなりますが、
// それらを編集することはできません。
// 個人用リポジトリで行なった最新の変更を公開リポジトリに反映するには編集操作が必要です。

The simplest way to do this is using linkgit:git-push[1] and ssh; to
update the remote branch named "master" with the latest state of your
branch named "master", run
// 編集を行なう一番簡単な方法は  linkgit:git-push[1] と ssh を使用する方法です；
// あなたのブランチ "master" の最新の状態で、リモートブランチ "master" を更新するには、

-------------------------------------------------
$ git push ssh://yourserver.com/~you/proj.git master:master
-------------------------------------------------

or just
// または単に

-------------------------------------------------
$ git push ssh://yourserver.com/~you/proj.git master
-------------------------------------------------

// を実行します。
As with `git fetch`, `git push` will complain if this does not result in a
<<fast-forwards,fast forward>>; see the following section for details on
handling this case.
// `git fetch` と同じように `git push` は <<fast-forwards,fast forward>> されない場合に
// 文句を言います；このような場合の対応については次節を参照してください。

Note that the target of a "push" is normally a
<<def_bare_repository,bare>> repository.  You can also push to a
repository that has a checked-out working tree, but the working tree
will not be updated by the push.  This may lead to unexpected results if
the branch you push to is the currently checked-out branch!
// "push" のターゲットは通常は <<def_bare_repository,bare>> リポジトリであることに
// 注意してください。チェックアウトした作業ツリーを持つリポジトリに対しても
// push することはできますが、push しても作業ツリーは更新されません。
// その為、push したブランチが現在チェックアウトしているブランチの場合、
// 予期しない結果となります！

As with `git fetch`, you may also set up configuration options to
save typing; so, for example, after
// `git fetch` と同じように、タイピングを節約する為のオプションを
// 設定することができます；例えば、次のようにします。

-------------------------------------------------
$ cat >>.git/config <<EOF
[remote "public-repo"]
	url = ssh://yourserver.com/~you/proj.git
EOF
-------------------------------------------------

you should be able to perform the above push with just
// こうすることで次のように上記場所に push できるようになります。

-------------------------------------------------
$ git push public-repo master
-------------------------------------------------

See the explanations of the remote.<name>.url, branch.<name>.remote,
and remote.<name>.push options in linkgit:git-config[1] for
details.
// remote.<name>.url, branch.<name>.remote, remote.<name>.push の詳細は
// linkgit:git-config[1] のオプションを参照してください。

[[forcing-push]]
What to do when a push fails
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ==== push に失敗した場合の対処

If a push would not result in a <<fast-forwards,fast forward>> of the
remote branch, then it will fail with an error like:
// push の結果がリモートブランチの <<fast-forwards,fast forward>> とならない場合、
// 次のようなエラーが発生して push は失敗します：

-------------------------------------------------
error: remote 'refs/heads/master' is not an ancestor of
 local  'refs/heads/master'.
 Maybe you are not up-to-date and need to pull first?
error: failed to push to 'ssh://yourserver.com/~you/proj.git'
-------------------------------------------------

This can happen, for example, if you:
// これは、例えば次のような場合におきます：

	- use `git reset --hard` to remove already-published commits, or
//	- `git reset --hard` を使用し、すでに発行していたコミットを削除した場合、または
	- use `git commit --amend` to replace already-published commits
	  (as in <<fixing-a-mistake-by-rewriting-history>>), or
//	- `git commit --amend` を使用し、すでに発行していたコミットを差し替えた場合
//	  （<<fixing-a-mistake-by-rewriting-history,履歴を再編集して間違いを訂正する>>の手順で）、または
	- use `git rebase` to rebase any already-published commits (as
	  in <<using-git-rebase>>).
//	- `git rebase` を使用し、すでに発行したこみっちをリベースした場合
//	  （<<using-git-rebase,git rebase を使用する>> の手順で）

You may force `git push` to perform the update anyway by preceding the
branch name with a plus sign:
// ブランチ名の前に＋記号を付けることで、強制的に `git push` を実行
// することができます：

-------------------------------------------------
$ git push ssh://yourserver.com/~you/proj.git +master
-------------------------------------------------

Normally whenever a branch head in a public repository is modified, it
is modified to point to a descendant of the commit that it pointed to
before.  By forcing a push in this situation, you break that convention.
(See <<problems-With-rewriting-history>>.)
// 通常、公開したリポジトリ内のブランチヘッドを修正した時はいつでも、
// 以前指し示していた子孫のコミットを指し示すように変更されます。
// このような場合に強制的に push を行うと、規約を壊すことになります)
// (<<problems-With-rewriting-history,履歴の書き換えによって生じる問題>> を参照)

Nevertheless, this is a common practice for people that need a simple
way to publish a work-in-progress patch series, and it is an acceptable
compromise as long as you warn other developers that this is how you
intend to manage the branch.
// にもかかわらず、この方法は作業中の一連のパッチを簡単な方法で発行する必要がある場合に
// 一般に行われる方法であり、あなたがブランチを管理する方針を他の開発者に
// 伝えている限りは許容できるでしょう。

It's also possible for a push to fail in this way when other people have
the right to push to the same repository.  In that case, the correct
solution is to retry the push after first updating your work: either by a
pull, or by a fetch followed by a rebase; see the
<<setting-up-a-shared-repository,next section>> and
linkgit:gitcvs-migration[7] for more.
// push が失敗するもう一つのケースとして、同じリポジトリの push 権限を他の人にも
// 与えている場合が考えられます。その場合、はじめに pull するか
// rebase によって変更を取得した後に再度 push を試みてください；
// 詳しくは <<setting-up-a-shared-repository,次の節>> と linkgit:gitcvs-migration[7]
// を参照してください。

[[setting-up-a-shared-repository]]
Setting up a shared repository
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ==== 共有リポジトリの設定

Another way to collaborate is by using a model similar to that
commonly used in CVS, where several developers with special rights
all push to and pull from a single shared repository.  See
linkgit:gitcvs-migration[7] for instructions on how to
set this up.
// 共同作業をする為のもう一つの方法は CVSで一般に使用されているのと同じような
// モデルを使用するやり方で、特別な権限を持った複数の開発者が
// １つの共有リポジトリに対する push と pull の全てを行なうやり方です。
// この場合の設定方法については linkgit:gitcvs-migration[7] を
// 参照してください。

However, while there is nothing wrong with git's support for shared
repositories, this mode of operation is not generally recommended,
simply because the mode of collaboration that git supports--by
exchanging patches and pulling from public repositories--has so many
advantages over the central shared repository:
// しかし、git は共有リポジトリを使った運用で何も問題を起こすことはありませんが、
// この運用モードは一般には推奨されません。
// それは単に、git がサポートする共同開発のモード(つまり、パッチを交換し、
// 公開リポジトリからpull する方法)の方が、中央リポジトリよりも多くの点で
// 利点があるからです：

	- Git's ability to quickly import and merge patches allows a
	  single maintainer to process incoming changes even at very
	  high rates.  And when that becomes too much, `git pull` provides
	  an easy way for that maintainer to delegate this job to other
	  maintainers while still allowing optional review of incoming
	  changes.
//	- Git はパッチのインポートとマージを高速に行なう能力をもっており、
//	  とても頻繁に変更が行なわれる場合でもそれらのマージを一人の管理者で
//	  行なうことができます。そして、変更が多すぎる場合でも `git pull` の機能により
//	  寄せられる変更の任意レビューを行なう一方で、変更の受け入れ作業を
//	  他の管理者に容易に委任することができます。
	- Since every developer's repository has the same complete copy
	  of the project history, no repository is special, and it is
	  trivial for another developer to take over maintenance of a
	  project, either by mutual agreement, or because a maintainer
	  becomes unresponsive or difficult to work with.
//	- 各開発者が専用のリポジトリを持ち、プロジェクトの履歴の完全なコピーを
//	  持つことができるので、どれが特別なリポジトリというわけではないので、
//	  他の開発者がプロジェクトのメンテナンスを引き継ぐのもとても簡単です。
	- The lack of a central group of "committers" means there is
	  less need for formal decisions about who is "in" and who is
	  "out".
//	- "コミッター"と呼ばれる中央のグループが存在しないことにより
//	  誰が "内側" で、だれが "外側" であるかに関する正式な決定を
//	  する必要がなくなります。

[[setting-up-gitweb]]
Allowing web browsing of a repository
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ==== リポジトリのWebブラウジング

The gitweb cgi script provides users an easy way to browse your
project's files and history without having to install git; see the file
gitweb/INSTALL in the git source tree for instructions on setting it up.
// gitweb という CGI スクリプトを使用すると、プロジェクトのファイルと履歴を
// git をインストールすることなしに参照することができます：
// gitweb の設定方法は、git のソースツリーに含まれる gitweb/INSTALL ファイルを参照してください。

[[sharing-development-examples]]
Examples
--------
// === 例

[[maintaining-topic-branches]]
Maintaining topic branches for a Linux subsystem maintainer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ==== Linux のサブシステム管理者が topic ブランチを管理する方法

This describes how Tony Luck uses git in his role as maintainer of the
IA64 architecture for the Linux kernel.
// ここでは、Linux カーネルの IA64 アーキテクチャのメンテナンスを担当している
// Tony Luck の git の利用方法を紹介します。

He uses two public branches:
// 彼は２つの公開リポジトリを使用します：

 - A "test" tree into which patches are initially placed so that they
   can get some exposure when integrated with other ongoing development.
   This tree is available to Andrew for pulling into -mm whenever he
   wants.
// - "test" ツリーはパッチが最初に入れられる場所です。
//   ここで他の進行中の開発と一緒に統合されて公表されます。
//   このツリーは Andrew がいつでも -mm に pull できるようにする為のものです。
//   (訳注："-mm" とは Andrew Morton によってリリースされる実験的なカーネルパッチ群のこと。
//    -mm に入って価値を証明されると Linus のツリーに反映される)

 - A "release" tree into which tested patches are moved for final sanity
   checking, and as a vehicle to send them upstream to Linus (by sending
   him a "please pull" request.)
// - "release" ツリーはテストされたパッチが最終的に健全であることが確認された後に
//   移動され、Linus に変更を送付する乗り物として使用されます。(Linus に
//   このツリーを "pull してください" というリクエストをします)

He also uses a set of temporary branches ("topic branches"), each
containing a logical grouping of patches.
// 彼は他にも一時的なブランチ("topic branches")を使用します。
// それぞれのブランチはパッチの論理的なグループを含んでいます。

To set this up, first create your work tree by cloning Linus's public
tree:
// この設定をする為には、最初に Linus の公開ツリーを複製することで
// 作業ツリーを作成します：

-------------------------------------------------
$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git work
$ cd work
-------------------------------------------------

Linus's tree will be stored in the remote branch named origin/master,
and can be updated using linkgit:git-fetch[1]; you can track other
public trees using linkgit:git-remote[1] to set up a "remote" and
linkgit:git-fetch[1] to keep them up-to-date; see
<<repositories-and-branches>>.
// Linus のツリーは origin/master という名前のリモートブランチに格納され、
// linkgit:git-fetch[1] を使用して更新できます；他の公開ツリーも
// linkgit:git-remote[1] を使用して "remote" を設定し linkgit:git-fetch[1] で
// それらを最新に保ちます；<<repositories-and-branches>> を参照してください。

Now create the branches in which you are going to work; these start out
at the current tip of origin/master branch, and should be set up (using
the --track option to linkgit:git-branch[1]) to merge changes in from
Linus by default.
// さて、あなたが作業する為のブランチを作成しました；
// このブランチは origin/master ブランチの現在の先端から開始していて、
// (linkgit:git-branch[1] の --track オプションを使用して)
// デフォルトでは Linus からの変更をマージする設定にすべきです。

-------------------------------------------------
$ git branch --track test origin/master
$ git branch --track release origin/master
-------------------------------------------------

These can be easily kept up to date using linkgit:git-pull[1].
// これらは linkgit:git-pull[1] を用いて簡単に最新に保つことができます。

-------------------------------------------------
$ git checkout test && git pull
$ git checkout release && git pull
-------------------------------------------------

Important note!  If you have any local changes in these branches, then
this merge will create a commit object in the history (with no local
changes git will simply do a "Fast forward" merge).  Many people dislike
the "noise" that this creates in the Linux history, so you should avoid
doing this capriciously in the "release" branch, as these noisy commits
will become part of the permanent history when you ask Linus to pull
from the release branch.
// 重要な注意点！ これらのブランチにローカルな変更を加えると、
// このマージは履歴内にコミットオブジェクトを生成します (ローカルで
// 変更を加えていない時は単に "Fast forward" でマージされます)。
// 多くの人は Linux の履歴にこれが作成されることを "ノイズ" として嫌います。
// その為 "release" ブランチにこの気まぐれが行なわれるのを避けるべきです。
// これらノイズとなるコミットはあなたが Linus にリリースブランチへの pull
// を依頼するときに恒久的な履歴の一部になってしまいます。

A few configuration variables (see linkgit:git-config[1]) can
make it easy to push both branches to your public tree.  (See
<<setting-up-a-public-repository>>.)
// 幾つかの設定変数(linkgit:git-config[1] 参照)は
// 両方のブランチをあなたの公開ツリーに push するのを容易にしてくれます。
// (<<setting-up-a-public-repository>> 参照。)

-------------------------------------------------
$ cat >> .git/config <<EOF
[remote "mytree"]
	url =  master.kernel.org:/pub/scm/linux/kernel/git/aegl/linux-2.6.git
	push = release
	push = test
EOF
-------------------------------------------------

Then you can push both the test and release trees using
linkgit:git-push[1]:
// 上記により test と release の両方のツリーに linkgit:git-push[1] を
// 使用して push することができるようになります：

-------------------------------------------------
$ git push mytree
-------------------------------------------------

or push just one of the test and release branches using:
// あるいは、test と release のブランチの一方にだけ push する場合は：

-------------------------------------------------
$ git push mytree test
-------------------------------------------------

or
// あるいは、

-------------------------------------------------
$ git push mytree release
-------------------------------------------------

Now to apply some patches from the community.  Think of a short
snappy name for a branch to hold this patch (or related group of
patches), and create a new branch from the current tip of Linus's
branch:
// さて、コミュニティからの幾つかのパッチを適用することを考えます。
// このパッチ(あるいは関連するパッチグループ)を保管するブランチに
// 短く分かり易い名前を付けます。

-------------------------------------------------
$ git checkout -b speed-up-spinlocks origin
-------------------------------------------------

Now you apply the patch(es), run some tests, and commit the change(s).  If
the patch is a multi-part series, then you should apply each as a separate
commit to this branch.
// パッチを適用し、幾つかのテストを実行し、変更をコミットします。
// パッチが複数のパートから構成される場合は、それぞれを分割した
// コミットとしてこのブランチに適用すべきです。

-------------------------------------------------
$ ... patch ... test  ... commit [ ... patch ... test ... commit ]*
-------------------------------------------------

When you are happy with the state of this change, you can pull it into the
"test" branch in preparation to make it public:
// この変更状態が良好なら、"test" ブランチに pull し
// 公開する準備をします。

-------------------------------------------------
$ git checkout test && git pull . speed-up-spinlocks
-------------------------------------------------

It is unlikely that you would have any conflicts here ... but you might if you
spent a while on this step and had also pulled new versions from upstream.
// ここではコンフリクトは発生しそうにありません...しかし
// この段階までの間にしばらくの時間がかかり、上流から新しいバージョンを pull
// しているかもしれません。

Some time later when enough time has passed and testing done, you can pull the
same branch into the "release" tree ready to go upstream.  This is where you
see the value of keeping each patch (or patch series) in its own branch.  It
means that the patches can be moved into the "release" tree in any order.
// しばらく後に十分な時間が経ちテストが完了したときに、
// 同じブランチを "release" ツリーに pull し、上流に向かう準備をします。
// これは、それぞれのパッチ(あるいは一連のパッチ)をパッチ用のブランチ
// に留めておくありがたみを理解する場面です。この作業は一連のパッチが
// "release" ツリーへ任意の順番で移動できることを意味します。
// (訳注: 先を読めばわかりますが、ブランチを作って、パッチを適用すると、パッチ群
// のテストをブランチごとに並行して行なうことができます。そして、テストが完了したパッチ
// のブランチから順に release ツリーへ移動することができます。そして、各パッチ用のブラ
// ンチの状況も簡単に把握できます。)

-------------------------------------------------
$ git checkout release && git pull . speed-up-spinlocks
-------------------------------------------------

After a while, you will have a number of branches, and despite the
well chosen names you picked for each of them, you may forget what
they are for, or what status they are in.  To get a reminder of what
changes are in a specific branch, use:
// その後、たくさんのブランチが作成され、それらブランチの名前を
// 適切に指定していたとしても、それらが何であるか又は何が含まれているかを
// 忘れてしまうかもしれません。特定のブランチでどんな変更が行なわれているかを
// 思い出すには、次のようにします：

-------------------------------------------------
$ git log linux..branchname | git shortlog
-------------------------------------------------

To see whether it has already been merged into the test or release branches,
use:
// test または release ブランチに既にマージされたかどうかは
// 次のようにして確認します：

-------------------------------------------------
$ git log test..branchname
-------------------------------------------------

or
// あるいは

-------------------------------------------------
$ git log release..branchname
-------------------------------------------------

(If this branch has not yet been merged, you will see some log entries.
If it has been merged, then there will be no output.)
// (このブランチがまだマージされていない場合、いくつかのログエントリが表示されます。
// 既にマージされている場合は、何も出力されません。)

Once a patch completes the great cycle (moving from test to release,
then pulled by Linus, and finally coming back into your local
"origin/master" branch), the branch for this change is no longer needed.
You detect this when the output from:
// パッチがこの大きなサイクル(test から release に移動し、
// Linus に pull され、最終的に自身の "origin/master" ブランチに返却する流れ)
// を完遂すると変更に対するブランチは不要になります。
// このことは次の出力が空であることを確認することで検出できます：

-------------------------------------------------
$ git log origin..branchname
-------------------------------------------------

is empty.  At this point the branch can be deleted:
// この時点でブランチは削除することができます：

-------------------------------------------------
$ git branch -d branchname
-------------------------------------------------

Some changes are so trivial that it is not necessary to create a separate
branch and then merge into each of the test and release branches.  For
these changes, just apply directly to the "release" branch, and then
merge that into the "test" branch.
// 幾つかの変更は自明で、分割したブランチを作成し test と release ブランチに
// それぞれマージする必要がない場合もあります。
// そういった変更は直接 "release" ブランチに適用し、
// "test" ブランチにマージします。

To create diffstat and shortlog summaries of changes to include in a "please
pull" request to Linus you can use:
// Linus に送る "pull してください" のリクエストに含める diff 状態と
// 変更の短いサマリを作成するには、次のようにします：

-------------------------------------------------
$ git diff --stat origin..release
-------------------------------------------------

and
// そして

-------------------------------------------------
$ git log -p origin..release | git shortlog
-------------------------------------------------

Here are some of the scripts that simplify all this even further.
// 以下はこれら全てをさらに単純化するスクリプトです。

-------------------------------------------------
==== update script ====
# Update a branch in my GIT tree.  If the branch to be updated
// # GIT ツリーのブランチを更新する。更新すべきブランチが
# is origin, then pull from kernel.org.  Otherwise merge
// # origin の場合、kernel.org から pull する。そうでない時は
# origin/master branch into test|release branch
// # origin/master ブランチを test|release ブランチにマージします。

case "$1" in
test|release)
	git checkout $1 && git pull . origin
	;;
origin)
	before=$(git rev-parse refs/remotes/origin/master)
	git fetch origin
	after=$(git rev-parse refs/remotes/origin/master)
	if [ $before != $after ]
	then
		git log $before..$after | git shortlog
	fi
	;;
*)
	echo "Usage: $0 origin|test|release" 1>&2
	exit 1
	;;
esac
-------------------------------------------------

-------------------------------------------------
==== merge script ====
# Merge a branch into either the test or release branch
// # ブランチを test または release ブランチにマージ

pname=$0

usage()
{
	echo "Usage: $pname branch test|release" 1>&2
	exit 1
}

git show-ref -q --verify -- refs/heads/"$1" || {
	echo "Can't see branch <$1>" 1>&2
	usage
}

case "$2" in
test|release)
	if [ $(git log $2..$1 | wc -c) -eq 0 ]
	then
		echo $1 already merged into $2 1>&2
		exit 1
	fi
	git checkout $2 && git pull . $1
	;;
*)
	usage
	;;
esac
-------------------------------------------------

-------------------------------------------------
==== status script ====
# report on status of my ia64 GIT tree
// # ia64 GIT ツリーの状態をレポートする

gb=$(tput setab 2)
rb=$(tput setab 1)
restore=$(tput setab 9)

if [ `git rev-list test..release | wc -c` -gt 0 ]
then
	echo $rb Warning: commits in release that are not in test $restore
	git log test..release
fi

for branch in `git show-ref --heads | sed 's|^.*/||'`
do
	if [ $branch = test -o $branch = release ]
	then
		continue
	fi

	echo -n $gb ======= $branch ====== $restore " "
	status=
	for ref in test release origin/master
	do
		if [ `git rev-list $ref..$branch | wc -c` -gt 0 ]
		then
			status=$status${ref:0:1}
		fi
	done
	case $status in
	trl)
		echo $rb Need to pull into test $restore
		;;
	rl)
		echo "In test"
		;;
	l)
		echo "Waiting for linus"
		;;
	"")
		echo $rb All done $restore
		;;
	*)
		echo $rb "<$status>" $restore
		;;
	esac
	git log origin/master..$branch | git shortlog
done
-------------------------------------------------


[[cleaning-up-history]]
Rewriting history and maintaining patch series
==============================================
// == 履歴を再編集し、一連のパッチを管理する

Normally commits are only added to a project, never taken away or
replaced.  Git is designed with this assumption, and violating it will
cause git's merge machinery (for example) to do the wrong thing.
// 通常コミットはプロジェクトに追加されるのみで、削除したり置き換えられる
// ことはありません。Git はこの仮定をもとにデザインされており、
// この仮定を破ると git のマージ装置は(例えば)間違ったことをしてしまいます。

However, there is a situation in which it can be useful to violate this
assumption.
// しかし、この仮定を破ると便利なシチュエーションもあります。

[[patch-series]]
Creating the perfect patch series
---------------------------------
// === 一連の完全なパッチの作成

Suppose you are a contributor to a large project, and you want to add a
complicated feature, and to present it to the other developers in a way
that makes it easy for them to read your changes, verify that they are
correct, and understand why you made each change.
// あなたが大きなプロジェクトのコントリビュータであったと仮定し、
// 複雑な変更を加えたとします。あなたはそれを他の開発者に公表する為、
// その変更を読みやすい手順にし、それが正しいとわかることを証明し、
// 各変更を行なった理由がわかるようにしたいとします。

If you present all of your changes as a single patch (or commit), they
may find that it is too much to digest all at once.
// １つのパッチ(あるいはコミット)として変更全てを公表すると、
// 大き過ぎる為一度に全てを消化できません。

If you present them with the entire history of your work, complete with
mistakes, corrections, and dead ends, they may be overwhelmed.
// あなたの作業の完全な履歴を公表するとなると、間違いや訂正、意味無く終わったもの
// などが全て含まれ、冗長すぎてしまいます。

So the ideal is usually to produce a series of patches such that:
// 従って、通常は次のような一連のパッチを生成するのが理想的です：

	1. Each patch can be applied in order.
//	1. 各パッチが順番に適用できる。

	2. Each patch includes a single logical change, together with a
	   message explaining the change.
//	2. 各パッチは１つの論理的な変更を含み、その変更を説明する
//	   メッセージを一緒に含んでいる。

	3. No patch introduces a regression: after applying any initial
	   part of the series, the resulting project still compiles and
	   works, and has no bugs that it didn't have before.
//	3. 回帰を持ち込むようなパッチがないこと：一連のパッチの最初の部分だけを
//	   適用した場合でも、コンパイルがとおり、動作し、過去に存在しなかったバグが
//	   持ち込まれない。

	4. The complete series produces the same end result as your own
	   (probably much messier!) development process did.
//	4. 一連のパッチを完全に適用すると、最終結果があなた自身が行なった
//	   (おそらく散らかっている!)開発作業の結果と一致する。

We will introduce some tools that can help you do this, explain how to
use them, and then explain some of the problems that can arise because
you are rewriting history.
// これら作業の手助けをする幾つかのツールを紹介し、
// それらの使い方を説明し、履歴を再編集することにより発生する問題の幾つかを
// 説明します

[[using-git-rebase]]
Keeping a patch series up to date using git rebase
--------------------------------------------------
// git rebase を使用して一連のパッチを最新に保つ

Suppose that you create a branch "mywork" on a remote-tracking branch
"origin", and create some commits on top of it:
// リモート追跡ブランチ "origin" の上にブランチ "mywork" を作成し、
// 幾つかコミットを作成したとします：

-------------------------------------------------
$ git checkout -b mywork origin
$ vi file.txt
$ git commit
$ vi otherfile.txt
$ git commit
...
-------------------------------------------------

You have performed no merges into mywork, so it is just a simple linear
sequence of patches on top of "origin":
// mywork にマージをしていないので、変更は "origin" から単純に並行に
// 行なわれています。

................................................
 o--o--o <-- origin
        \
         o--o--o <-- mywork
................................................

Some more interesting work has been done in the upstream project, and
"origin" has advanced:
// プロジェクトの上流では他の興味深い変更が行なわれ、
// "origin" は発展します：

................................................
 o--o--O--o--o--o <-- origin
        \
         a--b--c <-- mywork
................................................

At this point, you could use "pull" to merge your changes back in;
the result would create a new merge commit, like this:
// この時点で、"pull" を使用して変更をマージさせることができます；
// 結果として新しいマージコミットが生成されます、次のようにです：

................................................
 o--o--O--o--o--o <-- origin
        \        \
         a--b--c--m <-- mywork
................................................

However, if you prefer to keep the history in mywork a simple series of
commits without any merges, you may instead choose to use
linkgit:git-rebase[1]:
// しかし、自分の履歴をマージ操作の無い、単純な一連のコミットの状態で
// 保ちたいのであれば、その代わりに linkgit:git-rebase[1] を使用すると
// 良いでしょう。

-------------------------------------------------
$ git checkout mywork
$ git rebase origin
-------------------------------------------------

This will remove each of your commits from mywork, temporarily saving
them as patches (in a directory named ".git/rebase-apply"), update mywork to
point at the latest version of origin, then apply each of the saved
patches to the new mywork.  The result will look like:
// これは、mywork からあなたの各コミットを削除し、一時的に
// (".git/rebase-apply" という名前のディレクトリ内に)パッチとして保存し、
// mywork を origin の最新バージョンの位置に更新し、その後で保存した
// 各パッチを新しい mywork ブランチに適用します。結果は次のようになります：


................................................
 o--o--O--o--o--o <-- origin
		 \
		  a'--b'--c' <-- mywork
................................................

In the process, it may discover conflicts.  In that case it will stop
and allow you to fix the conflicts; after fixing conflicts, use `git add`
to update the index with those contents, and then, instead of
running `git commit`, just run
// この作業中にコンフリクトが発生するかもしれません。その場合は
// コンフリクトを解決してください；コンフリクトを解消した後に
// `git add` を使用してそれらの内容で索引を更新し、
// `git commit` を実行する代わりに、

-------------------------------------------------
$ git rebase --continue
-------------------------------------------------

and git will continue applying the rest of the patches.
// を実行します。すると、残りのパッチを適用する作業が続けられます。

At any point you may use the `--abort` option to abort this process and
return mywork to the state it had before you started the rebase:
// どの時点でも `--abort` オプションを使用すると、この作業を取り消し、
// rebase を開始する前の mywork の状態に戻ることができます：

-------------------------------------------------
$ git rebase --abort
-------------------------------------------------

[[rewriting-one-commit]]
Rewriting a single commit
-------------------------
// === １つのコミットを再編集する

We saw in <<fixing-a-mistake-by-rewriting-history>> that you can replace the
most recent commit using
// <<fixing-a-mistake-by-rewriting-history,履歴を再編集して間違いを訂正する>> で見てきたように直前のコミットを
// 以下のようにして修正することができます。

-------------------------------------------------
$ git commit --amend
-------------------------------------------------

which will replace the old commit by a new commit incorporating your
changes, giving you a chance to edit the old commit message first.
// この操作は、過去のコミットをあなたが変更を受け入れる新しいコミットに
// 置き換え、過去のコミットメッセージを編集する機会を与えてくれます。

You can also use a combination of this and linkgit:git-rebase[1] to
replace a commit further back in your history and recreate the
intervening changes on top of it.  First, tag the problematic commit
with
// これと linkgit:git-rebase[1] を組み合わせることで、履歴内のさらに過去のコミットについても
// 置き換えをし、その先頭の変更に立ち入ることができます。
// 初めに、次のようにして問題のあるコミットにタグを付けます。

-------------------------------------------------
$ git tag bad mywork~5
-------------------------------------------------

(Either gitk or `git log` may be useful for finding the commit.)
// (gitk または `git log` が問題のあるコミットを見つけるのに役立ちます。)

Then check out that commit, edit it, and rebase the rest of the series
on top of it (note that we could check out the commit on a temporary
branch, but instead we're using a <<detached-head,detached head>>):
// そのコミットをチェックアウトして編集し、残りの一連の変更を
// その先頭にリベースします(ここでは <<detached-head,引き剥がされたhead>> を
// 使用する代わりに、一時的なブランチ上にコミットをチェックアウトします。)：

-------------------------------------------------
$ git checkout bad
$ # make changes here and update the index
// # ここで変更と索引の更新をします
$ git commit --amend
$ git rebase --onto HEAD bad mywork
-------------------------------------------------

When you're done, you'll be left with mywork checked out, with the top
patches on mywork reapplied on top of your modified commit.  You can
then clean up with
// これらを行なった後、チェックアウトした mywork が保たれ続け、mywork 上の
// 先頭のパッチは修正したコミットの先頭に再適用されます。
// そして、これらを片付けることができます。

-------------------------------------------------
$ git tag -d bad
-------------------------------------------------

Note that the immutable nature of git history means that you haven't really
"modified" existing commits; instead, you have replaced the old commits with
new commits having new object names.
// git の履歴が不変であるという性質は既存のコミットを実際に "変更" していない
// ことを意味していることに注意してください；代わりに、古いコミットを
// 新しいオブジェクト名を持つ新しいコミットで置き換えています。

[[reordering-patch-series]]
Reordering or selecting from a patch series
-------------------------------------------
// === 一連のパッチの並び替えや選択

Given one existing commit, the linkgit:git-cherry-pick[1] command
allows you to apply the change introduced by that commit and create a
new commit that records it.  So, for example, if "mywork" points to a
series of patches on top of "origin", you might do something like:
// 存在するコミットを引数にして linkgit:git-cherry-pick[1] コマンドを
// 実行すると、そのコミットが行なった変更を適用し、新しいコミットを
// 作成することができます。従って、例えば、"mywork" が "origin" の先頭の
// 一連のパッチを指しているなら、以下のようにすることができます：

-------------------------------------------------
$ git checkout -b mywork-new origin
$ gitk origin..mywork &
-------------------------------------------------

and browse through the list of patches in the mywork branch using gitk,
applying them (possibly in a different order) to mywork-new using
cherry-pick, and possibly modifying them as you go using `git commit --amend`.
The linkgit:git-gui[1] command may also help as it allows you to
individually select diff hunks for inclusion in the index (by
right-clicking on the diff hunk and choosing "Stage Hunk for Commit").
// そして、gitk を使用して mywork ブランチのパッチの一覧を表示し、
// cherry-pick を使用して mywork-new にそれらを(可能なら異なる順番で)適用し、
// 可能であるなら `git commit --amend` を使用してそれらを修正します。
// linkgit:git-gui[1] コマンドは個々の選択した diff ハンクを索引に含めるかどうかを
// 選択するのに役に立つかもしれません。(diff ハンクを右クリックし、
// "Stage Hunk for Commit" を選択します)

Another technique is to use `git format-patch` to create a series of
patches, then reset the state to before the patches:
// もう一つの技術は `git format-patch` を使用して一連のパッチを作成し、
// パッチの前の状態にリセットすることです：

-------------------------------------------------
$ git format-patch origin
$ git reset --hard origin
-------------------------------------------------

Then modify, reorder, or eliminate patches as preferred before applying
them again with linkgit:git-am[1].
// そして、修正し、順番を並び替え、取り除き linkgit:git-am[1] を使用して
// 再びパッチを適用します。

[[patch-series-tools]]
Other tools
-----------
// === 他のツール

There are numerous other tools, such as StGIT, which exist for the
purpose of maintaining a patch series.  These are outside of the scope of
this manual.
// 他にもツールが多数あります。例えば StGIT です。stgit は一連のパッチを
// 管理するツールです。このマニュアルの対照から外れるため、説明は省略します。

[[problems-With-rewriting-history]]
Problems with rewriting history
-------------------------------
// === 履歴の書き換えによって生じる問題

The primary problem with rewriting the history of a branch has to do
with merging.  Suppose somebody fetches your branch and merges it into
their branch, with a result something like this:
// ブランチの履歴を書き換えることによって生じる主な問題はマージに関する
// ことです。誰かがあなたのブランチをフェッチし、自分のブランチにマージ
// すると、結果は次のようになります：

................................................
 o--o--O--o--o--o <-- origin
        \        \
         t--t--t--m <-- their branch:
................................................

Then suppose you modify the last three commits:
// そして、最後の３つのコミットを修正したとします：

................................................
	 o--o--o <-- new head of origin
	/
 o--o--O--o--o--o <-- old head of origin
................................................

If we examined all this history together in one repository, it will
look like:
// もしそれらが１つのリポジトリに入っていたとすると、
// 次のようになります：

................................................
	 o--o--o <-- new head of origin
	/
 o--o--O--o--o--o <-- old head of origin
        \        \
         t--t--t--m <-- their branch:
................................................

Git has no way of knowing that the new head is an updated version of
the old head; it treats this situation exactly the same as it would if
two developers had independently done the work on the old and new heads
in parallel.  At this point, if someone attempts to merge the new head
in to their branch, git will attempt to merge together the two (old and
new) lines of development, instead of trying to replace the old by the
new.  The results are likely to be unexpected.
// Git は新しい head が古い head の更新されたバージョンであることを認識
// しません；Git はこのような状態を２つの開発者が古い head と新しい head で
// 並行に作業したものとして扱います。
// その為、だれかが当たらし head を自身のブランチにマージしようとすると、
// git は old を new に置き換える代わりに、その２つの開発ライン(old と new)
// をいっしょにマージしようとします。
// その結果は、期待したものとはことなります。

You may still choose to publish branches whose history is rewritten,
and it may be useful for others to be able to fetch those branches in
order to examine or test them, but they should not attempt to pull such
branches into their own work.
// 履歴が再編集されたブランチをまだ公開しようとするかもしれません。
// そして、それらブランチをフェッチし順番にテストするのは役に立つことだと
// 思うかもしれません。しかし、そのようなブランチを自分の作業エリアに pull
// すべきではありません。

For true distributed development that supports proper merging,
published branches should never be rewritten.
// 適切なマージをサポートする本来の分散開発では、
// 公開されたブランチは決して再編集されるべきではありません。

[[bisect-merges]]
Why bisecting merge commits can be harder than bisecting linear history
-----------------------------------------------------------------------
// === マージコミットの分割が１本線の履歴の分割よりも困難となる理由

The linkgit:git-bisect[1] command correctly handles history that
includes merge commits.  However, when the commit that it finds is a
merge commit, the user may need to work harder than usual to figure out
why that commit introduced a problem.
// linkgit:git-bisect[1] コマンドはマージコミットを含んだ履歴を正確に扱います。
// しかし、コミットがマージコミットである時は、そのコミットが何故問題を起こしている
// かの原因を見つけ出すのに苦労することがあります。

Imagine this history:
// 次の履歴を考えてください：

................................................
      ---Z---o---X---...---o---A---C---D
          \                       /
           o---o---Y---...---o---B
................................................

Suppose that on the upper line of development, the meaning of one
of the functions that exists at Z is changed at commit X.  The
commits from Z leading to A change both the function's
implementation and all calling sites that exist at Z, as well
as new calling sites they add, to be consistent.  There is no
bug at A.
// 上側の開発ライン上のコミットXにて Zから存在する関数の意味が
// 変更されたとします。ZからAにつながるコミットは、関数の実装を変更し、
// Zの時点で存在する全コール箇所と新しく追加したコール箇所の両方を変更して、
// 矛盾のない状態にしていたとします。
// A の時点ではバグはありません。

Suppose that in the meantime on the lower line of development somebody
adds a new calling site for that function at commit Y.  The
commits from Z leading to B all assume the old semantics of that
function and the callers and the callee are consistent with each
other.  There is no bug at B, either.
// それと同時に下側の開発ラインではコミットYにてその関数の新しい
// コール箇所を追加していたとします。
// ZからBにつながるコミットの全ては、その関数の古い動作を想定していて
// コール元とコール先は互いに矛盾していません。Bにもバグはありません。

Suppose further that the two development lines merge cleanly at C,
so no conflict resolution is required.
// ２つの開発ラインがきれいにマージできたとすると、
// コンフリクトの解消要求はありません。

Nevertheless, the code at C is broken, because the callers added
on the lower line of development have not been converted to the new
semantics introduced on the upper line of development.  So if all
you know is that D is bad, that Z is good, and that
linkgit:git-bisect[1] identifies C as the culprit, how will you
figure out that the problem is due to this change in semantics?
// にもかかわらず、Cのソースは壊れています。なぜなら
// 下側の開発ラインは上側の開発ラインで行われた新しい動作に変換
// されていないからです。
// したがって、linkgit:git-bisect[1] は D に問題があり、
// Z には問題ないこと、そしてC が問題の原因であると伝えます。
// どのようにしたら、問題が動作変更によるものだと見つけることが
// できるでしょうか？

When the result of a `git bisect` is a non-merge commit, you should
normally be able to discover the problem by examining just that commit.
Developers can make this easy by breaking their changes into small
self-contained commits.  That won't help in the case above, however,
because the problem isn't obvious from examination of any single
commit; instead, a global view of the development is required.  To
make matters worse, the change in semantics in the problematic
function may be just one small part of the changes in the upper
line of development.
// `git bisect` の結果が非マージコミットの場合、通常、単にそのコミットを
// 確認するだけで問題を見つけることができます。
// 開発者はコミットを自己完結したより小さいものに分割することで
// これを容易に行うことができます。しかし、
// 上記場合には１つのコミットを確認することでは問題が明らかにならない為、
// このような方法では解決の役に立ちません；その代わりに開発の大局的な視点が
// 必要となります。さらに悪いことに、問題となっている関数の動作変更が
// 上側の開発ラインの単なる小さな部分の変更であるかもしれません。

On the other hand, if instead of merging at C you had rebased the
history between Z to B on top of A, you would have gotten this
linear history:
// その一方で、C のマージをする代わりに、ZからBの履歴を Aの先頭
// にリベースした場合、次のような１行の履歴を取得することができます：

................................................................
    ---Z---o---X--...---o---A---o---o---Y*--...---o---B*--D*
................................................................

Bisecting between Z and D* would hit a single culprit commit Y*,
and understanding why Y* was broken would probably be easier.
// Z と D* の間を git bisect すると、１つの問題の原因となるコミット Y*
// を見つけることができ、Y* が何故問題を引き起こしている理由を
// 容易に理解することができるでしょう。

Partly for this reason, many experienced git users, even when
working on an otherwise merge-heavy project, keep the history
linear by rebasing against the latest upstream version before
publishing.
// 部分的にですが、この理由により、たくさん経験を積んだ git ユーザは
// マージが頻繁に行われるプロジェクトで作業する場合でさえも
// 最新の上流バージョンに対するリベースを行うことによって
// 履歴を１ラインに保つようにしています。

[[advanced-branch-management]]
Advanced branch management
==========================
// == 高度なブランチ管理

[[fetching-individual-branches]]
Fetching individual branches
----------------------------
// === 個々のブランチをフェッチする

Instead of using linkgit:git-remote[1], you can also choose just
to update one branch at a time, and to store it locally under an
arbitrary name:
// linkgit:git-remote[1] を使用する代わりに、時には１つのブランチだけを
// 更新し、任意の名前でローカルに保存することもできます：

-------------------------------------------------
$ git fetch origin todo:my-todo-work
-------------------------------------------------

The first argument, "origin", just tells git to fetch from the
repository you originally cloned from.  The second argument tells git
to fetch the branch named "todo" from the remote repository, and to
store it locally under the name refs/heads/my-todo-work.
// 最初の引数 "origin" はクローン元のリポジトリからフェッチすることを
// git に伝えています。２つ目の引数はリモートのリポジトリの "todo" という
// 名前のブランチをフェッチし、refs/heads/my-todo-work という名前で
// ローカルに保存することを git に伝えています。

You can also fetch branches from other repositories; so
// 他のリポジトリにあるブランチをフェッチすることもできます；例えば、

-------------------------------------------------
$ git fetch git://example.com/proj.git master:example-master
-------------------------------------------------

will create a new branch named "example-master" and store in it the
branch named "master" from the repository at the given URL.  If you
already have a branch named example-master, it will attempt to
<<fast-forwards,fast-forward>> to the commit given by example.com's
master branch.  In more detail:
// は "example-master" という名前の新しいブランチを作成し、
// 指定した URL にあるリポジトリの "master" という名前のブランチの内容を
// 保存します。既に "example-master" という名前のブランチが存在する場合は、
// example.com の master ブランチが与えるコミットの <<fast-forwards,fast-forward>> を
// 試みます。詳細は次の節で説明します。

[[fetch-fast-forwards]]
git fetch and fast-forwards
---------------------------
// === git fetch と fast-forwards

In the previous example, when updating an existing branch, "git fetch"
checks to make sure that the most recent commit on the remote
branch is a descendant of the most recent commit on your copy of the
branch before updating your copy of the branch to point at the new
commit.  Git calls this process a <<fast-forwards,fast forward>>.
// 前節の例では、存在するブランチを更新する時に、"git fetch" は
// リモートブランチの最新のコミットがあなたのコピーしたブランチの最新の
// コミットの子孫であることを確認してから、新しいコミットの位置に
// 更新しようとします。
// Git はこのプロセスを <<fast-forwards,fast forward>> と呼びます。

A fast forward looks something like this:
// fast forward は、以下のように見えます：

................................................
 o--o--o--o <-- old head of the branch
           \
            o--o--o <-- new head of the branch
................................................


In some cases it is possible that the new head will *not* actually be
a descendant of the old head.  For example, the developer may have
realized she made a serious mistake, and decided to backtrack,
resulting in a situation like:
// 時には、新しい head は古い head の子孫ではない可能性があります。
// 例えば、開発者が深刻な間違いをしたことに気がつき、変更を
// 元に戻すことにした場合です、その結果は次のようになります：

................................................
 o--o--o--o--a--b <-- old head of the branch
           \
            o--o--o <-- new head of the branch
................................................

In this case, "git fetch" will fail, and print out a warning.
// この場合、"git fetch" は失敗し、警告が表示されます。

In that case, you can still force git to update to the new head, as
described in the following section.  However, note that in the
situation above this may mean losing the commits labeled "a" and "b",
unless you've already created a reference of your own pointing to
them.
// その場合にも、次の節で説明する方法で、強制的に新しい head に
// 更新することができます。しかし、上記の場合には それらへの参照を既に作成していない限りは
//  "a" と "b" のコミットが紛失することを意味することに注意してください。

[[forcing-fetch]]
Forcing git fetch to do non-fast-forward updates
------------------------------------------------
// === 強制的に fast-forward を使わずに git fetch を行う

If git fetch fails because the new head of a branch is not a
descendant of the old head, you may force the update with:
// 新しいブランチの head が古い head の子孫ではない為に、
// git fetch 失敗した場合には、次のようにして強制的に
// 更新することができます：

-------------------------------------------------
$ git fetch git://example.com/proj.git +master:refs/remotes/example/master
-------------------------------------------------

Note the addition of the "+" sign.  Alternatively, you can use the "-f"
flag to force updates of all the fetched branches, as in:
// "+" 記号を追加していることに注意してください。代わりに "-f" を
// のフラグを使用し、フェッチした全てのブランチを強制的に更新することもできます：

-------------------------------------------------
$ git fetch -f origin
-------------------------------------------------

Be aware that commits that the old version of example/master pointed at
may be lost, as we saw in the previous section.
// この操作により、example/master の古いバージョンが指していたコミットは紛失して
// しまうことに注意してください。それは、前の節で説明したとおりです。

[[remote-branch-configuration]]
Configuring remote branches
---------------------------
// === リモートブランチの構成

We saw above that "origin" is just a shortcut to refer to the
repository that you originally cloned from.  This information is
stored in git configuration variables, which you can see using
linkgit:git-config[1]:
// 既に説明したように、"origin" はクローン元のリポジトリを参照する
// ショートカットです。この情報は git の構成ファイルに格納されており、
// linkgit:git-config[1] を使用して参照することができます：

-------------------------------------------------
$ git config -l
core.repositoryformatversion=0
core.filemode=true
core.logallrefupdates=true
remote.origin.url=git://git.kernel.org/pub/scm/git/git.git
remote.origin.fetch=+refs/heads/*:refs/remotes/origin/*
branch.master.remote=origin
branch.master.merge=refs/heads/master
-------------------------------------------------

If there are other repositories that you also use frequently, you can
create similar configuration options to save typing; for example,
after
// 他にも頻繁に参照するリポジトリがある場合は、タイピング数を節約するため、
// 同じように構成ファイルに登録することができます；例えば、

-------------------------------------------------
$ git config remote.example.url git://example.com/proj.git
-------------------------------------------------

then the following two commands will do the same thing:
// とすると、次の２つのコマンドは同じことをするようになります：

-------------------------------------------------
$ git fetch git://example.com/proj.git master:refs/remotes/example/master
$ git fetch example master:refs/remotes/example/master
-------------------------------------------------

Even better, if you add one more option:
// さらに、次のオプションを追加すると：

-------------------------------------------------
$ git config remote.example.fetch master:refs/remotes/example/master
-------------------------------------------------

then the following commands will all do the same thing:
// 次のコマンドは全て同じことをするようになります：

-------------------------------------------------
$ git fetch git://example.com/proj.git master:refs/remotes/example/master
$ git fetch example master:refs/remotes/example/master
$ git fetch example
-------------------------------------------------

You can also add a "+" to force the update each time:
// "+" をつけて強制的に更新することもできます：

-------------------------------------------------
$ git config remote.example.fetch +master:ref/remotes/example/master
-------------------------------------------------

Don't do this unless you're sure you won't mind "git fetch" possibly
throwing away commits on 'example/master'.
// "git fetch" が 'example/master' 上のコミットを捨て去る可能性があることを
// 嫌う場合は、この操作はしないでください。

Also note that all of the above configuration can be performed by
directly editing the file .git/config instead of using
linkgit:git-config[1].
// また、上記の構成全ては、linkgit:git-config[1] を使用する代わりに
// 直接 .git/config ファイルを編集して登録することもできます。

See linkgit:git-config[1] for more details on the configuration
options mentioned above.
// 詳細は linkgit:git-config[1] 内の 構成オプションについて触れられている
// 箇所を参照してください。


[[git-concepts]]
Git concepts
============
// == Git のコンセプト

Git is built on a small number of simple but powerful ideas.  While it
is possible to get things done without understanding them, you will find
git much more intuitive if you do.
// Git は少ない数のシンプルだが強力なアイデアで成り立っています。
// それらを理解しなくても git を利用することはできますが、
// 理解することで git をより直感的に理解できます。

We start with the most important, the  <<def_object_database,object
database>> and the <<def_index,index>>.
// 最も重要なコンセプトである <<def_object_database,オブジェクトデータベース>>
// と <<def_index,索引(index)>> の説明から開始しましょう、

[[the-object-database]]
The Object Database
-------------------
// === オブジェクトＤＢ


We already saw in <<understanding-commits>> that all commits are stored
under a 40-digit "object name".  In fact, all the information needed to
represent the history of a project is stored in objects with such names.
In each case the name is calculated by taking the SHA-1 hash of the
contents of the object.  The SHA-1 hash is a cryptographic hash function.
What that means to us is that it is impossible to find two different
objects with the same name.  This has a number of advantages; among
others:
// 既に <<understanding-commits>> で見てきたように、全てのコミットは
// 40桁の "オブジェクト名" で格納されています。実際、プロジェクトの履歴を
// 表現するのに必要な全ての情報は、そのような名前のオブジェクトとして格納されています。
// それぞれの名前はオブジェクト内容の SHA-1 ハッシュによって
// 計算されています。SHA-1ハッシュは暗号学的ハッシュ関数です。
// それはつまり、同じ名前を持つ２つの異なるオブジェクトを見つけるのが
// 不可能であることを意味します。このことは多くの利点を持っています。
// とりわけ：

- Git can quickly determine whether two objects are identical or not,
  just by comparing names.
// - Git は２つのオブジェクトが同じであるかどうかを
// 名前を比較するだけで高速に判断できます。
- Since object names are computed the same way in every repository, the
  same content stored in two repositories will always be stored under
  the same name.
// オブジェクト名が全てのリポジトリに対して同じ方法で計算されるので、
// ２つのリポジトリに格納した同じ内容は、常に同じ名前で格納されます。
- Git can detect errors when it reads an object, by checking that the
  object's name is still the SHA-1 hash of its contents.
// - オブジェクト名が自身の内容の SHA-1 ハッシュ値と一致しているかを
// 確認することで、Git はオブジェクトを読み込んだ時に、エラーを検出できます。

(See <<object-details>> for the details of the object formatting and
SHA-1 calculation.)
// (オブジェクトの形式と SHA1 計算の詳細は <<object-details>> を参照してください)

There are four different types of objects: "blob", "tree", "commit", and
"tag".
// Gitが扱う オブジェクトには４種類あります："blob", "tree", "commit" そして "tag" です。

- A <<def_blob_object,"blob" object>> is used to store file data.
// - <<def_blob_object,"blob" オブジェクト>> はファイルデータを格納するのに使用されます。
- A <<def_tree_object,"tree" object>> ties one or more
  "blob" objects into a directory structure. In addition, a tree object
  can refer to other tree objects, thus creating a directory hierarchy.
// - <<def_tree_object,"tree" オブジェクト>> は１つ以上の "blob" オブジェクトに
// リンクし、ディレクトリ構成を作ります。さらに、tree オブジェクトは
// 他の tree オブジェクトを参照できます。従って、ディレクトリ階層を作成できます。
- A <<def_commit_object,"commit" object>> ties such directory hierarchies
  together into a <<def_DAG,directed acyclic graph>> of revisions--each
  commit contains the object name of exactly one tree designating the
  directory hierarchy at the time of the commit. In addition, a commit
  refers to "parent" commit objects that describe the history of how we
  arrived at that directory hierarchy.
// - <<def_commit_object,"commit" オブジェクト>>はディレクトリ階層とリンクし、
// リビジョンの <<def_DAG,有向非巡回グラフ>>を作ります。-- 各コミットは
// そのコミット時点でのディレクトリ階層を指し示すオブジェクトの名前を
// 含みます。さらに、commit はそのディレクトリ階層に到った経路を示す
// "親" のコミットオブジェクトを参照しています。
- A <<def_tag_object,"tag" object>> symbolically identifies and can be
  used to sign other objects. It contains the object name and type of
  another object, a symbolic name (of course!) and, optionally, a
  signature.
// - <<def_tag_object,"tag" オブジェクト>> はあるオブジェクトを特定する
// シンボルの役目をし、また他のオブジェクトに署名をつける目的でも
// 利用できます。"tag" オブジェクトは、他のオブジェクトの名前と型、
// そして(もちろん)シンボリック名を持ち、時には署名も含んでいます。

The object types in some more detail:
// オブジェクトタイプの詳細：

[[commit-object]]
Commit Object
~~~~~~~~~~~~~
// ==== Commit オブジェクト

The "commit" object links a physical state of a tree with a description
of how we got there and why.  Use the --pretty=raw option to
linkgit:git-show[1] or linkgit:git-log[1] to examine your favorite
commit:
// "commit" オブジェクトはツリーの物理的な状態にリンクし、
// また、どのようにしてその記述に至ったかの情報も一緒に含んでいます。
// --pretty=raw オプション付きで linkgit:git-show[1] または linkgit:git-log[1] を
// 実行すると、特定のコミットの内容を確認できます：

------------------------------------------------
$ git show -s --pretty=raw 2be7fcb476
commit 2be7fcb4764f2dbcee52635b91fedb1b3dcf7ab4
tree fb3a8bdd0ceddd019615af4d57a53f43d8cee2bf
parent 257a84d9d02e90447b149af58b271c19405edb6a
author Dave Watson <dwatson@mimvista.com> 1187576872 -0400
committer Junio C Hamano <gitster@pobox.com> 1187591163 -0700

    Fix misspelling of 'suppress' in docs

    Signed-off-by: Junio C Hamano <gitster@pobox.com>
------------------------------------------------

As you can see, a commit is defined by:
// このように、コミットは次のように定義されています：

- a tree: The SHA-1 name of a tree object (as defined below), representing
  the contents of a directory at a certain point in time.
// - tree： ある時点のディレクトリの中身を表現する
// ツリーオブジェクト(以下で定義)の SHA-1 名。
- parent(s): The SHA-1 name of some number of commits which represent the
  immediately previous step(s) in the history of the project.  The
  example above has one parent; merge commits may have more than
  one.  A commit with no parents is called a "root" commit, and
  represents the initial revision of a project.  Each project must have
  at least one root.  A project can also have multiple roots, though
  that isn't common (or necessarily a good idea).
// - parent(s): プロジェクト履歴内のすぐ１つ前の状態を表している
// 複数のコミットの SHA-1 名。上記例では１つの parent があります；
// マージコミットでは、１つ以上の場合があります。
// parent のないコミットは "root" コミットと呼ばれ、
// プロジェクトの初期リビジョンを表します。各プロジェクトは最低１つの root を
// 持つ必要があります。プロジェクトは複数の root を持つこともできますが、
// あまり一般的ではありません(良いアイデアではありません)
- an author: The name of the person responsible for this change, together
  with its date.
// - author: この変更に対する責任者の名前と日付。
- a committer: The name of the person who actually created the commit,
  with the date it was done.  This may be different from the author, for
  example, if the author was someone who wrote a patch and emailed it
  to the person who used it to create the commit.
// - committer: このコミットを実際に作成した担当者と日付。
// committer は author とは一致しないかもしれません、例えば、
// author がパッチを作成しそれを E-Mailで別の人がそのパッチをコミットする
// ことがあります。
- a comment describing this commit.
// - このコメントに関するコメント。

Note that a commit does not itself contain any information about what
actually changed; all changes are calculated by comparing the contents
of the tree referred to by this commit with the trees associated with
its parents.  In particular, git does not attempt to record file renames
explicitly, though it can identify cases where the existence of the same
file data at changing paths suggests a rename.  (See, for example, the
-M option to linkgit:git-diff[1]).
// 注意：コミット自身は実際にどのような変更がされたかの情報を持っていません；
// 全ての変更はコミットが参照しているツリーとparents から連想されるツリーとの比較
// によって計算されます。特に、git はファイル名の変更を明示的には記録しようと
// しません。しかし、同じデータをもつファイルが存在する場合に名前変更であると
// 認識する方法があります。(例えば、linkgit:git-diff[1] の -M オプションを参照)

A commit is usually created by linkgit:git-commit[1], which creates a
commit whose parent is normally the current HEAD, and whose tree is
taken from the content currently stored in the index.
// コミットは通常 linkgit:git-commit[1] によって作成されます。
// デフォルトではその親を現在のHEADとしたコミットが作成され、
// そのツリーは現在の索引に格納されている内容が使用されます。

[[tree-object]]
Tree Object
~~~~~~~~~~~
// ==== Tree オブジェクト

The ever-versatile linkgit:git-show[1] command can also be used to
examine tree objects, but linkgit:git-ls-tree[1] will give you more
details:
// linkgit:git-show[1] コマンドは tree オブジェクトに対しても
// 使用することができますが、linkgit:git-ls-tree[1] の方が
// より詳細な情報を表示します：

------------------------------------------------
$ git ls-tree fb3a8bdd0ce
100644 blob 63c918c667fa005ff12ad89437f2fdc80926e21c    .gitignore
100644 blob 5529b198e8d14decbe4ad99db3f7fb632de0439d    .mailmap
100644 blob 6ff87c4664981e4397625791c8ea3bbb5f2279a3    COPYING
040000 tree 2fb783e477100ce076f6bf57e4a6f026013dc745    Documentation
100755 blob 3c0032cec592a765692234f1cba47dfdcc3a9200    GIT-VERSION-GEN
100644 blob 289b046a443c0647624607d471289b2c7dcd470b    INSTALL
100644 blob 4eb463797adc693dc168b926b6932ff53f17d0b1    Makefile
100644 blob 548142c327a6790ff8821d67c2ee1eff7a656b52    README
...
------------------------------------------------

As you can see, a tree object contains a list of entries, each with a
mode, object type, SHA-1 name, and name, sorted by name.  It represents
the contents of a single directory tree.
// このように、tree オブジェクトは名前順でソートされたエントリの一覧を含んでおり、
// 各エントリは mode, オブジェクトタイプ、SHA-1名、名前を持っています。
// tree は １つのディレクトリツリーの中身を表現します。

The object type may be a blob, representing the contents of a file, or
another tree, representing the contents of a subdirectory.  Since trees
and blobs, like all other objects, are named by the SHA-1 hash of their
contents, two trees have the same SHA-1 name if and only if their
contents (including, recursively, the contents of all subdirectories)
are identical.  This allows git to quickly determine the differences
between two related tree objects, since it can ignore any entries with
identical object names.
// オブジェクトタイプが blob の場合はファイルデータであることを表し、
// tree である場合は、サブディレクトリであることを表しています。
// tree と blob は他のオブジェクトと同じようにその中身の SHA-1値によって
// 名前が付けられていて、その中身が(全てのサブディレクトリの内容も含めて)同じ場合
// にのみ同じ SHA-1 名となります。この仕組みにより git は２つの関連する
// tree オブジェクト間の差分を高速に調べることができます。

(Note: in the presence of submodules, trees may also have commits as
entries.  See <<submodules>> for documentation.)
// (注意：サブモジュールが存在する場合、tree は commit をエントリに
// 持つことがあります。<<submodules>> のドキュメントを参照。)

Note that the files all have mode 644 or 755: git actually only pays
attention to the executable bit.
// 注意：ファイルは全て 644 または 755 のモードとなります：実際、git は
// 実行パーミッションだけを管理しています。

[[blob-object]]
Blob Object
~~~~~~~~~~~
// ==== Blob オブジェクト

You can use linkgit:git-show[1] to examine the contents of a blob; take,
for example, the blob in the entry for "COPYING" from the tree above:
// linkgit:git-show[1] を使用すると blob の内容を参照できます；
// 例として、上記ツリーの blob エントリ "COPYING" を確認します：

------------------------------------------------
$ git show 6ff87c4664

 Note that the only valid version of the GPL as far as this project
 is concerned is _this_ particular version of the license (ie v2, not
 v2.2 or v3.x or whatever), unless explicitly otherwise stated.
...
------------------------------------------------

A "blob" object is nothing but a binary blob of data.  It doesn't refer
to anything else or have attributes of any kind.
// "blob" オブジェクトはバイナリの blob データであるにすぎません。
// 参照や属性といったものは持っていません。

Since the blob is entirely defined by its data, if two files in a
directory tree (or in multiple different versions of the repository)
have the same contents, they will share the same blob object. The object
is totally independent of its location in the directory tree, and
renaming a file does not change the object that file is associated with.
// blob はそれ自身のデータによって完全に定義されるため、
// ディレクトリツリー内(またはリポジトリ内の異なるバージョン)に
// ２つのファイルがあり、それらが同じ内容であるなら、同じ blob オブジェクトを
// 共有します。オブジェクトはディレクトリツリーの位置に完全に独立しており、
// ファイル名を変更してもそれに対応するオブジェクトは変更されません。

Note that any tree or blob object can be examined using
linkgit:git-show[1] with the <revision>:<path> syntax.  This can
sometimes be useful for browsing the contents of a tree that is not
currently checked out.
// 注意：全ての tree と blob オブジェクトは linkgit:git-show[1] に
// <revision>:<path> の引数を付けて実行することができます。
// これにより、現在チェックアウトしていないツリーの中身を
// ブラウズすることができます。

[[trust]]
Trust
~~~~~
// ==== Trust

If you receive the SHA-1 name of a blob from one source, and its contents
from another (possibly untrusted) source, you can still trust that those
contents are correct as long as the SHA-1 name agrees.  This is because
the SHA-1 is designed so that it is infeasible to find different contents
that produce the same hash.
// あるソースから blob の SHA-1値と(信頼できないかもしれない)ソースの中身
// を受け取ったとします。この場合でも SHA-1値が一致する限りはその内容が
// 正しいと信頼することができます。何故なら SHA-1値は同じハッシュ値を生成
// する異なるファイルを見つけることが困難なように設計されているからです。

Similarly, you need only trust the SHA-1 name of a top-level tree object
to trust the contents of the entire directory that it refers to, and if
you receive the SHA-1 name of a commit from a trusted source, then you
can easily verify the entire history of commits reachable through
parents of that commit, and all of those contents of the trees referred
to by those commits.
// 同様に、トップレベルのツリーオブジェクトの SHA-1値を信頼するだけで
// それが参照する全ディレクトリの内容を信頼することができます。
// また、信頼するソースからコミットのSHA-1値を受け取ったなら、
// そのコミットの親から到達可能なコミットの全履歴とコミットが参照する
// ツリーの内容全てを容易に信頼することができます。

So to introduce some real trust in the system, the only thing you need
to do is to digitally sign just 'one' special note, which includes the
name of a top-level commit.  Your digital signature shows others
that you trust that commit, and the immutability of the history of
commits tells others that they can trust the whole history.
// 従ってトップレベルのコミット名を含む '一つの' 特定のノートに
// デジタル署名するだけで、システムに信頼性を持たせることができます。
// デジタル署名はあなたがそのコミットを信頼していることを示し、
// コミット履歴の不変性は全ての履歴が信頼できることを示しています。

In other words, you can easily validate a whole archive by just
sending out a single email that tells the people the name (SHA-1 hash)
of the top commit, and digitally sign that email using something
like GPG/PGP.
// 言い換えると、トップレベルのコミットのSHA-1値を伝えるメールを作成し、
// GPG/PGPでデジタル署名するだけで、容易に全ての履歴の妥当性を示す
// ことができるということです。

To assist in this, git also provides the tag object...
// この仕組みを支援するため、gitはtagオブジェクトも用意しています。

[[tag-object]]
Tag Object
~~~~~~~~~~
// ==== タグ オブジェクト

A tag object contains an object, object type, tag name, the name of the
person ("tagger") who created the tag, and a message, which may contain
a signature, as can be seen using linkgit:git-cat-file[1]:
// tag オブジェクトはオブジェクトとオブジェクトタイプ、タグ名、
// タグの作成者、メッセージ(これには署名が付けられることがあります)を
// 含んでいます。このことは linkgit:git-cat-file[1] で確認できます:

------------------------------------------------
$ git cat-file tag v1.5.0
object 437b1b20df4b356c9342dac8d38849f24ef44f27
type commit
tag v1.5.0
tagger Junio C Hamano <junkio@cox.net> 1171411200 +0000

GIT 1.5.0
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)

iD8DBQBF0lGqwMbZpPMRm5oRAuRiAJ9ohBLd7s2kqjkKlq1qqC57SbnmzQCdG4ui
nLE/L9aUXdWeTFPron96DLA=
=2E+0
-----END PGP SIGNATURE-----
------------------------------------------------

See the linkgit:git-tag[1] command to learn how to create and verify tag
objects.  (Note that linkgit:git-tag[1] can also be used to create
"lightweight tags", which are not tag objects at all, but just simple
references whose names begin with "refs/tags/").
// タグの作成方法と検証方法は linkgit:git-tag[1] コマンドを参照してください。
// (注意: linkgit:git-tag[1] は'軽量'タグを作成することもできます。
// これは、tagオブジェクトとは全く異なるもので、'refs/tags/'で始まる
// 単なる参照です)

[[pack-files]]
How git stores objects efficiently: pack files
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ==== gitがどのようにオブジェクトを効率的に保管するか： packファイル

Newly created objects are initially created in a file named after the
object's SHA-1 hash (stored in .git/objects).
// 新規作成されたオブジェクトは最初はオブジェクトの SHA-1ハッシュ値の
// 名前でファイルとして保存されます(.git/objects 内に保管されます)。

Unfortunately this system becomes inefficient once a project has a
lot of objects.  Try this on an old project:
// 残念なことに、プロジェクトに大量のオブジェクトが作成されると、
// この仕組みでは不十分になります。古いプロジェクトで以下を実行
// してみてください:

------------------------------------------------
$ git count-objects
6930 objects, 47620 kilobytes
------------------------------------------------

The first number is the number of objects which are kept in
individual files.  The second is the amount of space taken up by
those "loose" objects.
// 最初の数字はファイルとして保管されているオブジェクト数です。
// 二つ目の数字はこれらの "遊離した" オブジェクトによって消費される
// 容量の合計値です。

You can save space and make git faster by moving these loose objects in
to a "pack file", which stores a group of objects in an efficient
compressed format; the details of how pack files are formatted can be
found in link:technical/pack-format.txt[technical/pack-format.txt].
// これら遊離したオブジェクトを "packファイル" に移動することで
// ディスク容量を節約し、またgitを高速化することができます。
// pack ファイルはオブジェクトのグループを十分に圧縮した形式で保管します:
// packファイル形式の詳細は link:technical/pack-format.txt[technical/pack-format.txt]
// を参照してください。

To put the loose objects into a pack, just run git repack:
// 遊離したオブジェクトを pack に移動するには、git repack を実行するだけです:

------------------------------------------------
$ git repack
Generating pack...
Done counting 6020 objects.
Deltifying 6020 objects.
 100% (6020/6020) done
Writing 6020 objects.
 100% (6020/6020) done
Total 6020, written 6020 (delta 4070), reused 0 (delta 0)
Pack pack-3e54ad29d5b2e05838c75df582c65257b8d08e1c created.
------------------------------------------------

You can then run
// その後、

------------------------------------------------
$ git prune
------------------------------------------------

to remove any of the "loose" objects that are now contained in the
pack.  This will also remove any unreferenced objects (which may be
created when, for example, you use "git reset" to remove a commit).
You can verify that the loose objects are gone by looking at the
.git/objects directory or by running
// を実行すると pack に含まれる全ての "遊離した" オブジェクトは削除されます。
// この操作は参照されていないオブジェクト(例えば、"git reset" によって
// コミットを削除した場合などに作成される)も全て削除します
// 遊離したオブジェクトが削除されたことは .git/objects ディレクトリを
// 見るか、次のコマンドを実行することで確認できます。

------------------------------------------------
$ git count-objects
0 objects, 0 kilobytes
------------------------------------------------

Although the object files are gone, any commands that refer to those
objects will work exactly as they did before.
// オブジェクトファイルが削除されても、そのオブジェクトを参照する
// 全てのコマンドは以前と同じように動作します。

The linkgit:git-gc[1] command performs packing, pruning, and more for
you, so is normally the only high-level command you need.
// The linkgit:git-gc[1] コマンドは repack、prune などを実行してくれるので
// 通常は高レベルであるこのコマンドのみ使用します。

[[dangling-objects]]
Dangling objects
~~~~~~~~~~~~~~~~
// ==== Dangling オブジェクト

The linkgit:git-fsck[1] command will sometimes complain about dangling
objects.  They are not a problem.
// linkgit:git-fsck[1] コマンドは dangling オブジェクトに関する
// メッセージを表示することがありますが、これは問題ではありません。

The most common cause of dangling objects is that you've rebased a
branch, or you have pulled from somebody else who rebased a branch--see
<<cleaning-up-history>>.  In that case, the old head of the original
branch still exists, as does everything it pointed to. The branch
pointer itself just doesn't, since you replaced it with another one.
// dangling オブジェクトが作成される主な原因は
// ブランチをリベースした場合や、
// 他のユーザがリベースしたブランチを pull した場合です。
// -- <<cleaning-up-history>> 参照。この場合、ブランチの古い head は
// まだ存在していて、head が参照していたオブジェクトも全て残っています。
// ブランチのポインタは、他の場所に移しかえられているので、存在しませんが。

There are also other situations that cause dangling objects. For
example, a "dangling blob" may arise because you did a "git add" of a
file, but then, before you actually committed it and made it part of the
bigger picture, you changed something else in that file and committed
that *updated* thing--the old state that you added originally ends up
not being pointed to by any commit or tree, so it's now a dangling blob
object.
// dangling オブジェクトが作成される他の例もあります。
// 例えば、ファイルを "git add" したが、そのファイルに別の変更を加えて
// コミットしたような場合です。
// -- この場合、もともと add していた内容は、どのコミットとツリーにも
// 参照されず、dangling blob オブジェクトとなります。

Similarly, when the "recursive" merge strategy runs, and finds that
there are criss-cross merges and thus more than one merge base (which is
fairly unusual, but it does happen), it will generate one temporary
midway tree (or possibly even more, if you had lots of criss-crossing
merges and more than two merge bases) as a temporary internal merge
base, and again, those are real objects, but the end result will not end
up pointing to them, so they end up "dangling" in your repository.
// 同様に、"再帰的に" マージを実行した際に、マージ内容が複雑で
// 複数のマージベースが存在するような場合(あまり発生することはありませんが)には、
// 中間状態のツリーが一時的に作成されます。これら中間状態の作成時に
// オブジェクトが作成されますが、それらは最終的なマージ結果では
// 参照されることがありません。従ってこれらも "dangling" となります。

Generally, dangling objects aren't anything to worry about. They can
even be very useful: if you screw something up, the dangling objects can
be how you recover your old tree (say, you did a rebase, and realized
that you really didn't want to--you can look at what dangling objects
you have, and decide to reset your head to some old dangling state).
// 一般に、dangling オブジェクトが存在しても心配する必要はありません。
// どちらかといえば、それらは役に立つものです：何か操作間違いをした時に、
// dangling オブジェクトを使用すると元の状態に戻すことができます。
// (リベースした後に誤りに気が付いた時、
// ある古い dangling の状態に head をリセットすることができます)

For commits, you can just use:
// commit の場合は、次のようにします：

------------------------------------------------
$ gitk <dangling-commit-sha-goes-here> --not --all
------------------------------------------------

This asks for all the history reachable from the given commit but not
from any branch, tag, or other reference.  If you decide it's something
you want, you can always create a new reference to it, e.g.,
// これは、指定したコミットから到達可能だが他のブランチやタグ、その他の参照からは
// 到達できない履歴すべてを表示します。そのうちのどれかが望むものであるなら、
// 新しい参照を作成します、例えば次のように。

------------------------------------------------
$ git branch recovered-branch <dangling-commit-sha-goes-here>
------------------------------------------------

For blobs and trees, you can't do the same, but you can still examine
them.  You can just do
// blob と tree の場合は、同じようにはできませんが、
// 次のようにして確認することができます。

------------------------------------------------
$ git show <dangling-blob/tree-sha-goes-here>
------------------------------------------------

to show what the contents of the blob were (or, for a tree, basically
what the "ls" for that directory was), and that may give you some idea
of what the operation was that left that dangling object.
// これは、blob の中身が何であるか(ツリーの場合、ディレクトリの "ls" の内容)
// を表示するので、その dangling オブジェクトを残すのにどのような操作が
// 必要となるかを教えてくれるでしょう。

Usually, dangling blobs and trees aren't very interesting. They're
almost always the result of either being a half-way mergebase (the blob
will often even have the conflict markers from a merge in it, if you
have had conflicting merges that you fixed up by hand), or simply
because you interrupted a "git fetch" with ^C or something like that,
leaving _some_ of the new objects in the object database, but just
dangling and useless.
// 通常、dangling blob と tree はあまり必要になることはありません。
// 大抵はコンフリクトマーカのついたマージの途中状態であるか、
// "git fetch" を Ctrl+C や何かで中断した際に作成されたもので、
// 宙ぶらりんで役に立ちません。

Anyway, once you are sure that you're not interested in any dangling
state, you can just prune all unreachable objects:
// いずれにしろ、dangling 状態に興味がないことを確認したのなら、
// 到達できないオブジェクト全てを破棄することができます：

------------------------------------------------
$ git prune
------------------------------------------------

and they'll be gone. But you should only run "git prune" on a quiescent
repository--it's kind of like doing a filesystem fsck recovery: you
don't want to do that while the filesystem is mounted.
// "git prune" は必ず休止状態にあるリポジトリでだけ実行してください。
// -- これはファイルシステムの fsck によるリカバリのようなものです：
// ファイルシステムがマウントされている時には行なうべきではありません。

(The same is true of "git fsck" itself, btw, but since
`git fsck` never actually *changes* the repository, it just reports
on what it found, `git fsck` itself is never 'dangerous' to run.
Running it while somebody is actually changing the repository can cause
confusing and scary messages, but it won't actually do anything bad. In
contrast, running "git prune" while somebody is actively changing the
repository is a *BAD* idea).
// ("git fsck" についてもこれと同じことが言えます。ところで、
// `git fsck` は実際に決してリポジトリを変更することはなく、
// 検出されたものを報告するだけで、実行しても危険なものではありません。
// 誰かがリポジトリを変更している最中に実行した場合、
// 紛らわしく恐ろしいメッセージが表示されますが、悪いことは行なわれません。
// それとは反対に "git prune" を他のユーザがリポジトリを変更している最中に
// 実行するのは *悪い* アイデアです。)

[[recovering-from-repository-corruption]]
Recovering from repository corruption
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ==== リポジトリの破損からの復旧

By design, git treats data trusted to it with caution.  However, even in
the absence of bugs in git itself, it is still possible that hardware or
operating system errors could corrupt data.
// git は意図的にデータを慎重に扱います。しかし、git 自身にバグがなかったとしても
// ハードウェアやオペレーティングシステムのエラーによりデータが壊れることがあります。

The first defense against such problems is backups.  You can back up a
git directory using clone, or just using cp, tar, or any other backup
mechanism.
// そのような問題に対する第１の防御はバックアップです。
// clone コマンドを使用するか cp, tar または他のバックアップメカニズムを
// 使用して git ディレクトリをバックアップすることができます。

As a last resort, you can search for the corrupted objects and attempt
to replace them by hand.  Back up your repository before attempting this
in case you corrupt things even more in the process.
// 最後の手段は、破損したオブジェクトを探し出して手作業で置き換えることです。
// 破損しかかっている最中であっても、作業をする前にリポジトリを
// バックアップしてください。

We'll assume that the problem is a single missing or corrupted blob,
which is sometimes a solvable problem.  (Recovering missing trees and
especially commits is *much* harder).
// １つの blob が紛失または破損している場合を考えます。
// そのような場合は時に解決できることがあります。
// (ツリー、そして特にコミットの紛失から復旧する場合はより困難です)

Before starting, verify that there is corruption, and figure out where
it is with linkgit:git-fsck[1]; this may be time-consuming.
// 開始する前に、破損している箇所を linkgit:git-fsck[1] を使用して
// 確認します；これには多大な時間を必要とするかもしれません。

Assume the output looks like this:
// 次のように出力されたとします：

------------------------------------------------
$ git fsck --full
broken link from    tree 2d9263c6d23595e7cb2a21e5ebbb53655278dff8
              to    blob 4b9458b3786228369c63936db65827de3cc06200
missing blob 4b9458b3786228369c63936db65827de3cc06200
------------------------------------------------

(Typically there will be some "dangling object" messages too, but they
aren't interesting.)
// (通常、これらと一緒に "dangling オブジェクト" のメッセージも表示
// されますが、これらは興味深いものではありません)

Now you know that blob 4b9458b3 is missing, and that the tree 2d9263c6
points to it.  If you could find just one copy of that missing blob
object, possibly in some other repository, you could move it into
.git/objects/4b/9458b3... and be done.  Suppose you can't.  You can
still examine the tree that pointed to it with linkgit:git-ls-tree[1],
which might output something like:
// 4b9458b3 の blob が紛失しており、2d9263c6 のツリーが
// それを参照していることがわかります。その紛失したblobのコピーを
// 他のリポジトリなどから見つけることができるなら、それを
// .git/objects/4b/9458b3... に移動すれば修復は完了です。もしそれが
// できない場合でも、linkgit:git-ls-tree[1] を用いて、それが何を指し示して
// いるかを確認することができます：

------------------------------------------------
$ git ls-tree 2d9263c6d23595e7cb2a21e5ebbb53655278dff8
100644 blob 8d14531846b95bfa3564b58ccfb7913a034323b8	.gitignore
100644 blob ebf9bf84da0aab5ed944264a5db2a65fe3a3e883	.mailmap
100644 blob ca442d313d86dc67e0a2e5d584b465bd382cbf5c	COPYING
...
100644 blob 4b9458b3786228369c63936db65827de3cc06200	myfile
...
------------------------------------------------

So now you know that the missing blob was the data for a file named
"myfile".  And chances are you can also identify the directory--let's
say it's in "somedirectory".  If you're lucky the missing copy might be
the same as the copy you have checked out in your working tree at
"somedirectory/myfile"; you can test whether that's right with
linkgit:git-hash-object[1]:
// これにより、紛失した blob が "myfile" という名前のファイルデータであることが
// わかります。そして、それがあるディレクトリも特定できたとします--
// "somedirectory" とします。運よくチェックアウトした作業ツリー内の
// "somedirectory/myfile" にそれと同じコピーがあるのなら、
// linkgit:git-hash-object[1] を用いてそれが正しいかどうかをテストできます。

------------------------------------------------
$ git hash-object -w somedirectory/myfile
------------------------------------------------

which will create and store a blob object with the contents of
somedirectory/myfile, and output the SHA-1 of that object.  if you're
extremely lucky it might be 4b9458b3786228369c63936db65827de3cc06200, in
which case you've guessed right, and the corruption is fixed!
// これにより、somedirectory/myfile の内容をもった blob オブジェクトを
// 作成して格納し、そのオブジェクトの SHA-1 を表示します。
// その値が 4b9458b3786228369c63936db65827de3cc06200 であったなら
// あなたは非常に幸運です。この場合、あなたの推測は正しく、破損は
// 修復されました！

Otherwise, you need more information.  How do you tell which version of
the file has been lost?
// 一致しなかった場合、より詳しい情報が必要になります。
// そのファイルのどのバージョンを無くしたかを確認します。

The easiest way to do this is with:
// 最も簡単な方法は、次のとおりです：

------------------------------------------------
$ git log --raw --all --full-history -- somedirectory/myfile
------------------------------------------------

Because you're asking for raw output, you'll now get something like
// 生データを出力しているため、次のような出力が得られます

------------------------------------------------
commit abc
Author:
Date:
...
:100644 100644 4b9458b... newsha... M somedirectory/myfile


commit xyz
Author:
Date:

...
:100644 100644 oldsha... 4b9458b... M somedirectory/myfile
------------------------------------------------

This tells you that the immediately preceding version of the file was
"newsha", and that the immediately following version was "oldsha".
You also know the commit messages that went with the change from oldsha
to 4b9458b and with the change from 4b9458b to newsha.
// これはすぐ前のファイルのバージョンが "newsha" であり、すぐ後のバージョンが
// "oldsha1" であることを示しています。
// また、oldsha から 4b9458b の変更点と 4b9458b から newsha での変更点
// のコミットメッセージについても知ることができます。

If you've been committing small enough changes, you may now have a good
shot at reconstructing the contents of the in-between state 4b9458b.
// 変更内容が十分小さい場合、4b9458b の状態の内容を再作成することが
// できるかもしれません。

If you can do that, you can now recreate the missing object with
// もしそれができたのなら、紛失したオブジェクトを次のようにして
// 再作成することができます。

------------------------------------------------
$ git hash-object -w <recreated-file>
------------------------------------------------

and your repository is good again!
// これにより、リポジトリは正常に戻ります！

(Btw, you could have ignored the fsck, and started with doing a
// (ところで、fsck を無視することもできます。次のようにして、

------------------------------------------------
$ git log --raw --all
------------------------------------------------

and just looked for the sha of the missing object (4b9458b..) in that
whole thing. It's up to you - git does *have* a lot of information, it is
just missing one particular blob version.
// 紛失したオブジェクト(4b9458b..)の sha を探し出します。
// - git はたくさんの情報を持っていますが、紛失したのは１つの特定の blob
// バージョンであるにすぎません)

[[the-index]]
The index
-----------
// === 索引(index)

The index is a binary file (generally kept in .git/index) containing a
sorted list of path names, each with permissions and the SHA-1 of a blob
object; linkgit:git-ls-files[1] can show you the contents of the index:
// 索引はバイナリファイル(通常 .git/index 内に保管)であり、
// ソートされたパス名と、パーミッション、blob の SHA-1値の一覧を含んでいます；
// linkgit:git-ls-files[1] を使用すると索引の中身を参照できます：

-------------------------------------------------
$ git ls-files --stage
100644 63c918c667fa005ff12ad89437f2fdc80926e21c 0	.gitignore
100644 5529b198e8d14decbe4ad99db3f7fb632de0439d 0	.mailmap
100644 6ff87c4664981e4397625791c8ea3bbb5f2279a3 0	COPYING
100644 a37b2152bd26be2c2289e1f57a292534a51a93c7 0	Documentation/.gitignore
100644 fbefe9a45b00a54b58d94d06eca48b03d40a50e0 0	Documentation/Makefile
...
100644 2511aef8d89ab52be5ec6a5e46236b4b6bcd07ea 0	xdiff/xtypes.h
100644 2ade97b2574a9f77e7ae4002a4e07a6a38e46d07 0	xdiff/xutils.c
100644 d5de8292e05e7c36c4b68857c1cf9855e3d2f70a 0	xdiff/xutils.h
-------------------------------------------------

Note that in older documentation you may see the index called the
"current directory cache" or just the "cache".  It has three important
properties:
// 古いドキュメントでは、"現在のディレクトリキャッシュ" または単に
// "キャッシュ" と呼んでいることがあります。索引には３つの重要な
// 性質があります：

1. The index contains all the information necessary to generate a single
(uniquely determined) tree object.
+
For example, running linkgit:git-commit[1] generates this tree object
from the index, stores it in the object database, and uses it as the
tree object associated with the new commit.
// 1. 索引は１つの(ユニークに決定される)ツリーオブジェクトを
// 生成するのに必要な情報全てを含んでいます。
// +
// 例えば、linkgit:git-commit[1] を実行すると、索引から
// 新しいコミットが参照する tree オブジェクトを生成し、オブジェクトＤＢに
// 格納します。

2. The index enables fast comparisons between the tree object it defines
and the working tree.
+
It does this by storing some additional data for each entry (such as
the last modified time).  This data is not displayed above, and is not
stored in the created tree object, but it can be used to determine
quickly which files in the working directory differ from what was
stored in the index, and thus save git from having to read all of the
data from such files to look for changes.
// 2. 索引は索引が定義する tree オブジェクトと
// 作業ツリーとを高速に比較することができます。
// +
// これは、各エントリに対する追加情報(最終更新日のようなもの)を
// 格納することで行なわれます。このデータは上記には表示されず、
// tree オブジェクトを作成する時には格納されませんが、
// 変更されているファイルと索引に格納されているファイルを
// 高速に確認するために使用できます。この仕組みが git がデータの
// 全てを読み込み変更を探す作業を手助けします。

3. It can efficiently represent information about merge conflicts
between different tree objects, allowing each pathname to be
associated with sufficient information about the trees involved that
you can create a three-way merge between them.
+
We saw in <<conflict-resolution>> that during a merge the index can
store multiple versions of a single file (called "stages").  The third
column in the linkgit:git-ls-files[1] output above is the stage
number, and will take on values other than 0 for files with merge
conflicts.
// 3. 異なるツリーオブジェクト間のコンフリクトの情報を表現することができ、
// 各パス名は3-way マージを行なうときに作成されるツリーの情報を
// 持つことができます。
// +
// <<conflict-resolution>> で見たように、マージしている間、
// 1つのファイルの("ステージ"と呼ばれる)複数のバージョンを格納する
// ことができます。linkgit:git-ls-files[1] の出力の3つ目のカラムは
// ステージの番号で、コンフリクトしたファイルには０より大きい値が
// 付けられます。

The index is thus a sort of temporary staging area, which is filled with
a tree which you are in the process of working on.
// このように索引は一時的な作業エリアの役割をし、
// 作業中のツリーの内容が詰められています。

If you blow the index away entirely, you generally haven't lost any
information as long as you have the name of the tree that it described.
// 索引を完全に消し去ると、それを記述していたツリーの名前を
// 持っていない限りは、全ての情報を失ってしまいます。

[[submodules]]
Submodules
==========
// == サブモジュール

Large projects are often composed of smaller, self-contained modules.  For
example, an embedded Linux distribution's source tree would include every
piece of software in the distribution with some local modifications; a movie
player might need to build against a specific, known-working version of a
decompression library; several independent programs might all share the same
build scripts.
// 大きなプロジェクトは自己完結したより小さいプロジェクトを含む場合があります。
// 例えば、組み込みLinuxディストリビュションのソースツリーは
// ディストリビュション内にローカルに変更を加えられたソフトウェアのピースが
// 含まれています；ムービープレーヤーは解凍ライブラリの特定のバージョンで
// ビルドできるようにする必要があるかもしれません；幾つかの独立したプログラムは
// 同じビルドスクリプトを共有しているかもしれません。

With centralized revision control systems this is often accomplished by
including every module in one single repository.  Developers can check out
all modules or only the modules they need to work with.  They can even modify
files across several modules in a single commit while moving things around
or updating APIs and translations.
// 集中型のリビジョン管理システムでは、１つのリポジトリ内に各モジュールを含む
// ことによってこれを実現します。開発者は全てのモジュールあるいは必要なモジュール
// だけをチェックアウトすることができます。API や翻訳の移動や更新といった
// 幾つかのモジュールにまたがったファイルを1回のコミットで変更することができます。

Git does not allow partial checkouts, so duplicating this approach in Git
would force developers to keep a local copy of modules they are not
interested in touching.  Commits in an enormous checkout would be slower
than you'd expect as Git would have to scan every directory for changes.
If modules have a lot of local history, clones would take forever.
// Gitは部分的なチェックアウトを許可していない為、Git の複製アプローチでは
// 開発者は興味のないモジュールのコピーまで取得しなくてはなりません。
// Git は各ディレクトリの変更をスキャンしなくてはならず、
// 莫大なコミットをチェックアウトすることで、想像以上に Git は遅くなります。

On the plus side, distributed revision control systems can much better
integrate with external sources.  In a centralized model, a single arbitrary
snapshot of the external project is exported from its own revision control
and then imported into the local revision control on a vendor branch.  All
the history is hidden.  With distributed revision control you can clone the
entire external history and much more easily follow development and re-merge
local changes.
// 一方プラスの面として、分散型のリビジョン管理システムは外部ソースを
// より良い形で統合します。集中型モデルでは、外部プロジェクトの１つの任意の
// スナップショットをそれ自身のリビジョン管理ツールからエクスポートし、
// ローカルのリビジョン管理ツールにベンダーブランチとしてインポートします。
// 変更履歴は全て隠れてしまいます。分散型のリビジョン管理システムでは
// 外部の履歴全てを複製することができ、よりいっそう容易に開発を進め、
// ローカルの変更を再マージすることもできます。

Git's submodule support allows a repository to contain, as a subdirectory, a
checkout of an external project.  Submodules maintain their own identity;
the submodule support just stores the submodule repository location and
commit ID, so other developers who clone the containing project
("superproject") can easily clone all the submodules at the same revision.
Partial checkouts of the superproject are possible: you can tell Git to
clone none, some or all of the submodules.
// Git のサブモジュール機能は外部のプロジェクトを
// サブディレクトリとしてリポジトリに含ませることができます。
// サブモジュールはそれ自身で独自性をもってメンテナンスされます；
// これは、サブモジュールは自身のリポジトリとコミットIDとを持つということであり、
// そのサブモジュールを含むプロジェクト("親プロジェクト")を複製した場合、
// 同じリビジョンのサブモジュールを全て容易に複製できます。
// 親プロジェクトの部分チェックアウトは可能です：サブモジュールを
// 複製する、しないをサブモジュールごとにしていすることができます。

The linkgit:git-submodule[1] command is available since Git 1.5.3.  Users
with Git 1.5.2 can look up the submodule commits in the repository and
manually check them out; earlier versions won't recognize the submodules at
all.
// linkgit:git-submodule[1] コマンドは Git 1.5.3 から利用可能になりました。
// Git 1.5.2 を使用しているユーザもリポジトリ内のサブモジュールのコミットを
// 参照し、それらをマニュアルでチェックアウトすることはできます；
// 初期のバージョンでは全てのサブモジュールを認識することはできないでしょう。

To see how submodule support works, create (for example) four example
repositories that can be used later as a submodule:
// サブモジュールがどのように利用できるかを見るため、
// 例として４つのリポジトリを作成します：

-------------------------------------------------
$ mkdir ~/git
$ cd ~/git
$ for i in a b c d
do
	mkdir $i
	cd $i
	git init
	echo "module $i" > $i.txt
	git add $i.txt
	git commit -m "Initial commit, submodule $i"
	cd ..
done
-------------------------------------------------

Now create the superproject and add all the submodules:
// そして、親プロジェクトを作成し、全てのサブモジュールを追加します：

-------------------------------------------------
$ mkdir super
$ cd super
$ git init
$ for i in a b c d
do
	git submodule add ~/git/$i $i
done
-------------------------------------------------

NOTE: Do not use local URLs here if you plan to publish your superproject!
// 注意：親プロジェクトを公開する予定がある場合は、ローカルのURLは使用しないでください！

See what files `git submodule` created:
// `git submodule` がどのようなファイルを作成するか見ましょう：

-------------------------------------------------
$ ls -a
.  ..  .git  .gitmodules  a  b  c  d
-------------------------------------------------

The `git submodule add <repo> <path>` command does a couple of things:
// `git submodule add <repo> <path>` コマンドは幾つかのことをしています：

- It clones the submodule from <repo> to the given <path> under the
  current directory and by default checks out the master branch.
// - カレントディレクトリ下の <path> に <repo> からサブモジュールの複製を作成し、
//   デフォルトではマスターブランチをチェックアウトします。
- It adds the submodule's clone path to the linkgit:gitmodules[5] file and
  adds this file to the index, ready to be committed.
// - サブモジュールの複製パスを linkgit:gitmodules[5] ファイルに追加し、
//   このファイルを索引に追加し、コミット可能な状態にします。
- It adds the submodule's current commit ID to the index, ready to be
  committed.
// - サブモジュールの現在のコミットID を索引に追加し、
//   コミット可能な状態にします。

Commit the superproject:
// 親プロジェクトをコミットします：

-------------------------------------------------
$ git commit -m "Add submodules a, b, c and d."
-------------------------------------------------

Now clone the superproject:
// そして、親プロジェクトを複製してみます：

-------------------------------------------------
$ cd ..
$ git clone super cloned
$ cd cloned
-------------------------------------------------

The submodule directories are there, but they're empty:
// サブモジュールのディレクトリが作成されていますが、それらは空です：

-------------------------------------------------
$ ls -a a
.  ..
$ git submodule status
-d266b9873ad50488163457f025db7cdd9683d88b a
-e81d457da15309b4fef4249aba9b50187999670d b
-c1536a972b9affea0f16e0680ba87332dc059146 c
-d96249ff5d57de5de093e6baff9e0aafa5276a74 d
-------------------------------------------------

NOTE: The commit object names shown above would be different for you, but they
should match the HEAD commit object names of your repositories.  You can check
it by running `git ls-remote ../a`.
// 注意：あなたの環境では、コミットオブジェクトの名前が上記のものとは
// 違っているかもしれません。しかし、それらはあなたのリポジトリの HEAD コミットの
// オブジェクト名と一致しているはずです。このことは `git ls-remote ../a` で
// 確認できます。

Pulling down the submodules is a two-step process. First run `git submodule
init` to add the submodule repository URLs to `.git/config`:
// サブモジュールの取得は２つの手順で行ないます。まず `git submodule init`
// を実行しサブモジュールのリポジトリURLを `.git/config` に追加します：

-------------------------------------------------
$ git submodule init
-------------------------------------------------

Now use `git submodule update` to clone the repositories and check out the
commits specified in the superproject:
// そして `git subumodule update` を実行すると、リポジトリの複製と
// 親プロジェクトにて指定されているコミットをチェックアウトが行われます：

-------------------------------------------------
$ git submodule update
$ cd a
$ ls -a
.  ..  .git  a.txt
-------------------------------------------------

One major difference between `git submodule update` and `git submodule add` is
that `git submodule update` checks out a specific commit, rather than the tip
of a branch. It's like checking out a tag: the head is detached, so you're not
working on a branch.
// `git submodule update` と `git submodule add` の間の大きな違いは
// `git submodule update` が特定のコミットをチェックアウトするのに対し
// `git submodule add` はブランチの先端をチェックアウトするという点です。
// それは、タグをチェックアウトするのに似ています：
// つまり head から引き離され、ブランチ上に位置しません。

-------------------------------------------------
$ git branch
* (no branch)
  master
-------------------------------------------------

If you want to make a change within a submodule and you have a detached head,
then you should create or checkout a branch, make your changes, publish the
change within the submodule, and then update the superproject to reference the
new commit:
// head から引き離されているサブモジュール内で変更を加えたい場合は、
// ブランチを作成またはチェックアウトし、変更を加え、サブモジュール内の変更を
// 公開し、新しいコミットを参照するように親プロジェクトを更新します：

-------------------------------------------------
$ git checkout master
-------------------------------------------------

or
// または

-------------------------------------------------
$ git checkout -b fix-up
-------------------------------------------------

then
// そして、

-------------------------------------------------
$ echo "adding a line again" >> a.txt
$ git commit -a -m "Updated the submodule from within the superproject."
$ git push
$ cd ..
$ git diff
diff --git a/a b/a
index d266b98..261dfac 160000
--- a/a
+++ b/a
@@ -1 +1 @@
-Subproject commit d266b9873ad50488163457f025db7cdd9683d88b
+Subproject commit 261dfac35cb99d380eb966e102c1197139f7fa24
$ git add a
$ git commit -m "Updated submodule a."
$ git push
-------------------------------------------------

You have to run `git submodule update` after `git pull` if you want to update
submodules, too.
// サブモジュールも更新したい場合は、
// `git pull` をした後に `git submodule update` を実行します。

Pitfalls with submodules
------------------------
// === サブモジュールの落し穴

Always publish the submodule change before publishing the change to the
superproject that references it. If you forget to publish the submodule change,
others won't be able to clone the repository:
// サブモジュールを参照する親プロジェクトの変更を公開する前には
// 必ずサブモジュールの変更を公開してください。もしサブモジュールの変更を
// 公開し忘れた場合、リポジトリを複製できなくなるでしょう：

-------------------------------------------------
$ cd ~/git/super/a
$ echo i added another line to this file >> a.txt
$ git commit -a -m "doing it wrong this time"
$ cd ..
$ git add a
$ git commit -m "Updated submodule a again."
$ git push
$ cd ~/git/cloned
$ git pull
$ git submodule update
error: pathspec '261dfac35cb99d380eb966e102c1197139f7fa24' did not match any file(s) known to git.
Did you forget to 'git add'?
Unable to checkout '261dfac35cb99d380eb966e102c1197139f7fa24' in submodule path 'a'
-------------------------------------------------

You also should not rewind branches in a submodule beyond commits that were
ever recorded in any superproject.
// 親プロジェクトにより記録されたコミットよりも手前にサブモジュールのブランチを
// 巻き戻すべきではありません。

It's not safe to run `git submodule update` if you've made and committed
changes within a submodule without checking out a branch first. They will be
silently overwritten:
// そうした場合、ブランチを最初にチェックアウトせずにサブモジュール内の変更を
// コミットした時に `git submodule update` は安全に動作しません。
// 何も言わずに変更を上書きしてしまいます。

-------------------------------------------------
$ cat a.txt
module a
$ echo line added from private2 >> a.txt
$ git commit -a -m "line added inside private2"
$ cd ..
$ git submodule update
Submodule path 'a': checked out 'd266b9873ad50488163457f025db7cdd9683d88b'
$ cd a
$ cat a.txt
module a
-------------------------------------------------

NOTE: The changes are still visible in the submodule's reflog.
// 注意：変更はサブモジュールの reflog にまだ残っています。

This is not the case if you did not commit your changes.
// ただし、変更をコミットしていない場合は残っていません。

[[low-level-operations]]
Low-level git operations
========================
// == 下位レベルの git 操作

Many of the higher-level commands were originally implemented as shell
scripts using a smaller core of low-level git commands.  These can still
be useful when doing unusual things with git, or just as a way to
understand its inner workings.
// 多くの上位レベルコマンドは、より小さくコアとなっている下位レベルの git コマンド
// を使用したシェルスクリプトで元々は実装されています。
// 下位レベルのコマンドは通常は行なわないようなことを git で行なう場合や
// 内部の仕組みを理解する手段として役に立つ場合があります。

[[object-manipulation]]
Object access and manipulation
------------------------------
// === オブジェクトのアクセスと操作

The linkgit:git-cat-file[1] command can show the contents of any object,
though the higher-level linkgit:git-show[1] is usually more useful.
// linkgit:git-cat-file[1] コマンドは任意のオブジェクトの中身を表示する
// ことができますが、上位の linkgit:git-show[1] の方が通常は便利です。

The linkgit:git-commit-tree[1] command allows constructing commits with
arbitrary parents and trees.
// linkgit:git-commit-tree[1] コマンドを用いると任意の親とツリーで
// コミットを構成させることができます。

A tree can be created with linkgit:git-write-tree[1] and its data can be
accessed by linkgit:git-ls-tree[1].  Two trees can be compared with
linkgit:git-diff-tree[1].
// linkgit:git-write-tree[1] を用いるとツリーを作成することができ、
// その中身は linkgit:git-ls-tree[1] でアクセスできます。２つのツリーは
// linkgit:git-diff-tree[1] で比較することができます。

A tag is created with linkgit:git-mktag[1], and the signature can be
verified by linkgit:git-verify-tag[1], though it is normally simpler to
use linkgit:git-tag[1] for both.
// タグは linkgit:git-mktag[1] で作成でき、その署名は linkgit:git-verify-tag[1]
// で検証することができます。しかし、これら２つは linkgit:git-tag[1] を
// 使用すると同じようなことができます。

[[the-workflow]]
The Workflow
------------
// === ワークフロー

High-level operations such as linkgit:git-commit[1],
linkgit:git-checkout[1] and linkgit:git-reset[1] work by moving data
between the working tree, the index, and the object database.  Git
provides low-level operations which perform each of these steps
individually.
// linkgit:git-commit[1]、linkgit:git-checkout[1]、linkgit:git-reset[1]
// のような高レベルの操作は作業ツリー、索引、オブジェクトＤＢ間の
// データを移動することによって仕事をします。
// Git はこれらの各ステップを独立に行なう下位レベルの操作を提供しています。

Generally, all "git" operations work on the index file. Some operations
work *purely* on the index file (showing the current state of the
index), but most operations move data between the index file and either
the database or the working directory. Thus there are four main
combinations:
// 一般に、全ての "git" 操作は索引ファイル上で作用します。
// いくつかの操作は *純粋に* 索引ファイル(現在の索引の状態を表示)
// 上で作用しますが、ほとんどの操作は索引ファイルとデータベース又は
// 作業ディレクトリ間のデータを移動します。従って、主に４つの組み合わせがあります：

[[working-directory-to-index]]
working directory -> index
~~~~~~~~~~~~~~~~~~~~~~~~~~
// ==== 作業ディレクトリ → 索引

The linkgit:git-update-index[1] command updates the index with
information from the working directory.  You generally update the
index information by just specifying the filename you want to update,
like so:
// linkgit:git-update-index[1] コマンドは作業ディレクトリの情報を
// 索引に更新します。一般には更新したいファイルを特定して
// 索引の情報を更新します、次のように：

-------------------------------------------------
$ git update-index filename
-------------------------------------------------

but to avoid common mistakes with filename globbing etc, the command
will not normally add totally new entries or remove old entries,
i.e. it will normally just update existing cache entries.
// しかし、ファイル名を補完した際などの間違いを防ぐため、
// このコマンドは新しいエントリや削除された古いエントリを
// 自動的に追加することはありません。即ち、存在するキャッシュエントリを単に更新するだけです。

To tell git that yes, you really do realize that certain files no
longer exist, or that new files should be added, you
should use the `--remove` and `--add` flags respectively.
// あるファイルを削除する場合は `--remove` フラグを、
// 新しいファイルを追加する場合は `--add` フラグを使用します。

NOTE! A `--remove` flag does 'not' mean that subsequent filenames will
necessarily be removed: if the files still exist in your directory
structure, the index will be updated with their new status, not
removed. The only thing `--remove` means is that update-index will be
considering a removed file to be a valid thing, and if the file really
does not exist any more, it will update the index accordingly.
// 注意！ `--remove` フラグを使用しても必ずしもそのファイルが削除される
// わけではありません：ファイルがディレクトリ内にまだ存在する場合、
// 索引は新しいステータスに更新されますが、ファイルは削除されません。
// `--remove` はファイルが削除されたのが正しいことであることが
// 索引の更新時に考慮されることを意味しているだけであり、
// もしファイルが本当に存在しないのなら索引をそれに従い更新するだけです。

As a special case, you can also do `git update-index --refresh`, which
will refresh the "stat" information of each index to match the current
stat information. It will 'not' update the object status itself, and
it will only update the fields that are used to quickly test whether
an object still matches its old backing store object.
// `git update-index --refresh` という特別なオプションもあります。
// これは現在の "stat" 情報に一致する各索引の "stat" 情報を
// リフレッシュします。オブジェクトのステータス自身は更新せず、
// オブジェクトが過去に格納されたオブジェクトとまだ一致している
// かを素早くテストする為に使用されるフィールドだけを更新します。

The previously introduced linkgit:git-add[1] is just a wrapper for
linkgit:git-update-index[1].
// 以前紹介した linkgit:git-add[1] は linkgit:git-update-index[1] の
// 単なるラッパースクリプトです。

[[index-to-object-database]]
index -> object database
~~~~~~~~~~~~~~~~~~~~~~~~
// ==== 索引 → オブジェクトＤＢ

You write your current index file to a "tree" object with the program
// 現在の索引ファイルを "tree" オブジェクトに書く為には、プログラム

-------------------------------------------------
$ git write-tree
-------------------------------------------------

that doesn't come with any options--it will just write out the
current index into the set of tree objects that describe that state,
and it will return the name of the resulting top-level tree. You can
use that tree to re-generate the index at any time by going in the
other direction:
// を使用します。これにはオプションがありません。-- これは
// その状態を記述する現在の索引をツリーオブジェクトの集合へと
// 書き出す役目をし、トップレベルのツリーの名前を返却します。
// このツリーはいつでも索引を再生成する為に利用できます。

[[object-database-to-index]]
object database -> index
~~~~~~~~~~~~~~~~~~~~~~~~
// ==== オブジェクトＤＢ → 索引

You read a "tree" file from the object database, and use that to
populate (and overwrite--don't do this if your index contains any
unsaved state that you might want to restore later!) your current
index.  Normal operation is just
// オブジェクトＤＢから "tree" ファイルを読み込み、現在の索引を
// そのツリーの状態と同じにするには次のようにします。
// (索引が後で元に戻す可能性がある未保存の状態を含む場合にはこれをしないでください！)

-------------------------------------------------
$ git read-tree <SHA-1 of tree>
-------------------------------------------------

and your index file will now be equivalent to the tree that you saved
earlier. However, that is only your 'index' file: your working
directory contents have not been modified.
// これにより索引ファイルは過去に保存したツリーと同じ状態になります。
// しかし、それは 'index' ファイルに対してだけです：作業ディレクトリは
// 何も変更されていません。

[[index-to-working-directory]]
index -> working directory
~~~~~~~~~~~~~~~~~~~~~~~~~~
// ==== 索引 → 作業ディレクトリ

You update your working directory from the index by "checking out"
files. This is not a very common operation, since normally you'd just
keep your files updated, and rather than write to your working
directory, you'd tell the index files about the changes in your
working directory (i.e. `git update-index`).

However, if you decide to jump to a new version, or check out somebody
else's version, or just restore a previous tree, you'd populate your
index file with read-tree, and then you need to check out the result
with
// 次のようにすると、作業ディレクトリを索引の状態に
// 更新することができます。

-------------------------------------------------
$ git checkout-index filename
-------------------------------------------------

or, if you want to check out all of the index, use `-a`.
// あるいは、全ての索引をチェックアウトしたい場合は `-a` を使用します。

NOTE! `git checkout-index` normally refuses to overwrite old files, so
if you have an old version of the tree already checked out, you will
need to use the "-f" flag ('before' the "-a" flag or the filename) to
'force' the checkout.
// 注意！ `git checkout-index` は通常、古いファイルを上書きすることを居します。
// 従って、チェックアウト済みの古いバージョンのツリーを持っている場合、
// ("-a" フラグ又はファイル名の'前に') "-f" フラグを使用し、'強制的に'
// チェックアウトする必要があります。


Finally, there are a few odds and ends which are not purely moving
from one representation to the other:
// 最後に、一方から他方への純粋な移動ではないものを説明します：

[[tying-it-all-together]]
Tying it all together
~~~~~~~~~~~~~~~~~~~~~
// ==== 機能間の連携

To commit a tree you have instantiated with "git write-tree", you'd
create a "commit" object that refers to that tree and the history
behind it--most notably the "parent" commits that preceded it in
history.
// "git write-tree" で作成したツリーをコミットするには、
// そのツリーと背後にある履歴(つまり、その履歴とつながる"親の"コミット)
// を参照する "commit" オブジェクトを作成します。

Normally a "commit" has one parent: the previous state of the tree
before a certain change was made. However, sometimes it can have two
or more parent commits, in which case we call it a "merge", due to the
fact that such a commit brings together ("merges") two or more
previous states represented by other commits.
// 通常 "commit" は一つの親を持ちます：これはある変更を行った一つ前の
// ツリー状態を指しています。しかしながら時には二つ以上の親を持つこと
// もあります。それは "マージ" と言われる場合であり、そのようなコミットは
// 二つ以上の状態を一つに纏めます。

In other words, while a "tree" represents a particular directory state
of a working directory, a "commit" represents that state in "time",
and explains how we got there.
// 言い換えると、ツリーがある作業ディレクトリの特定の状態を表す一方、
// コミットはその状態の時刻とそこに至った経緯を表します。

You create a commit object by giving it the tree that describes the
state at the time of the commit, and a list of parents:
// コミットを作成するには、コミット時点の状態を表すツリーと親のリストを
// 渡すことで作成することができます:

-------------------------------------------------
$ git commit-tree <tree> -p <parent> [-p <parent2> ..]
-------------------------------------------------

and then giving the reason for the commit on stdin (either through
redirection from a pipe or file, or by just typing it at the tty).
// コミット時のコメントは標準入力(あるいはパイプやファイルのリダイレクト)
// で指定します。

`git commit-tree` will return the name of the object that represents
that commit, and you should save it away for later use. Normally,
you'd commit a new `HEAD` state, and while git doesn't care where you
save the note about that state, in practice we tend to just write the
result to the file pointed at by `.git/HEAD`, so that we can always see
what the last committed state was.
// `git commit-tree` は作成したコミットのオブジェクト名を返却します。
// 通常、この名前は `.git/HEAD` ファイルに保存され、その結果、
// 最後のコミットが何であるかを確認できます。

Here is an ASCII art by Jon Loeliger that illustrates how
various pieces fit together.
// 以下は Jon Loeliger が作成したテキストのイラストで、
// 項目間の関係を示しています。

------------

                     commit-tree
                      commit obj
                       +----+
                       |    |
                       |    |
                       V    V
                    +-----------+
                    | Object DB |
                    |  Backing  |
                    |   Store   |
                    +-----------+
                       ^
           write-tree  |     |
             tree obj  |     |
                       |     |  read-tree
                       |     |  tree obj
                             V
                    +-----------+
                    |   Index   |
                    |  "cache"  |
                    +-----------+
         update-index  ^
             blob obj  |     |
                       |     |
    checkout-index -u  |     |  checkout-index
             stat      |     |  blob obj
                             V
                    +-----------+
                    |  Working  |
                    | Directory |
                    +-----------+

------------


[[examining-the-data]]
Examining the data
------------------
// === データの中身を参照する

You can examine the data represented in the object database and the
index with various helper tools. For every object, you can use
linkgit:git-cat-file[1] to examine details about the
object:
// 様々なヘルパーツールを用いることでオブジェクトDBと
// 索引の中身を確認することができます。
// 各オブジェクトの中身は linkgit:git-cat-file[1] で確認します:

-------------------------------------------------
$ git cat-file -t <objectname>
-------------------------------------------------

shows the type of the object, and once you have the type (which is
usually implicit in where you find the object), you can use
// これはオブジェクトのタイプを表示し、タイプを確認した後は
// 次のようにして、中身を確認することができます。

-------------------------------------------------
$ git cat-file blob|tree|commit|tag <objectname>
-------------------------------------------------

to show its contents. NOTE! Trees have binary content, and as a result
there is a special helper for showing that content, called
`git ls-tree`, which turns the binary content into a more easily
readable form.
// 注意！ Tree はバイナリであり、その中身を見るには `git ls-tree` という
// 特別なツールを使用します。これは、バイナリの内容をより読みやすい形式に
// 変換してくれます。

It's especially instructive to look at "commit" objects, since those
tend to be small and fairly self-explanatory. In particular, if you
follow the convention of having the top commit name in `.git/HEAD`,
you can do
// "commit" オブジェクトの中身を見ることはとても教育的です。
// それらは小さく、一目瞭然です。特に、
// 最新のコミット名が `.git/HEAD` にあるという規約を使用し、
// 次のようにすると、最新のコミットの中身を確認できます。

-------------------------------------------------
$ git cat-file commit HEAD
-------------------------------------------------

to see what the top commit was.

[[merging-multiple-trees]]
Merging multiple trees
----------------------
// === 複数のツリーをマージする

Git helps you do a three-way merge, which you can expand to n-way by
repeating the merge procedure arbitrary times until you finally
"commit" the state.  The normal situation is that you'd only do one
three-way merge (two parents), and commit it, but if you like to, you
can do multiple parents in one go.
// Git は 3方向マージを行なう手助けをします。これは
// 任意の回数繰り返すことにより n方向マージに拡張することができます。
// 通常は3方向マージ(2つの親によるマージ)のみを行ないますが、
// 複数の親を1回でマージすることもできます。

To do a three-way merge, you need the two sets of "commit" objects
that you want to merge, use those to find the closest common parent (a
third "commit" object), and then use those commit objects to find the
state of the directory ("tree" object) at these points.
// 3方向マージをするには、マージする2組の "commit" オブジェクトが
// 必要です。これを使用し共通の親(3番目の"commit"オブジェクト)を見つけ、
// それら commit オブジェクトを使用してディレクトリ("tree" オブジェクト)
// の状態を探します。

To get the "base" for the merge, you first look up the common parent
of two commits with
// マージの "ベース" を得るには、まず次のようにして
// ２つのコミットの共通の親を見つけます。

-------------------------------------------------
$ git merge-base <commit1> <commit2>
-------------------------------------------------

which will return you the commit they are both based on.  You should
now look up the "tree" objects of those commits, which you can easily
do with (for example)
// これは、共通のベースコミットを返却します。
// これらコミットの "tree" オブジェクトは次のようにして
// 容易に見つけることができます。(例えば)

-------------------------------------------------
$ git cat-file commit <commitname> | head -1
-------------------------------------------------

since the tree object information is always the first line in a commit
object.
// tree オブジェクトの情報は、コミットオブジェクトの１行目に
// 常に記述されています。

Once you know the three trees you are going to merge (the one "original"
tree, aka the common tree, and the two "result" trees, aka the branches
you want to merge), you do a "merge" read into the index. This will
complain if it has to throw away your old index contents, so you should
make sure that you've committed those--in fact you would normally
always do a merge against your last commit (which should thus match what
you have in your current index anyway).
// マージしようとする３つのツリー(１つは "original"の tree いわゆる 共通の tree、
// ２つの "結果" tree、いわゆるマージしたいブランチ)を知った後は、
// 索引に読み込んでそれらを "マージ" します。
// 古い索引の中身を破棄しなくてはならない場合、エラーを表示します。
// 従ってそれらをコミットしたか確認してください。-- 実際、通常は常に
// 最後にコミットした内容をもとにマージします(そのコミットは従って
// 現在の索引の内容と一致します)

To do the merge, do
// マージをするには次のひょうにします。

-------------------------------------------------
$ git read-tree -m -u <origtree> <yourtree> <targettree>
-------------------------------------------------

which will do all trivial merge operations for you directly in the
index file, and you can just write the result out with
`git write-tree`.
// これにより、自明のマージ操作は直接索引ファイルに行なわれ、
// `git write-tree` を用いてその結果を書き込むことができます。


[[merging-multiple-trees-2]]
Merging multiple trees, continued
---------------------------------
// === 複数のツリーをマージする、続き

Sadly, many merges aren't trivial. If there are files that have
been added, moved or removed, or if both branches have modified the
same file, you will be left with an index tree that contains "merge
entries" in it. Such an index tree can 'NOT' be written out to a tree
object, and you will have to resolve any such merge clashes using
other tools before you can write out the result.
// 残念なことに、多くのマージは自明ではありませんん。
// 追加や移動、削除されたファイルがある場合や、あるいは両方のブランチ
// で同じファイルが変更されている場合、"マージエントリ" を含んだ
// 索引ツリーが残されます。このような索引ツリーは
// tree オブジェクトには書き込むことができません。その結果を書き込む前に
// 他のツールを使用してコンフリクトを解消する必要があります。

You can examine such index state with `git ls-files --unmerged`
command.  An example:
// このような索引状態は `git ls-files --unmerged` を
// 用いると確認できます。例えば：

------------------------------------------------
$ git read-tree -m $orig HEAD $target
$ git ls-files --unmerged
100644 263414f423d0e4d70dae8fe53fa34614ff3e2860 1	hello.c
100644 06fa6a24256dc7e560efa5687fa84b51f0263c3a 2	hello.c
100644 cc44c73eb783565da5831b4d820c962954019b69 3	hello.c
------------------------------------------------

Each line of the `git ls-files --unmerged` output begins with
the blob mode bits, blob SHA-1, 'stage number', and the
filename.  The 'stage number' is git's way to say which tree it
came from: stage 1 corresponds to `$orig` tree, stage 2 `HEAD`
tree, and stage3 `$target` tree.
// `git ls-files --unmerged` の出力の各行は blob のモードビット、
// blob の SHA-1、'stage番号'、そしてファイル番号で始まります。
// 'stage番号' はそれがどの tree から来たかを表す git のやり方です：
// stage 1 は `$orig` ツリーに対応し、stege 2 は `HEAD` の tree
// stage 3 `$target` tree です。

Earlier we said that trivial merges are done inside
`git read-tree -m`.  For example, if the file did not change
from `$orig` to `HEAD` nor `$target`, or if the file changed
from `$orig` to `HEAD` and `$orig` to `$target` the same way,
obviously the final outcome is what is in `HEAD`.  What the
above example shows is that file `hello.c` was changed from
`$orig` to `HEAD` and `$orig` to `$target` in a different way.
You could resolve this by running your favorite 3-way merge
program, e.g.  `diff3`, `merge`, or git's own merge-file, on
the blob objects from these three stages yourself, like this:
// 既に自明のマージは `git read-tree -m` にて行なわれたことを
// 説明しました。例えば、ファイルが `HEAD と `$target` のどちらでも
// 変更されていない場合や、`HEAD` と `$target` が同じ内容の場合は
// 明らかに最終的な結果は `HEAD` のものと同じです。
// 上記の例では `hello.c` は `HEAD` で変更されていて `$target`でも
// 別の変更が行なわれている場合です。
// 好きな3方向マージツールを実行してこれを解決することができます。
// 例えば `diff3`、`merge` あるいは git 自身の merge-file などを使用し
// これら３つのstage 上のファイルを次のようにしてマージします。

------------------------------------------------
$ git cat-file blob 263414f... >hello.c~1
$ git cat-file blob 06fa6a2... >hello.c~2
$ git cat-file blob cc44c73... >hello.c~3
$ git merge-file hello.c~2 hello.c~1 hello.c~3
------------------------------------------------

This would leave the merge result in `hello.c~2` file, along
with conflict markers if there are conflicts.  After verifying
the merge result makes sense, you can tell git what the final
merge result for this file is by:
// これはマージ結果は `hello.c~2` ファイルに保存し、
// コンフリクトがあるときは、コンフリクトマーカが付けられます。
// マージ結果を確認した後、このファイルの最終的なマージ結果を
// git に次のようにして伝えます：

-------------------------------------------------
$ mv -f hello.c~2 hello.c
$ git update-index hello.c
-------------------------------------------------

When a path is in the "unmerged" state, running `git update-index` for
that path tells git to mark the path resolved.
// ファイルにマージ済みになっていない時は、`git update-index` は
// ファイルに解決済みのマークを付けます。

The above is the description of a git merge at the lowest level,
to help you understand what conceptually happens under the hood.
In practice, nobody, not even git itself, runs `git cat-file` three times
for this.  There is a `git merge-index` program that extracts the
stages to temporary files and calls a "merge" script on it:
// 上記は下位レベルにおける git のマージ動作の解説で、
// 水面下でどのようなことが起きているかの概念を理解する手助けになります。
// 実際、誰も、git 自身でさえ、`git cat-file` を3回も実行しません。
// `git merge-index` プログラムがあり、これが stage を一時ファイルとして
// 抽出し、"merge" スクリプトをコールします：

-------------------------------------------------
$ git merge-index git-merge-one-file hello.c
-------------------------------------------------

and that is what higher level `git merge -s resolve` is implemented with.
// そして、上位レベルとして `git merge -s resolve` が実装されています。

[[hacking-git]]
Hacking git
===========
// == git をハックする

This chapter covers internal details of the git implementation which
probably only git developers need to understand.
// この章では git の実装内部の詳細について説明します。
// これらの内容はおそらく git の開発者のみが必要となる内容です。

[[object-details]]
Object storage format
---------------------
// === オブジェクトの保管形式

All objects have a statically determined "type" which identifies the
format of the object (i.e. how it is used, and how it can refer to other
objects).  There are currently four different object types: "blob",
"tree", "commit", and "tag".
// すべてのオブジェクトは静的に決定された "種別" を持っており、
// それによりオブジェクトの形式が特定されます(例えば、どのように使用され
// どのように他のオブジェクトを参照するかなど)。現在のところ、オブジェクト
// 種別は４つ存在します： "blob", "tree", "commit", "tag" です。

Regardless of object type, all objects share the following
characteristics: they are all deflated with zlib, and have a header
that not only specifies their type, but also provides size information
about the data in the object.  It's worth noting that the SHA-1 hash
that is used to name the object is the hash of the original data
plus this header, so `sha1sum` 'file' does not match the object name
for 'file'.
(Historical note: in the dawn of the age of git the hash
was the SHA-1 of the 'compressed' object.)
// オブジェクトの種別に関係なく、すべてのオブジェクトは次の特徴を持ちます：
// オブジェクトは全て zlib で圧縮され、ヘッダにはオブジェクトの種別だけでなく、
// オブジェクトデータのサイズの情報が含まれています。
// なお、オブジェクトの名前に使用されている SHA-1 ハッシュ値は元データ＋このヘッダの
// ハッシュ値となっています。従ってファイルの `sha1sum` の結果は
// そのオブジェクトの名前とは一致しません。

As a result, the general consistency of an object can always be tested
independently of the contents or the type of the object: all objects can
be validated by verifying that (a) their hashes match the content of the
file and (b) the object successfully inflates to a stream of bytes that
forms a sequence of <ascii type without space> {plus} <space> {plus} <ascii decimal
size> {plus} <byte\0> {plus} <binary object data>.
// その結果、オブジェクトの一般的な一貫性はその中身やオブジェクト種別とは
// 常に独立してテストすることができます：全ておオブジェクトは次のようにして
// 検証することができます。(a)それらのハッシュ値がファイルの中身と一致していること。そして、
// (b)オブジェクトを解凍することができ、解凍したデータは <オブジェクトの種別> + 空白 +
// <サイズ> ＋ <byte\0> + <オブジェクトのバイナリデータ> の順番となっていること。

The structured objects can further have their structure and
connectivity to other objects verified. This is generally done with
the `git fsck` program, which generates a full dependency graph
of all objects, and verifies their internal consistency (in addition
to just verifying their superficial consistency through the hash).
// 構造化されたオブジェクトの場合は、さらにその構造と他のオブジェクトの
// 連結性によって懸賞することができます。これらは `git fsck` プログラムが
// 通常行っている内容であり、全オブジェクトの完全な依存グラフを生成し、
// それらの内部一貫性を検証します(さらに、単にハッシュを使用した表面的な
// 一貫性の検証も行います)

[[birdview-on-the-source-code]]
A birds-eye view of Git's source code
-------------------------------------
// === Git ソースコードの鳥瞰図

It is not always easy for new developers to find their way through Git's
source code.  This section gives you a little guidance to show where to
start.
// 新しい開発者にとっては Git のソースコードの構成を理解するのは必ずしも
// 容易ではないでしょう。このセクションでは、どこから開始したら良いかを
// 示す小さなガイダンスです。

A good place to start is with the contents of the initial commit, with:
// 手始めとして良い場所は、初期コミットの内容を見ることです。次のように取得します：

----------------------------------------------------
$ git checkout e83c5163
----------------------------------------------------

The initial revision lays the foundation for almost everything git has
today, but is small enough to read in one sitting.
// 初期コミットには現在の git のほとんど全ての基礎ができていますが、
// ざっと読みとおすのには十分な小ささです。

Note that terminology has changed since that revision.  For example, the
README in that revision uses the word "changeset" to describe what we
now call a <<def_commit_object,commit>>.
// 現在ではこのリビジョンの頃から用語が変更されています。例えば、
// このリビジョンの README では現在 <<def_commit_object,コミット>> と呼んでいる
// ものを "チェンジセット" と呼んでいます。

Also, we do not call it "cache" any more, but rather "index"; however, the
file is still called `cache.h`.  Remark: Not much reason to change it now,
especially since there is no good single name for it anyway, because it is
basically _the_ header file which is included by _all_ of Git's C sources.
// また、現在は "キャッシュ" という言い方はせず それどころか"索引(index)" と呼んでいますが、
// ファイルは今も `cache.h` です。(注釈：Not much reason to change it now,
// especially since there is no good single name for it anyway, because it is
// basically _the_ header file which is included by _all_ of Git's C sources.)

If you grasp the ideas in that initial commit, you should check out a
more recent version and skim `cache.h`, `object.h` and `commit.h`.
// 初期コミットを眺めて概要を把握できたら、より新しいバージョンを
// チェックアウトし、`cache.h`, `object.h`, `commit.h` にざっと目を
// 通してください。

In the early days, Git (in the tradition of UNIX) was a bunch of programs
which were extremely simple, and which you used in scripts, piping the
output of one into another. This turned out to be good for initial
development, since it was easier to test new things.  However, recently
many of these parts have become builtins, and some of the core has been
"libified", i.e. put into libgit.a for performance, portability reasons,
and to avoid code duplication.
// 初期の頃には、Git は UNIX の伝統にならい、非常にシンプルなプログラムの
// 集まりとなっていて、それらをパイプで組み合わせ、スクリプト化したりして
// 利用するようなツールでした。新しいことを試すのが容易であったため、
// 初期の開発でこれは良いことでした。しかし、現在では、これらの大部分は
// 内部に組み込まれ、いくつかのコア部分は "ライブラリ化" されました。
// つまり、パフォーマンスや移植性、コードの重複の回避などの理由で
// libgit.a に入れられました。

By now, you know what the index is (and find the corresponding data
structures in `cache.h`), and that there are just a couple of object types
(blobs, trees, commits and tags) which inherit their common structure from
`struct object`, which is their first member (and thus, you can cast e.g.
`(struct object *)commit` to achieve the _same_ as `&commit->object`, i.e.
get at the object name and flags).
// ここまでの確認で、索引が何かを理解し、そして、`cashe.h`内の索引のデータ
// 構造を理解することができたはずです。また、４つのオブジェクトタイプ(blob, tree, commit, tag)が
// `struct object` の共通構造を継承していていることや、
// `struct object` がそれらの最初のメンバであり
// 例えば `(struct object *)commit` のようにキャストすることで
// `&commit->object` と同じ結果が得られること、同じようにオブジェクト名やフラグも
// 得られることを確認できたはずです。

Now is a good point to take a break to let this information sink in.
// ここまでで、オブジェクトデータに関する確認はひと段落です。

Next step: get familiar with the object naming.  Read <<naming-commits>>.
There are quite a few ways to name an object (and not only revisions!).
All of these are handled in `sha1_name.c`. Just have a quick look at
the function `get_sha1()`. A lot of the special handling is done by
functions like `get_sha1_basic()` or the likes.
// 次のステップ：オブジェクトの指定方法を理解してください。
// <<naming-commits,コミットの指定方法>> に書かれているとおり、
// オブジェクトの指定方法は数個です(そして、それらはコミットだけに限ったことではありません!)。
// これらの指定部分の実装は `sha1_name.c` で行われています。
// その中の関数 `get_sha1() をざっとみてください。
// 特徴的な部分は `get_sha1_basic()` などの関数部分でハンドリングされています。

This is just to get you into the groove for the most libified part of Git:
the revision walker.
// この部分は、Git の最もライブラリ化された部分、すなわちリビジョンウォーカー
// に対するよい導入になっています。

Basically, the initial version of `git log` was a shell script:
// 基本的には、`git log` の初期バージョンは次のようなシェルスクリプトでした：

----------------------------------------------------------------
$ git-rev-list --pretty $(git-rev-parse --default HEAD "$@") | \
	LESS=-S ${PAGER:-less}
----------------------------------------------------------------

What does this mean?
// これは何を意味するでしょうか？

`git rev-list` is the original version of the revision walker, which
_always_ printed a list of revisions to stdout.  It is still functional,
and needs to, since most new Git programs start out as scripts using
`git rev-list`.
// `git rev-list` はリビジョンウォーカーの元になったバージョンであり、
// _常に_ リビジョンの一覧を標準出力に出力するコマンドです。
// このコマンドは現在でも役に立っており、新しい Git プログラムを
// スクリプトとして作成するような場合によく利用されます。

`git rev-parse` is not as important any more; it was only used to filter out
options that were relevant for the different plumbing commands that were
called by the script.
// `git rev-parse` はもはや重要ではありません；何故ならこれは、スクリプトにより
// コールされる異なる配管コマンドに対して、関連のあるオプションをフィルタリング
// する為だけに利用されているからです。

Most of what `git rev-list` did is contained in `revision.c` and
`revision.h`.  It wraps the options in a struct named `rev_info`, which
controls how and what revisions are walked, and more.
// `git rev-list` が行っていることのほとんどは、`revision.c` と `revision.h`
// に含まれています。`rev_info` という名前の構造内のオプションを包み込み、
// どのようにどのリビジョンにウォーク(アクセス)するかなどのコントロールをします。

The original job of `git-rev-parse` is now taken by the function
`setup_revisions()`, which parses the revisions and the common command line
options for the revision walker. This information is stored in the struct
`rev_info` for later consumption. You can do your own command line option
parsing after calling `setup_revisions()`. After that, you have to call
`prepare_revision_walk()` for initialization, and then you can get the
commits one by one with the function `get_revision()`.
// `git rev-parse` の元の役割は、現在は `setup_revisions()` 関数に
// 取って代わられました。`setup_revisions()` はリビジョンウォーカーの為に
// リビジョンと共通のコマンドラインの解析をします。解析結果は `rev_info` に
// 保管されて利用されます。`setup_revisions()` を呼び出した後に、自身の
// コマンドラインオプションを解析することもできます。その後に
// `prepare_revision_walk()` をコールして初期化すると、`get_revision()` 関数にて
// ここのコミットを取得することができます。

If you are interested in more details of the revision walking process,
just have a look at the first implementation of `cmd_log()`; call
`git show v1.3.0{tilde}155^2{tilde}4` and scroll down to that function (note that you
no longer need to call `setup_pager()` directly).
// リビジョンウォーカーの処理をより詳しく知りたい場合は、始めに `cmd_log()` の
// 実装を参照してください；`git show v1.3.0{tilde}155^2{tilde}4` を実行し、その関数まで
// スクロールしてください(もはや `setup_pager()` を直接コールする必要がない
// 点に注意してください)。

Nowadays, `git log` is a builtin, which means that it is _contained_ in the
command `git`.  The source side of a builtin is
// 現在では `git log` はビルトイン化されています(つまり、`git` コマンド内に含まれています)。
// ビルトイン化されているソース部分は

- a function called `cmd_<bla>`, typically defined in `builtin-<bla>.c`,
  and declared in `builtin.h`,
// - `cmd_<bla>` という名前の関数で、通常は `builtin-<bla>.c` 内で定義されていて、
//   宣言は `builtin.h` 内で行われています。

- an entry in the `commands[]` array in `git.c`, and
// - `git.c` 内の `commands[]` 配列のエントリと、

- an entry in `BUILTIN_OBJECTS` in the `Makefile`.
// - `Makefile` 内の `BUILTIN_OBJECTS` 内のエントリとがあります。

Sometimes, more than one builtin is contained in one source file.  For
example, `cmd_whatchanged()` and `cmd_log()` both reside in `builtin-log.c`,
since they share quite a bit of code.  In that case, the commands which are
_not_ named like the `.c` file in which they live have to be listed in
`BUILT_INS` in the `Makefile`.
// 時には１つのソースファイルに複数のビルトインが含まれていることがあります。
// 例えば、`cmd_whatchanged()` と `cmd_log()` はコードのかなりを共有しているため、
// 両方とも `builtin-log.c` 内に存在します。このような場合、コマンドは
// `.c` ファイルの名前で呼ばれず、`Makefile` 内の `BUILT_INS` 内に
// リストされている必要があります。

`git log` looks more complicated in C than it does in the original script,
but that allows for a much greater flexibility and performance.
// `git log` は 元のスクリプトがしていた内容よりも C の実装の方がより
// 複雑に見えますが、より高い柔軟性とパフォーマンス性を持っています。

Here again it is a good point to take a pause.
// ここまでで再び一息つくのにちょうど良い箇所です。

Lesson three is: study the code.  Really, it is the best way to learn about
the organization of Git (after you know the basic concepts).
// レッスン３はコードの観察です。(基本的な概念を学んだ後に) Git の構成を学ぶには
// これが一番良い方法です

So, think about something which you are interested in, say, "how can I
access a blob just knowing the object name of it?".  The first step is to
find a Git command with which you can do it.  In this example, it is either
`git show` or `git cat-file`.
// 興味のある内容を考えてください。たとえば
// "blob のオブジェクト名からどのように blob にアクセスするのだろう？"とか。
// まず最初に、それを行う Git コマンドを見つけてください。この例では、
// `git show` または `git cat-file` です。

For the sake of clarity, let's stay with `git cat-file`, because it
// 明瞭にするため、`git cat-file` にしましょう。何故なら

- is plumbing, and
// - これが配管的なもの(plumbing)であり、

- was around even in the initial commit (it literally went only through
  some 20 revisions as `cat-file.c`, was renamed to `builtin-cat-file.c`
  when made a builtin, and then saw less than 10 versions).
// - 初期コミットの頃から存在しているからです。(`cat-file.c` のリビジョンが 20 個、
//   ビルトイン化されて `builtin-cat-file.c` に変更されてからのリビジョンは 10個以下です)。

So, look into `builtin-cat-file.c`, search for `cmd_cat_file()` and look what
it does.
// `builtin-cat-file.c` を開き、`cmd_cat_file()` を探し出して、
// 何が行われているかを見てください。

------------------------------------------------------------------
        git_config(git_default_config);
        if (argc != 3)
		usage("git cat-file [-t|-s|-e|-p|<type>] <sha1>");
                usage("git-cat-file [-t|-s|-e|-p|<type>] <sha1>");
        if (get_sha1(argv[2], sha1))
                die("Not a valid object name %s", argv[2]);
------------------------------------------------------------------

Let's skip over the obvious details; the only really interesting part
here is the call to `get_sha1()`.  It tries to interpret `argv[2]` as an
object name, and if it refers to an object which is present in the current
repository, it writes the resulting SHA-1 into the variable `sha1`.
// 明らかに細かな部分はスキップしましょう；ここで興味深い箇所は
// `get_sha1()` を読んでいる箇所です。ここではオブジェクト名である `argv[2]`
// を読み込み、もしそれが現在のリポジトリに存在するオブジェクトを参照している場合は
// その SHA-1 を変数 `sha1` に代入します。

Two things are interesting here:
// ここで興味深いのは次の２点です：

- `get_sha1()` returns 0 on _success_.  This might surprise some new
  Git hackers, but there is a long tradition in UNIX to return different
  negative numbers in case of different errors--and 0 on success.
// - `get_cha1()` は _成功_ 時に 0 を返却します。これは Git のハックを
//   初めて行う人にとっては驚くべきことですが、エラーの種別毎に異なる負数を返却し、
//   成功時には 0 を返却するのは UNIX の昔からの伝統です。

- the variable `sha1` in the function signature of `get_sha1()` is `unsigned
  char \*`, but is actually expected to be a pointer to `unsigned
  char[20]`.  This variable will contain the 160-bit SHA-1 of the given
  commit.  Note that whenever a SHA-1 is passed as `unsigned char \*`, it
  is the binary representation, as opposed to the ASCII representation in
  hex characters, which is passed as `char *`.
// - `get_sha1()` 関数の戻り値である変数 `sha1` は `unsigned char \*` ですが、
//   実際は `unsigned char[20]` を指し示すことが想定されています。
//   この変数は指定されたコミットの 160-bit の SHA-1 を含んでいます。
//   SHA-1 が `unsigned char \*` として渡される時はいつでも、
//   それがバイナリ表現であり、`char *` で渡される 16進の ASCII表現とは違う
//   ことに注意してください。

You will see both of these things throughout the code.
// これらの両方をソースを通して確認できます。

Now, for the meat:
// さて、ここが核心です：

-----------------------------------------------------------------------------
        case 0:
                buf = read_object_with_reference(sha1, argv[1], &size, NULL);
-----------------------------------------------------------------------------

This is how you read a blob (actually, not only a blob, but any type of
object).  To know how the function `read_object_with_reference()` actually
works, find the source code for it (something like `git grep
read_object_with | grep ":[a-z]"` in the git repository), and read
the source.
// これが blob (実際のところ、blob だけでなくすべてのオブジェクト)を読む方法です。
// この関数 `read_object_with_reference()` がどのように動くかを知る為には
// その部分のソースコードを `git grep read_object_with | grep ":[a-z]"` のように
// して見つけ出し、ソースを読むことです。

To find out how the result can be used, just read on in `cmd_cat_file()`:
// 結果がどのように使用されるかを見つけるには、`cmd_cat_file()` 内を見ます：

-----------------------------------
        write_or_die(1, buf, size);
-----------------------------------

Sometimes, you do not know where to look for a feature.  In many such cases,
it helps to search through the output of `git log`, and then `git show` the
corresponding commit.
// 時には機能の実装箇所を探し出すことができない場合があるかもしれません。
// そのような場合には、`git log` の出力を探しだし、関連するコミットを `git show`
// すると手助けになるかもしれません。

Example: If you know that there was some test case for `git bundle`, but
do not remember where it was (yes, you _could_ `git grep bundle t/`, but that
does not illustrate the point!):
// 例： `git bundle` に対するテストケースがあることは知っているが、
// それがどこにあるかがわからない場合 (もちろん、`git grep bundle t/` することも
// できますが、それではポイントを示すことになりません！)：

------------------------
$ git log --no-merges t/
------------------------

In the pager (`less`), just search for "bundle", go a few lines back,
and see that it is in commit 18449ab0...  Now just copy this object name,
and paste it into the command line
// ページャ (`less`) 内で "bundle" を検索し、数行戻ると、
// commit 18449ab0... にあるのがわかります。このオブジェクト名をコピーし
// コマンドラインにペーストします

-------------------
$ git show 18449ab0
-------------------

Voila.
// ビンゴ！

Another example: Find out what to do in order to make some script a
builtin:
// 次の例：スクリプトをビルトイン化するために必要な作業を調べるには：

-------------------------------------------------
$ git log --no-merges --diff-filter=A builtin-*.c
-------------------------------------------------

You see, Git is actually the best tool to find out about the source of Git
itself!
// ここまでに見てきたように、Git は Git 自身のソースを調べるときにも
// 最も役に立つツールなのです！

[[glossary]]
GIT Glossary
============

include::glossary-content.txt[]

[[git-quick-start]]
Appendix A: Git Quick Reference
===============================
// == 付録Ａ：Git Quick Reference

This is a quick summary of the major commands; the previous chapters
explain how these work in more detail.
// この章は主要コマンドのクイックサマリです；
// 詳細はこれまでの章の説明を参照してください。

[[quick-creating-a-new-repository]]
Creating a new repository
-------------------------
// === 新規リポジトリの作成

From a tarball:
// tar ボールから：

-----------------------------------------------
$ tar xzf project.tar.gz
$ cd project
$ git init
Initialized empty Git repository in .git/
$ git add .
$ git commit
-----------------------------------------------

From a remote repository:
// リモートのリポジトリから：

-----------------------------------------------
$ git clone git://example.com/pub/project.git
$ cd project
-----------------------------------------------

[[managing-branches]]
Managing branches
-----------------
// === ブランチの管理

-----------------------------------------------
$ git branch	     # list all local branches in this repo
//		     # リポジトリ内のすべてのローカルブランチを表示
$ git checkout test  # switch working directory to branch "test"
//		     # 作業ディレクトリをブランチ "test" に切り替え
$ git branch new     # create branch "new" starting at current HEAD
//		     # 現在の HEAD から始まる "new" ブランチを作成
$ git branch -d new  # delete branch "new"
//		     # "new" ブランチの削除
-----------------------------------------------

Instead of basing a new branch on current HEAD (the default), use:
// 現在の HEAD (デフォルト)以外の場所から始まるブランチを作成するには、次のようにします：

-----------------------------------------------
$ git branch new test    # branch named "test"
//			 # "test" ブランチのHEADから開始するブランチ "new" を作成
$ git branch new v2.6.15 # tag named v2.6.15
//			 # タグ v2.6.15 から開始するブランチ "new" を作成
$ git branch new HEAD^   # commit before the most recent
//			 # 最新のコミットの１つ前の位置から分岐するブランチを作成
$ git branch new HEAD^^  # commit before that
//			 # 最新のコミットの２つ前の位置から分岐するブランチを作成
$ git branch new test~10 # ten commits before tip of branch "test"
//			 # ブランチ "test" の１０個前の位置から分岐するブランチを作成
-----------------------------------------------

Create and switch to a new branch at the same time:
// 新しいブランチの作成と切り替えを同時に行うには：

-----------------------------------------------
$ git checkout -b new v2.6.15
-----------------------------------------------

Update and examine branches from the repository you cloned from:
// 複製(clone)元のリポジトリのブランチを更新しテストするには：

-----------------------------------------------
$ git fetch		# update
//			# 更新
$ git branch -r		# list
//			# リモートブランチの一覧を表示
  origin/master
  origin/next
  ...
$ git checkout -b masterwork origin/master
-----------------------------------------------

Fetch a branch from a different repository, and give it a new
name in your repository:
// 他のリポジトリ上にあるブランチを取得(fetch)し、
// そのブランチに対して名前を付けるには：

-----------------------------------------------
$ git fetch git://example.com/project.git theirbranch:mybranch
$ git fetch git://example.com/project.git v2.6.15:mybranch
-----------------------------------------------

Keep a list of repositories you work with regularly:
// リポジトリの一覧を管理し、定期的にそこから変更を取得するには：

-----------------------------------------------
$ git remote add example git://example.com/project.git
$ git remote			# list remote repositories
//				# リモートリポジトリの一覧を表示
example
origin
$ git remote show example	# get details
//				# 詳細を表示
* remote example
  URL: git://example.com/project.git
  Tracked remote branches
    master
    next
    ...
$ git fetch example		# update branches from example
//				# example のブランチを更新
$ git branch -r			# list all remote branches
//				# すべてのリモートブランチの一覧を表示
-----------------------------------------------


[[exploring-history]]
Exploring history
-----------------
// === 履歴の探索

-----------------------------------------------
$ gitk			    # visualize and browse history
//			    # 履歴を視覚的にブラウズする
$ git log		    # list all commits
//			    # すべてのコミットを一覧表示する
$ git log src/		    # ...modifying src/
//			    # src/ 配下のファイルを変更している・・・
$ git log v2.6.15..v2.6.16  # ...in v2.6.16, not in v2.6.15
//			    # v2.6.16 には含まれているが、v2.6.15 には含まれていない・・・
$ git log master..test	    # ...in branch test, not in branch master
//			    # test ブランチに含まれているが、master ブランチには含まれていない・・・
$ git log test..master	    # ...in branch master, but not in test
//			    # master ブランチに含まれているが、test ブランチには含まれていない・・・
$ git log test...master	    # ...in one branch, not in both
//			    # 片方のブランチには含まれているが、両方のブランチには含まれていない・・・
$ git log -S'foo()'	    # ...where difference contain "foo()"
//			    # 差分に "foo()" を含んでいる・・・
$ git log --since="2 weeks ago"
$ git log -p		    # show patches as well
//			    # パッチも表示する
$ git show		    # most recent commit
//			    # 最新のコミットを表示
$ git diff v2.6.15..v2.6.16 # diff between two tagged versions
//			    # ２つのタグ付されたバージョン間の差分
$ git diff v2.6.15..HEAD    # diff with current head
//			    # 現在の head との差分
$ git grep "foo()"	    # search working directory for "foo()"
//			    # 作業ディレクトリ内で "foo()" を検索する
$ git grep v2.6.15 "foo()"  # search old tree for "foo()"
//			    # 過去のツリー内で "foo()" を検索する
$ git show v2.6.15:a.txt    # look at old version of a.txt
//			    # a.txt の過去のバージョンを表示する
-----------------------------------------------

Search for regressions:
// 回帰点を探す：

-----------------------------------------------
$ git bisect start
$ git bisect bad		# current version is bad
//				# 現在のバージョンは bad
$ git bisect good v2.6.13-rc2	# last known good revision
//				# 最新の good なリビジョンを知らせる
Bisecting: 675 revisions left to test after this
				# test here, then:
//				# ここからテストを行う
$ git bisect good		# if this revision is good, or
//				# このリビジョンが good の場合
$ git bisect bad		# if this revision is bad.
//				# このリビジョンが bad の場合
				# repeat until done.
//				# 回帰点を見つけるまで続ける
-----------------------------------------------

[[making-changes]]
Making changes
--------------
// === 変更する

Make sure git knows who to blame:
// 誰の変更であるかを git に知らせる：

------------------------------------------------
$ cat >>~/.gitconfig <<\EOF
[user]
	name = Your Name Comes Here
	email = you@yourdomain.example.com
EOF
------------------------------------------------

Select file contents to include in the next commit, then make the
commit:
// 次のコミットに含めるファイルの内容を指定し、
// コミットする：

-----------------------------------------------
$ git add a.txt    # updated file
//		   # 更新したファイル
$ git add b.txt    # new file
//		   # 新しいファイル
$ git rm c.txt     # old file
//		   # 削除したファイル
$ git commit
-----------------------------------------------

Or, prepare and create the commit in one step:
// コミットの準備と実行を一度に行う：

-----------------------------------------------
$ git commit d.txt # use latest content only of d.txt
//		   # d.txt の最後の内容のみをコミット
$ git commit -a	   # use latest content of all tracked files
//		   # 管理対象の全ファイルの最新の状態をコミット
-----------------------------------------------

[[merging]]
Merging
-------
// === マージ

-----------------------------------------------
$ git merge test   # merge branch "test" into the current branch
//		   # "test" ブランチを現在のブランチにマージ
$ git pull git://example.com/project.git master
		   # fetch and merge in remote branch
//		   # リモートブランチの変更を取得し、マージ
$ git pull . test  # equivalent to git merge test
//		   # git merge test と同じ
-----------------------------------------------

[[sharing-your-changes]]
Sharing your changes
--------------------
// === 変更の共有

Importing or exporting patches:
// パッチをインポートし、エクスポートするには：

-----------------------------------------------
$ git format-patch origin..HEAD # format a patch for each commit
//				# HEAD に存在するが origin には存在しない
				# in HEAD but not in origin
//				# 各コミットのパッチを整形する
$ git am mbox # import patches from the mailbox "mbox"
//	      # メールボックス "mbox" からパッチをインポートする
-----------------------------------------------

Fetch a branch in a different git repository, then merge into the
current branch:
// 他の git リポジトリ内のブランチから変更を取得し、
// 現在のブランチにマージする：

-----------------------------------------------
$ git pull git://example.com/project.git theirbranch
-----------------------------------------------

Store the fetched branch into a local branch before merging into the
current branch:
// 現在のブランチにマージする前にローカルブランチに変更を格納する：

-----------------------------------------------
$ git pull git://example.com/project.git theirbranch:mybranch
-----------------------------------------------

After creating commits on a local branch, update the remote
branch with your commits:
// ローカルブランチ上でコミットした後に、リモートブランチに
// その内容を反映させる：

-----------------------------------------------
$ git push ssh://example.com/project.git mybranch:theirbranch
-----------------------------------------------

When remote and local branch are both named "test":
// リモートブランチとローカルブランチの名前が両方とも "test" である場合：

-----------------------------------------------
$ git push ssh://example.com/project.git test
-----------------------------------------------

Shortcut version for a frequently used remote repository:
// よく使用するリモートリポジトリに対して略称を付ける：

-----------------------------------------------
$ git remote add example ssh://example.com/project.git
$ git push example test
-----------------------------------------------

[[repository-maintenance]]
Repository maintenance
----------------------
// === リポジトリのメンテナンス

Check for corruption:
// 破損していないか検査する：

-----------------------------------------------
$ git fsck
-----------------------------------------------

Recompress, remove unused cruft:
// リポジトリを圧縮し、使用していないゴミを削除する：

-----------------------------------------------
$ git gc
-----------------------------------------------


[[todo]]
Appendix B: Notes and todo list for this manual
===============================================
// == 付録 B: このマニュアルの覚え書きとTODOリスト

This is a work in progress.
// この仕事は作業中です。

The basic requirements:
// 基本要件：

- It must be readable in order, from beginning to end, by someone
  intelligent with a basic grasp of the UNIX command line, but without
  any special knowledge of git.  If necessary, any other prerequisites
  should be specifically mentioned as they arise.
// - UNIXコマンドラインの基礎知識があれば、git の前提知識がなくても
// 最初から最後まで順番に読み進められること。必要なときは、
// その都度、他の前提知識が必要であることが述べられること。
- Whenever possible, section headings should clearly describe the task
  they explain how to do, in language that requires no more knowledge
  than necessary: for example, "importing patches into a project" rather
  than "the `git am` command"
// - 可能な時はいつでも、節の冒頭で方法を説明するタスクを明示的に説明するべきで、
// 言語に関する知識は必要以上には要求しない：例えば、"`git am` コマンド"
// ではなく、"パッチをプロジェクトにインポートする" とする。

Think about how to create a clear chapter dependency graph that will
allow people to get to important topics without necessarily reading
everything in between.
// 全内容を読まなくても重要なトピックスの理解ができるよう、
// 各章の依存関係を明確にしたグラフの作成方法を考えるべきです。

Scan Documentation/ for other stuff left out; in particular:
// Documentation/ ディレクトリをスキャンし、他の残項目を探す；特に：

- howto's
- some of technical/?
- hooks
- list of commands in linkgit:git[1]
//	howto に関するもの
//	technical/ の下のいくつか？
//	フック
//	linkgit:git[1] 内のコマンドの一覧

Scan email archives for other stuff left out
// E-mail のアーカイブをスキャンし、他の残項目を探す。

Scan man pages to see if any assume more background than this manual
provides.
// man ページをスキャンし、to see if any assume more background than this manual
// provides.

Simplify beginning by suggesting disconnected head instead of
temporary branch creation?
// Simplify beginning by suggesting disconnected head instead of
// temporary branch creation?

Add more good examples.  Entire sections of just cookbook examples
might be a good idea; maybe make an "advanced examples" section a
standard end-of-chapter section?
// より良い例を追加する。全てのセクションに使用例を追加するのは
// 良いアイデアかもしれない；"高度な例" を章末のセクションに追加する？

Include cross-references to the glossary, where appropriate.
// 用語集への相互参照を適切な場所に盛り込む。

Document shallow clones?  See draft 1.5.0 release notes for some
documentation.
// shallow clone のドキュメントは？ ドラフト版の 1.5.0 のリリースノート
// に幾らかの説明があります。

Add a section on working with other version control systems, including
CVS, Subversion, and just imports of series of release tarballs.
// 他のバージョン管理システムと作業する場合に関するセクションを追加する。
// CVS, Subversion も含めて。リリースする tarball にそれらをインポートする。

More details on gitweb?
// gitweb に関するより詳しい説明？

Write a chapter on using plumbing and writing scripts.
// 配管スクリプトの使用と、スクリプトの書き方に関する章を追加。

Alternates, clone -reference, etc.
// 交互の、clone -reference, など

More on recovery from repository corruption.  See:
	http://marc.theaimsgroup.com/?l=git&m=117263864820799&w=2
	http://marc.theaimsgroup.com/?l=git&m=117147855503798&w=2
// リポジトリの破損からの復旧についてより詳しく。参照：
// 	http://marc.theaimsgroup.com/?l=git&m=117263864820799&w=2
// 	http://marc.theaimsgroup.com/?l=git&m=117147855503798&w=2
