# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2013-12-07 00:31+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: ../../gittutorial.txt:31 ../../user-manual.txt:29
msgid "or:"
msgstr "もしくは:"

#. type: Plain text
#: ../../gittutorial.txt:38 ../../user-manual.txt:36
msgid ""
"With the latter, you can use the manual viewer of your choice; see linkgit:"
"git-help[1] for more information."
msgstr ""
"後者の方法では、マニュアルのビューアを指定できます；詳細は linkgit:git-help"
"[1] を参照して下さい。 "

#. type: delimited block -
#: ../../gittutorial.txt:83 ../../gittutorial.txt:125
#: ../../user-manual.txt:1084
#, fuzzy, no-wrap
msgid "$ git commit\n"
msgstr "$ git commit\n"

#. type: Title -
#: ../../gittutorial.txt:89 ../../user-manual.txt:4413
#, fuzzy, no-wrap
msgid "Making changes"
msgstr ""
"#-#-#-#-#  gittutorial.txt.po  #-#-#-#-#\n"
"変更の実施\n"
"#-#-#-#-#  user-manual.txt.po (PACKAGE VERSION)  #-#-#-#-#\n"
"変更する"

#. type: delimited block -
#: ../../gittutorial.txt:102 ../../user-manual.txt:1065
#, fuzzy, no-wrap
msgid "$ git diff --cached\n"
msgstr "$ git diff --cached\n"

#. type: delimited block -
#: ../../gittutorial.txt:134 ../../gittutorial.txt:250
#: ../../user-manual.txt:1097
#, fuzzy, no-wrap
msgid "$ git commit -a\n"
msgstr "$ git commit -a\n"

#. type: delimited block -
#: ../../gittutorial.txt:171 ../../user-manual.txt:671
#, fuzzy, no-wrap
msgid "$ git log -p\n"
msgstr "$ git log -p\n"

#. type: Title -
#: ../../gittutorial.txt:181 ../../user-manual.txt:4312
#, fuzzy, no-wrap
msgid "Managing branches"
msgstr ""
"#-#-#-#-#  gittutorial.txt.po  #-#-#-#-#\n"
"ブランチ管理\n"
"#-#-#-#-#  user-manual.txt.po (PACKAGE VERSION)  #-#-#-#-#\n"
"ブランチの管理"

#. type: delimited block -
#: ../../gittutorial.txt:243 ../../user-manual.txt:1072
#, fuzzy, no-wrap
msgid "$ git diff\n"
msgstr "$ git diff\n"

#. type: Title -
#: ../../gittutorial.txt:461 ../../user-manual.txt:4377
#, fuzzy, no-wrap
msgid "Exploring history"
msgstr "履歴の探索"

#. type: delimited block -
#: ../../gittutorial-2.txt:141 ../../user-manual.txt:304
#, fuzzy, no-wrap
msgid ""
"$ cat .git/HEAD\n"
"ref: refs/heads/master\n"
msgstr ""
"$ cat .git/HEAD\n"
"ref: refs/heads/master\n"

#. type: Title -
#: ../../everyday.txt:51 ../../everyday.txt:127 ../../everyday.txt:230
#: ../../everyday.txt:312 ../../user-manual.txt:728 ../../user-manual.txt:2061
#, fuzzy, no-wrap
msgid "Examples"
msgstr "Examples"

#. type: delimited block -
#: ../../git-bisect.txt:89 ../../user-manual.txt:515
#, fuzzy, no-wrap
msgid "$ git bisect reset\n"
msgstr "$ git bisect reset\n"

#. type: delimited block -
#: ../../git-bisect.txt:114 ../../user-manual.txt:527
#, fuzzy, no-wrap
msgid "$ git bisect visualize\n"
msgstr "$ git bisect visualize\n"

#. type: Plain text
#: ../../user-manual.txt:2
#, fuzzy
msgid "Git User's Manual (for version 1.5.3 or newer)"
msgstr "Git ユーザマニュアル (バージョン 1.5.3 以降用)"

#. type: delimited block _
#: ../../user-manual.txt:6
#, fuzzy
msgid "Git is a fast distributed revision control system."
msgstr "git は高速な分散リビジョン管理システムです。"

#. type: delimited block _
#: ../../user-manual.txt:9
#, fuzzy
msgid ""
"This manual is designed to be readable by someone with basic UNIX command-"
"line skills, but no previous knowledge of git."
msgstr ""
"このマニュアルは、基本的な UNIX コマンドのスキルをもった人が読むことを想定し"
"ていますが、 git に関する前提知識は必要ありません。"

#. type: delimited block _
#: ../../user-manual.txt:14
#, fuzzy
msgid ""
"<<repositories-and-branches>> and <<exploring-git-history>> explain how to "
"fetch and study a project using git--read these chapters to learn how to "
"build and test a particular version of a software project, search for "
"regressions, and so on."
msgstr ""
"<<repositories-and-branches>> と <<exploring-git-history>> では git を使用し"
"てプロジェクトを取得・調査する方法を説明します。--これらの章を読むことで、ソ"
"フトウェアプロジェクトの特定のバージョンをビルドして テストしたり、回帰点を探"
"し出す方法などを習得してください。"

#. type: delimited block _
#: ../../user-manual.txt:17
#, fuzzy
msgid ""
"People needing to do actual development will also want to read <<Developing-"
"With-git>> and <<sharing-development>>."
msgstr ""
"実際に開発する必要のある場合は、<<Developing-With-git>> と <<sharing-"
"development>> も読んでください。"

#. type: delimited block _
#: ../../user-manual.txt:19
#, fuzzy
msgid "Further chapters cover more specialized topics."
msgstr "さらに後ろの章では、より特化したトピックスを取り上げます。"

#. type: delimited block _
#: ../../user-manual.txt:23
#, fuzzy
msgid ""
"Comprehensive reference documentation is available through the man pages, or "
"linkgit:git-help[1] command.  For example, for the command \"git clone <repo>"
"\", you can either use:"
msgstr ""
"包括的なリファレンスドキュメントは man ページ もしくはコマンドlinkgit:git-"
"help[1]で確認できます。 例えば、\"git clone　<repo>\" のコマンドは次の どちら"
"のようにしても確認できます。"

#. type: delimited block -
#: ../../user-manual.txt:26
#, fuzzy, no-wrap
msgid "$ man git-clone\n"
msgstr "$ man git-clone\n"

#. type: delimited block -
#: ../../user-manual.txt:32
#, fuzzy, no-wrap
msgid "$ git help clone\n"
msgstr "$ git help clone\n"

#. type: Plain text
#: ../../user-manual.txt:39
#, fuzzy
msgid ""
"See also <<git-quick-start>> for a brief overview of git commands, without "
"any explanation."
msgstr "git コマンドの概要を知るには <<git-quick-start>> を参照してください。"

#. type: Plain text
#: ../../user-manual.txt:42
#, fuzzy
msgid ""
"Finally, see <<todo>> for ways that you can help make this manual more "
"complete."
msgstr ""
"最後に、<<todo>> では、このマニュアルをより完全にする為の情報を説明していま"
"す。"

#. type: Title =
#: ../../user-manual.txt:46
#, fuzzy, no-wrap
msgid "Repositories and Branches"
msgstr "リポジトリとブランチ"

#. type: Title -
#: ../../user-manual.txt:50
#, fuzzy, no-wrap
msgid "How to get a git repository"
msgstr "git リポジトリの取得方法"

#. type: Plain text
#: ../../user-manual.txt:54
#, fuzzy
msgid ""
"It will be useful to have a git repository to experiment with as you read "
"this manual."
msgstr ""
"このマニュアルを読む際には、実験用のリポジトリを取得しておくと便利です。"

#. type: Plain text
#: ../../user-manual.txt:58
#, fuzzy
msgid ""
"The best way to get one is by using the linkgit:git-clone[1] command to "
"download a copy of an existing repository.  If you don't already have a "
"project in mind, here are some interesting examples:"
msgstr ""
"実験用リポジトリを取得する一番良い方法は linkgit:git-clone[1] コマンドを使用"
"し、 既存のリポジトリのコピーをダウンロードすることです。"

#. type: delimited block -
#: ../../user-manual.txt:64
#, fuzzy, no-wrap
msgid ""
"\t# git itself (approx. 10MB download):\n"
"$ git clone git://git.kernel.org/pub/scm/git/git.git\n"
"\t# the Linux kernel (approx. 150MB download):\n"
"$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git\n"
msgstr ""
"\t# git 自身 (ダウンロードサイズは約10MB)：\n"
"$ git clone git://git.kernel.org/pub/scm/git/git.git\n"
"\t# linux カーネル (ダウンロードサイズは150MB)：\n"
"$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git\n"

#. type: Plain text
#: ../../user-manual.txt:68
#, fuzzy
msgid ""
"The initial clone may be time-consuming for a large project, but you will "
"only need to clone once."
msgstr ""
"初めてのclone(複製)では大きなプロジェクトの場合、時間をかなり消費するかもしれ"
"ませんが、 clone は１回行なうだけで良いです。"

#. type: Plain text
#: ../../user-manual.txt:75
#, fuzzy
msgid ""
"The clone command creates a new directory named after the project (\"git\" "
"or \"linux-2.6\" in the examples above).  After you cd into this directory, "
"you will see that it contains a copy of the project files, called the "
"<<def_working_tree,working tree>>, together with a special top-level "
"directory named \".git\", which contains all the information about the "
"history of the project."
msgstr ""
"clone コマンドはそのプロジェクトにちなんだ新しいディレクトリを作成します (上"
"記例では \"git\" 又は \"linux-2.6\")。 このディレクトリ内にはプロジェクトファ"
"イルのコピーが存在し (これは <<def_working_tree,作業ツリー>> といいます)、 そ"
"れと一緒に \".git\" という特別なトップレベルディレクトリが存在します。 \".git"
"\" ディレクトリにはプロジェクトの履歴の全てが含まれています。"

#. type: Title -
#: ../../user-manual.txt:78
#, fuzzy, no-wrap
msgid "How to check out a different version of a project"
msgstr "プロジェクトの他のバージョンのチェックアウト方法"

#. type: Plain text
#: ../../user-manual.txt:84
#, fuzzy
msgid ""
"Git is best thought of as a tool for storing the history of a collection of "
"files.  It stores the history as a compressed collection of interrelated "
"snapshots of the project's contents.  In git each such version is called a "
"<<def_commit,commit>>."
msgstr ""
"git はファイル集合の履歴を格納するツールとして非常によく考えられたツールで"
"す。 git は履歴を圧縮した集合として格納し、 プロジェクトの内容を相互に関連し"
"たスナップショットとして格納します。 git ではこれらのバージョンを "
"<<def_commit,コミット>> と呼びます。"

#. type: Plain text
#: ../../user-manual.txt:89
#, fuzzy
msgid ""
"Those snapshots aren't necessarily all arranged in a single line from oldest "
"to newest; instead, work may simultaneously proceed along parallel lines of "
"development, called <<def_branch,branches>>, which may merge and diverge."
msgstr ""
"それらのスナップショットは必ずしもすべてが古いものから最新のものに 単線で並ん"
"でいるとは限りません；その代り、開発ラインが並行して 進むことがあります (これ"
"は <<def_branch,ブランチ>> といいます)。 ブランチは分岐し統合されます。"

#. type: Plain text
#: ../../user-manual.txt:94
#, fuzzy
msgid ""
"A single git repository can track development on multiple branches.  It does "
"this by keeping a list of <<def_head,heads>> which reference the latest "
"commit on each branch; the linkgit:git-branch[1] command shows you the list "
"of branch heads:"
msgstr ""
"１つの git リポジトリは複数のブランチを追跡することができます。 Git は 各ブラ"
"ンチの最新のコミットの参照を <<def_head,ヘッド>> の 一覧に保管することで複数"
"のブランチを追跡します； linkgit:git-branch[1] コマンドはブランチの一覧を表示"
"します："

#. type: delimited block -
#: ../../user-manual.txt:98
#, fuzzy, no-wrap
msgid ""
"$ git branch\n"
"* master\n"
msgstr ""
"$ git branch\n"
"* master\n"

#. type: Plain text
#: ../../user-manual.txt:103
#, fuzzy
msgid ""
"A freshly cloned repository contains a single branch head, by default named "
"\"master\", with the working directory initialized to the state of the "
"project referred to by that branch head."
msgstr ""
"新しく clone したリポジトリは、１つのブランチヘッド(デフォルトではその名前は "
"\"master\"です)  を持っており、作業ディレクトリは、そのブランチ head が参照す"
"るプロジェクトの状態で 初期化されています。"

#. type: Plain text
#: ../../user-manual.txt:107
#, fuzzy
msgid ""
"Most projects also use <<def_tag,tags>>.  Tags, like heads, are references "
"into the project's history, and can be listed using the linkgit:git-tag[1] "
"command:"
msgstr ""
"多くのプロジェクトは <<def_tag,tags>> も使用しています。 tag は head のように"
"プロジェクトの履歴を参照していて、 linkgit:git-tag[1] コマンドを用いてリスト"
"表示できます。"

#. type: delimited block -
#: ../../user-manual.txt:120
#, fuzzy, no-wrap
msgid ""
"$ git tag -l\n"
"v2.6.11\n"
"v2.6.11-tree\n"
"v2.6.12\n"
"v2.6.12-rc2\n"
"v2.6.12-rc3\n"
"v2.6.12-rc4\n"
"v2.6.12-rc5\n"
"v2.6.12-rc6\n"
"v2.6.13\n"
"...\n"
msgstr ""
"$ git tag -l\n"
"v2.6.11\n"
"v2.6.11-tree\n"
"v2.6.12\n"
"v2.6.12-rc2\n"
"v2.6.12-rc3\n"
"v2.6.12-rc4\n"
"v2.6.12-rc5\n"
"v2.6.12-rc6\n"
"v2.6.13\n"
"...\n"

#. type: Plain text
#: ../../user-manual.txt:124
#, fuzzy
msgid ""
"Tags are expected to always point at the same version of a project, while "
"heads are expected to advance as development progresses."
msgstr ""
"tag は常にプロジェクトの特定のバージョンを指し示し、 head は開発が進むに従い"
"更新されていきます。"

#. type: Plain text
#: ../../user-manual.txt:127
#, fuzzy
msgid ""
"Create a new branch head pointing to one of these versions and check it out "
"using linkgit:git-checkout[1]:"
msgstr ""
"あるバージョンを指し示す新しいブランチの head を作成し、 そのブランチの head "
"をチェックアウトするには linkgit:git-checkout[1] を使用します："

#. type: delimited block -
#: ../../user-manual.txt:130
#, fuzzy, no-wrap
msgid "$ git checkout -b new v2.6.13\n"
msgstr "$ git checkout -b new v2.6.13\n"

#. type: Plain text
#: ../../user-manual.txt:135
#, fuzzy
msgid ""
"The working directory then reflects the contents that the project had when "
"it was tagged v2.6.13, and linkgit:git-branch[1] shows two branches, with an "
"asterisk marking the currently checked-out branch:"
msgstr ""
"この時、作業ディレクトリは v2.6.13 の tag を付けた時に プロジェクトのもってい"
"た内容が反映されています。 そして、linkgit:git-branch[1] すると２つのブランチ"
"が表示され、 現在チェックアウトしているブランチのマークがアスタリスク(*)で表"
"示されます。"

#. type: delimited block -
#: ../../user-manual.txt:140
#, fuzzy, no-wrap
msgid ""
"$ git branch\n"
"  master\n"
"* new\n"
msgstr ""
"$ git branch\n"
"  master\n"
"* new\n"

#. type: Plain text
#: ../../user-manual.txt:144
#, fuzzy
msgid ""
"If you decide that you'd rather see version 2.6.17, you can modify the "
"current branch to point at v2.6.17 instead, with"
msgstr ""
"もしバージョン 2.6.17 をむしろ参照したいと考えたなら、 現在のブランチを "
"v2.6.17 を参照するように変更できます。次のようにして："

#. type: delimited block -
#: ../../user-manual.txt:147
#, fuzzy, no-wrap
msgid "$ git reset --hard v2.6.17\n"
msgstr "$ git reset --hard v2.6.17\n"

#. type: Plain text
#: ../../user-manual.txt:153
#, fuzzy
msgid ""
"Note that if the current branch head was your only reference to a particular "
"point in history, then resetting that branch may leave you with no way to "
"find the history it used to point to; so use this command carefully."
msgstr ""
"ある特定の履歴がを参照しているのが、現在のブランチのみの場合、 ブランチをリ"
"セットすると、もやはその履歴を参照できなくなることに注意してください； ですか"
"ら、このコマンドは注意して使用してください。"

#. type: Title -
#: ../../user-manual.txt:156
#, fuzzy, no-wrap
msgid "Understanding History: Commits"
msgstr "履歴の理解：コミット"

#. type: Plain text
#: ../../user-manual.txt:161
#, fuzzy
msgid ""
"Every change in the history of a project is represented by a commit.  The "
"linkgit:git-show[1] command shows the most recent commit on the current "
"branch:"
msgstr ""
"プロジェクトの全ての変更履歴は、commit として表現されます。 linkgit:git-show"
"[1] コマンドは現在のブランチ上で最後にコミットした 履歴を表示します："

#. type: delimited block -
#: ../../user-manual.txt:167
#, fuzzy, no-wrap
msgid ""
"$ git show\n"
"commit 17cf781661e6d38f737f15f53ab552f1e95960d7\n"
"Author: Linus Torvalds <torvalds@ppc970.osdl.org.(none)>\n"
"Date:   Tue Apr 19 14:11:06 2005 -0700\n"
msgstr ""
"$ git show\n"
"commit 17cf781661e6d38f737f15f53ab552f1e95960d7\n"
"Author: Linus Torvalds <torvalds@ppc970.osdl.org.(none)>\n"
"Date:   Tue Apr 19 14:11:06 2005 -0700\n"

#. type: delimited block -
#: ../../user-manual.txt:169
#, fuzzy, no-wrap
msgid "    Remove duplicate getenv(DB_ENVIRONMENT) call\n"
msgstr "    Remove duplicate getenv(DB_ENVIRONMENT) call\n"

#. type: delimited block -
#: ../../user-manual.txt:171
#, fuzzy, no-wrap
msgid "    Noted by Tony Luck.\n"
msgstr "    Noted by Tony Luck.\n"

#. type: delimited block -
#: ../../user-manual.txt:177
#, fuzzy, no-wrap
msgid ""
"diff --git a/init-db.c b/init-db.c\n"
"index 65898fa..b002dc6 100644\n"
"--- a/init-db.c\n"
"+++ b/init-db.c\n"
"@@ -7,7 +7,7 @@\n"
msgstr ""
"diff --git a/init-db.c b/init-db.c\n"
"index 65898fa..b002dc6 100644\n"
"--- a/init-db.c\n"
"+++ b/init-db.c\n"
"@@ -7,7 +7,7 @@\n"

#. type: delimited block -
#: ../../user-manual.txt:183
#, fuzzy, no-wrap
msgid ""
" int main(int argc, char **argv)\n"
" {\n"
"-\tchar *sha1_dir = getenv(DB_ENVIRONMENT), *path;\n"
"+\tchar *sha1_dir, *path;\n"
" \tint len, i;\n"
msgstr ""
" int main(int argc, char **argv)\n"
" {\n"
"-\tchar *sha1_dir = getenv(DB_ENVIRONMENT), *path;\n"
"+\tchar *sha1_dir, *path;\n"
" \tint len, i;\n"

#. type: delimited block -
#: ../../user-manual.txt:185
#, fuzzy, no-wrap
msgid " \tif (mkdir(\".git\", 0755) < 0) {\n"
msgstr " \tif (mkdir(\".git\", 0755) < 0) {\n"

#. type: Plain text
#: ../../user-manual.txt:189
#, fuzzy
msgid ""
"As you can see, a commit shows who made the latest change, what they did, "
"and why."
msgstr ""
"このように、コミットは誰が最後に変更したか、何を、何故変更したかを表示しま"
"す。"

#. type: Plain text
#: ../../user-manual.txt:200
#, fuzzy
msgid ""
"Every commit has a 40-hexdigit id, sometimes called the \"object name\" or "
"the \"SHA-1 id\", shown on the first line of the \"git show\" output.  You "
"can usually refer to a commit by a shorter name, such as a tag or a branch "
"name, but this longer name can also be useful.  Most importantly, it is a "
"globally unique name for this commit: so if you tell somebody else the "
"object name (for example in email), then you are guaranteed that name will "
"refer to the same commit in their repository that it does in yours (assuming "
"their repository has that commit at all).  Since the object name is computed "
"as a hash over the contents of the commit, you are guaranteed that the "
"commit can never change without its name also changing."
msgstr ""
"全てのコミットは 40桁の16進数の ID (\"オブジェクト名\" 又は \"SHA-1 id\" と呼"
"ぶこともあります)  を持ち、\"git show\" の出力の１行目にその ID が表示されま"
"す。 通常、コミットはタグやブランチ名のような短い名前で参照できますが、 この"
"長い名前も役に立つことがあります。特に重要なのは、この ID がこのコミットを 大"
"局的にユニークにしている点です：つまり、他のだれかにその ID を (例えば email"
"で)伝えた場合、その ID が彼らのリポジトリ内でもあなたのリポジトリ内でも 同じ"
"コミットを指し示すことを保障しています。 (彼らのリポジトリにそのコミットが完"
"全に含まれている場合にはです)。 オブジェクト名はコミット対象のコンテンツの"
"ハッシュとして計算される為、 変更しない限りは、決して変わらないことが保障され"
"ています。"

#. type: Plain text
#: ../../user-manual.txt:204
#, fuzzy
msgid ""
"In fact, in <<git-concepts>> we shall see that everything stored in git "
"history, including file data and directory contents, is stored in an object "
"with a name that is a hash of its contents."
msgstr ""
"実際、<<git-concepts,gitのコンセプト>> では、git に格納されている全ての履歴"
"が、 ファイルデータとディレクトリの中身も含めて、その中身のハッシュの名前で "
"オブジェクトが格納されていることを見るでしょう。"

#. type: Title ~
#: ../../user-manual.txt:207
#, fuzzy, no-wrap
msgid "Understanding history: commits, parents, and reachability"
msgstr "履歴の理解：コミット、親、到達可能性"

#. type: Plain text
#: ../../user-manual.txt:213
#, fuzzy
msgid ""
"Every commit (except the very first commit in a project) also has a parent "
"commit which shows what happened before this commit.  Following the chain of "
"parents will eventually take you back to the beginning of the project."
msgstr ""
"全てのコミットは(プロジェクトの最初のコミットを除き)、そのコミットの前に 行わ"
"れた変更を示す親のコミットを持っています。 親のつながりは最終的にはプロジェク"
"トの開始点まで繋がっています。"

#. type: Plain text
#: ../../user-manual.txt:220
#, fuzzy
msgid ""
"However, the commits do not form a simple list; git allows lines of "
"development to diverge and then reconverge, and the point where two lines of "
"development reconverge is called a \"merge\".  The commit representing a "
"merge can therefore have more than one parent, with each parent representing "
"the most recent commit on one of the lines of development leading to that "
"point."
msgstr ""
"しかし、コミットは単純なリストの形式にはなりません； git は分散開発とその統合"
"を許可しており、２つの開発ラインが統合する点は、 \"マージ\" と呼ばれます。そ"
"の為、マージを表現するコミットは１つ以上の親を持ち、 各親はその点につながる開"
"発ラインの最新コミットを表現しています。"

#. type: Plain text
#: ../../user-manual.txt:224
#, fuzzy
msgid ""
"The best way to see how this works is using the linkgit:gitk[1] command; "
"running gitk now on a git repository and looking for merge commits will help "
"understand how the git organizes history."
msgstr ""
"これがどのように作業するかを見る最良の方法は linkgit:gitk[1] コマンドを 使用"
"することです；git リポジトリ上で gitk を実行し、マージコミットを 探すことで、"
"git が履歴をどのように整理しているかを理解することができます。"

#. type: Plain text
#: ../../user-manual.txt:229
#, fuzzy
msgid ""
"In the following, we say that commit X is \"reachable\" from commit Y if "
"commit X is an ancestor of commit Y.  Equivalently, you could say that Y is "
"a descendant of X, or that there is a chain of parents leading from commit Y "
"to commit X."
msgstr ""
"以下では、コミット X がコミット Y の祖先である場合に、 コミット X はコミット "
"Y から \"到達可能\"(reachable) であると言うことにします。 同様に、Y は X の子"
"孫である、あるいは、コミット Y から コミット X へ 繋がる親のチェーンがあると"
"言うこともできます。"

#. type: Title ~
#: ../../user-manual.txt:232
#, fuzzy, no-wrap
msgid "Understanding history: History diagrams"
msgstr "履歴の理解：履歴ダイアグラム"

#. type: Plain text
#: ../../user-manual.txt:237
#, fuzzy
msgid ""
"We will sometimes represent git history using diagrams like the one below.  "
"Commits are shown as \"o\", and the links between them with lines drawn with "
"- / and \\.  Time goes left to right:"
msgstr ""
"時々 git の履歴を以下のようなダイアグラムを使用して表現することがあります。 "
"コミットは \"o\" で、コミット間のリンクは - / \\ です。 時間は左から右に流れ"
"ます："

#. type: delimited block .
#: ../../user-manual.txt:245
#, fuzzy, no-wrap
msgid ""
"         o--o--o <-- Branch A\n"
"        /\n"
" o--o--o <-- master\n"
"        \\\n"
"         o--o--o <-- Branch B\n"
msgstr ""
"         o--o--o <-- Branch A\n"
"        /\n"
" o--o--o <-- master\n"
"        \\\n"
"         o--o--o <-- Branch B\n"

#. type: Plain text
#: ../../user-manual.txt:249
#, fuzzy
msgid ""
"If we need to talk about a particular commit, the character \"o\" may be "
"replaced with another letter or number."
msgstr ""
"特定のコミットについて話をする必要がある時は。記号 \"o\" は 他の文字や数字に"
"置き換えられることもあります。"

#. type: Title ~
#: ../../user-manual.txt:252
#, fuzzy, no-wrap
msgid "Understanding history: What is a branch?"
msgstr "履歴の理解：ブランチとは？"

#. type: Plain text
#: ../../user-manual.txt:260
#, fuzzy
msgid ""
"When we need to be precise, we will use the word \"branch\" to mean a line "
"of development, and \"branch head\" (or just \"head\") to mean a reference "
"to the most recent commit on a branch.  In the example above, the branch "
"head named \"A\" is a pointer to one particular commit, but we refer to the "
"line of three commits leading up to that point as all being part of \"branch "
"A\"."
msgstr ""
"正確さが必要な時は、用語 \"ブランチ\" は開発ラインという意味で使用し、 \"ブラ"
"ンチのヘッド\" (あるいは単に \"ヘッド\") はブランチ上の最新のコミット という"
"意味で使用します。上記例では、\"A\" というブランチヘッドは、 ある特定コミット"
"の点を指しますが、その点につながる３つのコミットの線は 全て \"ブランチ A\" を"
"構成する部品です。"

#. type: Plain text
#: ../../user-manual.txt:263
#, fuzzy
msgid ""
"However, when no confusion will result, we often just use the term \"branch"
"\" both for branches and for branch heads."
msgstr ""
"しかしながら、混乱が起きないようなときには、ブランチの場合にも ブランチのヘッ"
"ドの場合にも単に \"ブランチ\" ということがあります。"

#. type: Title -
#: ../../user-manual.txt:266
#, fuzzy, no-wrap
msgid "Manipulating branches"
msgstr "ブランチの運用"

#. type: Plain text
#: ../../user-manual.txt:270
#, fuzzy
msgid ""
"Creating, deleting, and modifying branches is quick and easy; here's a "
"summary of the commands:"
msgstr ""
"ブランチの作成/削除/変更はとても簡単です； 以下にコマンドのサマリを載せます："

#. type: Labeled list
#: ../../user-manual.txt:271
#, fuzzy, no-wrap
msgid "git branch"
msgstr "git branch"

#. type: Plain text
#: ../../user-manual.txt:273
#, fuzzy
msgid "list all branches"
msgstr "全てのブランチを一覧表示"

#. type: Labeled list
#: ../../user-manual.txt:273
#, fuzzy, no-wrap
msgid "git branch <branch>"
msgstr "git branch <branch>"

#. type: Plain text
#: ../../user-manual.txt:276
#, fuzzy
msgid ""
"create a new branch named <branch>, referencing the same point in history as "
"the current branch"
msgstr "現在のブランチと同じ履歴点を参照する 新しいブランチ <branch> を作成"

#. type: Labeled list
#: ../../user-manual.txt:276
#, fuzzy, no-wrap
msgid "git branch <branch> <start-point>"
msgstr "git branch <branch> <start-point>"

#. type: Plain text
#: ../../user-manual.txt:280
#, fuzzy
msgid ""
"create a new branch named <branch>, referencing <start-point>, which may be "
"specified any way you like, including using a branch name or a tag name"
msgstr ""
"<start-point> を参照する新しいブランチ <branch> を作成。 <start-point> にはブ"
"ランチ名又はタグ名を含む任意の名前を指定できます。"

#. type: Labeled list
#: ../../user-manual.txt:280
#, fuzzy, no-wrap
msgid "git branch -d <branch>"
msgstr "git branch -d <branch>"

#. type: Plain text
#: ../../user-manual.txt:284
#, fuzzy
msgid ""
"delete the branch <branch>; if the branch you are deleting points to a "
"commit which is not reachable from the current branch, this command will "
"fail with a warning."
msgstr ""
"ブランチ <branch> を削除； 現在のブランチから到達不可能なコミットを削除する場"
"合、 このコマンドは警告を表示して終了します。"

#. type: Labeled list
#: ../../user-manual.txt:284
#, fuzzy, no-wrap
msgid "git branch -D <branch>"
msgstr "git branch -D <branch>"

#. type: Plain text
#: ../../user-manual.txt:290
#, fuzzy
msgid ""
"even if the branch points to a commit not reachable from the current branch, "
"you may know that that commit is still reachable from some other branch or "
"tag.  In that case it is safe to use this command to force git to delete the "
"branch."
msgstr ""
"ブランチ <branch> を削除； ブランチのコミットが現在のブランチから到達不可能な"
"場合でも、 他のブランチ又はタグからそのコミットが到達可能な場合があります。 "
"その場合にこのコマンドを使用すると、強制的にブランチを削除することができま"
"す。"

#. type: Labeled list
#: ../../user-manual.txt:290
#, fuzzy, no-wrap
msgid "git checkout <branch>"
msgstr "git checkout <branch>"

#. type: Plain text
#: ../../user-manual.txt:293
#, fuzzy
msgid ""
"make the current branch <branch>, updating the working directory to reflect "
"the version referenced by <branch>"
msgstr ""
"現在のブランチを <branch> に変更し、作業ディレクトリを <branch> が 参照する"
"バージョンの状態にします。"

#. type: Labeled list
#: ../../user-manual.txt:293
#, fuzzy, no-wrap
msgid "git checkout -b <new> <start-point>"
msgstr "git checkout -b <new> <start-point>"

#. type: Plain text
#: ../../user-manual.txt:296
#, fuzzy
msgid "create a new branch <new> referencing <start-point>, and check it out."
msgstr ""
"<start-point> を参照する新しいブランチ <new> を作成し、 そのブランチをチェッ"
"クアウトします。"

#. type: Plain text
#: ../../user-manual.txt:300
#, fuzzy
msgid ""
"The special symbol \"HEAD\" can always be used to refer to the current "
"branch.  In fact, git uses a file named \"HEAD\" in the .git directory to "
"remember which branch is current:"
msgstr ""
"特別なシンボル \"HEAD\" 使用すると、常に現在のブランチを参照することができま"
"す。 実際 git は .git ディレクトリにある \"HEAD\" という名前のファイルを使用"
"して 現在のブランチの場所を記憶しています。"

#. type: Title -
#: ../../user-manual.txt:308
#, fuzzy, no-wrap
msgid "Examining an old version without creating a new branch"
msgstr "新しいブランチを作成せずに古いバージョンを取得する方法"

#. type: Plain text
#: ../../user-manual.txt:313
#, fuzzy
msgid ""
"The `git checkout` command normally expects a branch head, but will also "
"accept an arbitrary commit; for example, you can check out the commit "
"referenced by a tag:"
msgstr ""
"`git checkout` コマンドは通常はブランチヘッドが引数で渡されることを期待してい"
"ますが、 任意のコミットを指定することもできます；例えば、 タグによって参照さ"
"れるコミットをチェックアウトすることができます。"

#. type: delimited block -
#: ../../user-manual.txt:321
#, fuzzy, no-wrap
msgid ""
"$ git checkout v2.6.17\n"
"Note: moving to \"v2.6.17\" which isn't a local branch\n"
"If you want to create a new branch from this checkout, you may do so\n"
"(now or later) by using -b with the checkout command again. Example:\n"
"  git checkout -b <new_branch_name>\n"
"HEAD is now at 427abfa... Linux v2.6.17\n"
msgstr ""
"$ git checkout v2.6.17\n"
"Note: moving to \"v2.6.17\" which isn't a local branch\n"
"If you want to create a new branch from this checkout, you may do so\n"
"(now or later) by using -b with the checkout command again. Example:\n"
"  git checkout -b <new_branch_name>\n"
"HEAD is now at 427abfa... Linux v2.6.17\n"

#. type: Plain text
#: ../../user-manual.txt:325
#, fuzzy
msgid ""
"The HEAD then refers to the SHA-1 of the commit instead of to a branch, and "
"git branch shows that you are no longer on a branch:"
msgstr ""
"この時 HEAD はブランチの代わりにコミットの SHA-1 値を参照しており、 git "
"branch を実行するとブランチにいないことが分かります。"

#. type: delimited block -
#: ../../user-manual.txt:332
#, fuzzy, no-wrap
msgid ""
"$ cat .git/HEAD\n"
"427abfa28afedffadfca9dd8b067eb6d36bac53f\n"
"$ git branch\n"
"* (no branch)\n"
"  master\n"
msgstr ""
"$ cat .git/HEAD\n"
"427abfa28afedffadfca9dd8b067eb6d36bac53f\n"
"$ git branch\n"
"* (no branch)\n"
"  master\n"

#. type: Plain text
#: ../../user-manual.txt:335
#, fuzzy
msgid "In this case we say that the HEAD is \"detached\"."
msgstr "この状態を HEAD が \"切り離されている (detached)\" と言います。"

#. type: Plain text
#: ../../user-manual.txt:339
#, fuzzy, no-wrap
msgid ""
"This is an easy way to check out a particular version without having to\n"
"make up a name for the new branch.   You can still create a new branch\n"
"(or tag) for this version later if you decide to.\n"
msgstr "この方法は、新しいブランチを作成せずに特定のバージョンを チェックアウトする手軽な方法です。 こうした後でも、後からこのバージョンに対して新しいブランチ(またはタグ)を 作成することができます。"

#. type: Title -
#: ../../user-manual.txt:342
#, fuzzy, no-wrap
msgid "Examining branches from a remote repository"
msgstr "リモートリポジトリのブランチの調査"

#. type: Plain text
#: ../../user-manual.txt:349
#, fuzzy
msgid ""
"The \"master\" branch that was created at the time you cloned is a copy of "
"the HEAD in the repository that you cloned from.  That repository may also "
"have had other branches, though, and your local repository keeps branches "
"which track each of those remote branches, which you can view using the \"-r"
"\" option to linkgit:git-branch[1]:"
msgstr ""
"複製(clone)した時に作成される \"master\" ブランチは、 複製元リポジトリのヘッ"
"ドのコピーです。 しかし複製元リポジトリにはそれ以外にもブランチがあるかもしれ"
"ません。 ローカルリポジトリは、リモート(複製元)ブランチのそれぞれを追跡する為"
"の ブランチを持っています。 それらのブランチは \"-r\" オプションを付けて "
"linkgit:git-branch[1] を実行すると 確認できます："

#. type: delimited block -
#: ../../user-manual.txt:360
#, fuzzy, no-wrap
msgid ""
"$ git branch -r\n"
"  origin/HEAD\n"
"  origin/html\n"
"  origin/maint\n"
"  origin/man\n"
"  origin/master\n"
"  origin/next\n"
"  origin/pu\n"
"  origin/todo\n"
msgstr ""
"$ git branch -r\n"
"  origin/HEAD\n"
"  origin/html\n"
"  origin/maint\n"
"  origin/man\n"
"  origin/master\n"
"  origin/next\n"
"  origin/pu\n"
"  origin/todo\n"

#. type: Plain text
#: ../../user-manual.txt:364
#, fuzzy
msgid ""
"You cannot check out these remote-tracking branches, but you can examine "
"them on a branch of your own, just as you would a tag:"
msgstr ""
"それらリモート追跡ブランチを直接チェックアウトすることはできませんが、 自身の"
"ブランチを作成しそこで調べることはできます。"

#. type: delimited block -
#: ../../user-manual.txt:367
#, fuzzy, no-wrap
msgid "$ git checkout -b my-todo-copy origin/todo\n"
msgstr "$ git checkout -b my-todo-copy origin/todo\n"

#. type: Plain text
#: ../../user-manual.txt:371
#, fuzzy
msgid ""
"Note that the name \"origin\" is just the name that git uses by default to "
"refer to the repository that you cloned from."
msgstr ""
"\"origin\" という名前は、複製(clone)したリポジトリを参照する為に git がデフォ"
"ルトで使用する名前にすぎないことに注意してください。"

#. type: Title -
#: ../../user-manual.txt:374
#, fuzzy, no-wrap
msgid "Naming branches, tags, and other references"
msgstr "ブランチ、タグ、その他リファレンスの命名法"

#. type: Plain text
#: ../../user-manual.txt:380
#, fuzzy
msgid ""
"Branches, remote-tracking branches, and tags are all references to commits.  "
"All references are named with a slash-separated path name starting with "
"\"refs\"; the names we've been using so far are actually shorthand:"
msgstr ""
"ブランチ、リモート追跡ブランチ、タグは全てコミットを参照しています。 全ての参"
"照は \"refs\" で始まるスラッシュ区切りのパス名が付けられています； これまで使"
"用してきた名前は実のところ全て略記です。"

#. type: Plain text
#: ../../user-manual.txt:382
#, fuzzy
msgid "The branch \"test\" is short for \"refs/heads/test\"."
msgstr "ブランチ \"test\" は \"refs/heads/test\" の略記です。"

#. type: Plain text
#: ../../user-manual.txt:383
#, fuzzy
msgid "The tag \"v2.6.18\" is short for \"refs/tags/v2.6.18\"."
msgstr "タグ \"v2.6.18\" は \"refs/tags/v2.6.18\" の略記です。"

#. type: Plain text
#: ../../user-manual.txt:384
#, fuzzy
msgid "\"origin/master\" is short for \"refs/remotes/origin/master\"."
msgstr "\"origin/master\" は \"refs/remotes/origin/master\" の略記です。"

#. type: Plain text
#: ../../user-manual.txt:387
#, fuzzy
msgid ""
"The full name is occasionally useful if, for example, there ever exists a "
"tag and a branch with the same name."
msgstr ""
"フルネームは時折役に立つことがあります。例えば、 同じ名前のタグとブランチがあ"
"るような場合です。"

#. type: Plain text
#: ../../user-manual.txt:392
#, fuzzy
msgid ""
"(Newly created refs are actually stored in the .git/refs directory, under "
"the path given by their name.  However, for efficiency reasons they may also "
"be packed together in a single file; see linkgit:git-pack-refs[1])."
msgstr ""
"(新しく作成された参照は .git/refs ディレクトリ内にその参照の 名前で格納されて"
"います。しかし、効率性の理由により、 １つのファイルに纏めて圧縮されることもあ"
"ります；linkgit:git-pack-refs[1] 参照)"

#. type: Plain text
#: ../../user-manual.txt:396
#, fuzzy
msgid ""
"As another useful shortcut, the \"HEAD\" of a repository can be referred to "
"just using the name of that repository.  So, for example, \"origin\" is "
"usually a shortcut for the HEAD branch in the repository \"origin\"."
msgstr ""
"もう一つ役に立つ略記として、あるリポジトリの \"HEAD\" は、単にそのリポジトリ"
"名 を使うだけで参照できるというのがあります。 例えば \"origin\" は通常、リポ"
"ジトリ \"origin\" の HEAD ブランチの略記を表わします。"

#. type: Plain text
#: ../../user-manual.txt:401
#, fuzzy
msgid ""
"For the complete list of paths which git checks for references, and the "
"order it uses to decide which to choose when there are multiple references "
"with the same shorthand name, see the \"SPECIFYING REVISIONS\" section of "
"linkgit:git-rev-parse[1]."
msgstr ""
"参照先として git がチェックするパスの完全なリストと、 同じ略記をもつ複数の参"
"照がある場合の選択規則については linkgit:git-rev-parse[1] の \"SPECIFYING "
"REVISIONS\" の節を 確認してください。"

#. type: Title -
#: ../../user-manual.txt:404
#, fuzzy, no-wrap
msgid "Updating a repository with git fetch"
msgstr "git fetch を用いたリポジトリの更新"

#. type: Plain text
#: ../../user-manual.txt:409
#, fuzzy
msgid ""
"Eventually the developer cloned from will do additional work in her "
"repository, creating new commits and advancing the branches to point at the "
"new commits."
msgstr ""
"複製(clone)元の開発者はいずれ自身のリポジトリに変更を加えたり、 新しいコミッ"
"トを作成したり、新しいコミットを参照したブランチを作成するでしょう。"

#. type: Plain text
#: ../../user-manual.txt:414
#, fuzzy
msgid ""
"The command \"git fetch\", with no arguments, will update all of the remote-"
"tracking branches to the latest version found in her repository.  It will "
"not touch any of your own branches--not even the \"master\" branch that was "
"created for you on clone."
msgstr ""
"\"git fetch\" コマンドは、引数なしの場合、全てのリモート追跡している ブランチ"
"を複製元リポジトリの最新バージョンの状態に更新します。 この動作は、自分自身の"
"ブランチについては何も変更しません。 -- \"master\"ブランチも同じです、それは"
"複製時にあなたの開発用に 作られたものです。"

#. type: Title -
#: ../../user-manual.txt:417
#, fuzzy, no-wrap
msgid "Fetching branches from other repositories"
msgstr "他のリポジトリからのブランチの取得"

#. type: Plain text
#: ../../user-manual.txt:421
#, fuzzy
msgid ""
"You can also track branches from repositories other than the one you cloned "
"from, using linkgit:git-remote[1]:"
msgstr ""
"複製元以外のリポジトリにあるブランチを追跡することもできます。 そうするには "
"linkgit:git-remote[1] を使用します："

#. type: delimited block -
#: ../../user-manual.txt:427
#, fuzzy, no-wrap
msgid ""
"$ git remote add linux-nfs git://linux-nfs.org/pub/nfs-2.6.git\n"
"$ git fetch linux-nfs\n"
"* refs/remotes/linux-nfs/master: storing branch 'master' ...\n"
"  commit: bf81b46\n"
msgstr ""
"$ git remote add linux-nfs git://linux-nfs.org/pub/nfs-2.6.git\n"
"$ git fetch linux-nfs\n"
"* refs/remotes/linux-nfs/master: storing branch 'master' ...\n"
"  commit: bf81b46\n"

#. type: Plain text
#: ../../user-manual.txt:431
#, fuzzy
msgid ""
"New remote-tracking branches will be stored under the shorthand name that "
"you gave \"git remote add\", in this case linux-nfs:"
msgstr ""
"新しいリモート追跡ブランチは \"git remote add\" で指定した 省略名で格納され、"
"上記場合は linux-nfs です："

#. type: delimited block -
#: ../../user-manual.txt:436
#, fuzzy, no-wrap
msgid ""
"$ git branch -r\n"
"linux-nfs/master\n"
"origin/master\n"
msgstr ""
"$ git branch -r\n"
"linux-nfs/master\n"
"origin/master\n"

#. type: Plain text
#: ../../user-manual.txt:440
#, fuzzy
msgid ""
"If you run \"git fetch <remote>\" later, the tracking branches for the named "
"<remote> will be updated."
msgstr ""
"\"git fetch <remote>\" をその後に実行すると、<remote> という名前の 追跡ブラン"
"チが更新されます。"

#. type: Plain text
#: ../../user-manual.txt:443
#, fuzzy
msgid ""
"If you examine the file .git/config, you will see that git has added a new "
"stanza:"
msgstr ""
" .git/config ファイルを見ると、git が新しい節を追加したことを\n"
"確認できます。\n"

#. type: delimited block -
#: ../../user-manual.txt:451
#, fuzzy, no-wrap
msgid ""
"$ cat .git/config\n"
"...\n"
"[remote \"linux-nfs\"]\n"
"\turl = git://linux-nfs.org/pub/nfs-2.6.git\n"
"\tfetch = +refs/heads/*:refs/remotes/linux-nfs/*\n"
"...\n"
msgstr ""
"$ cat .git/config\n"
"...\n"
"[remote \"linux-nfs\"]\n"
"\turl = git://linux-nfs.org/pub/nfs-2.6.git\n"
"\tfetch = +refs/heads/*:refs/remotes/linux-nfs/*\n"
"...\n"

#. type: Plain text
#: ../../user-manual.txt:457
#, fuzzy
msgid ""
"This is what causes git to track the remote's branches; you may modify or "
"delete these configuration options by editing .git/config with a text "
"editor.  (See the \"CONFIGURATION FILE\" section of linkgit:git-config[1] "
"for details.)"
msgstr ""
"これは、git がリモートブランチを追跡する為に作成したものです； テキストエディ"
"タで .git/config を編集し、これらの設定オプションを 変更、削除することもでき"
"ます。 (詳細は linkgit:git-config[1] の \"CONFIGURATION FILE\" を参照してくだ"
"さい)"

#. type: Title =
#: ../../user-manual.txt:460
#, fuzzy, no-wrap
msgid "Exploring git history"
msgstr "Git履歴の探索"

#. type: Plain text
#: ../../user-manual.txt:466
#, fuzzy
msgid ""
"Git is best thought of as a tool for storing the history of a collection of "
"files.  It does this by storing compressed snapshots of the contents of a "
"file hierarchy, together with \"commits\" which show the relationships "
"between these snapshots."
msgstr ""
"git はファイルの集合の履歴を格納するツールとして とても良く考慮されたツールで"
"す。 ファイル階層の中身を圧縮したスナップショットと スナップショット間の関係"
"を表す \"commit\" を格納することで これを実現しています。"

#. type: Plain text
#: ../../user-manual.txt:469
#, fuzzy
msgid ""
"Git provides extremely flexible and fast tools for exploring the history of "
"a project."
msgstr "git は非常に柔軟で高速に動作するプロジェクトの履歴探索ツールです。"

#. type: Plain text
#: ../../user-manual.txt:472
#, fuzzy
msgid ""
"We start with one specialized tool that is useful for finding the commit "
"that introduced a bug into a project."
msgstr ""
"プロジェクトにバグを入れ込んだコミットを見つける為の便利な 特殊ツールの説明か"
"らはじめましょう。"

#. type: Title -
#: ../../user-manual.txt:475
#, fuzzy, no-wrap
msgid "How to use bisect to find a regression"
msgstr "リグレッションを見つける為の bisect の使用方法"

#. type: Plain text
#: ../../user-manual.txt:482
#, fuzzy
msgid ""
"Suppose version 2.6.18 of your project worked, but the version at \"master\" "
"crashes.  Sometimes the best way to find the cause of such a regression is "
"to perform a brute-force search through the project's history to find the "
"particular commit that caused the problem.  The linkgit:git-bisect[1] "
"command can help you do this:"
msgstr ""
"プロジェクトのバージョン 2.6.18 では動作するが、\"master\" ブランチの 最新"
"バージョンではクラッシュするとしましょう。 そのようなリグレッションの原因を探"
"し出す最良の方法は プロジェクトの履歴を総当たりで検索し、問題を引き起こす特定"
"のコミットを見つけることです。 linkgit:git-bisect[1] コマンドはこの作業の手伝"
"いをしてくれます："

#. type: delimited block -
#: ../../user-manual.txt:489
#, fuzzy, no-wrap
msgid ""
"$ git bisect start\n"
"$ git bisect good v2.6.18\n"
"$ git bisect bad master\n"
"Bisecting: 3537 revisions left to test after this\n"
"[65934a9a028b88e83e2b0f8b36618fe503349f8e] BLOCK: Make USB storage depend on SCSI rather than selecting it [try #6]\n"
msgstr ""
"$ git bisect start\n"
"$ git bisect good v2.6.18\n"
"$ git bisect bad master\n"
"Bisecting: 3537 revisions left to test after this\n"
"[65934a9a028b88e83e2b0f8b36618fe503349f8e] BLOCK: Make USB storage depend on SCSI rather than selecting it [try #6]\n"

#. type: Plain text
#: ../../user-manual.txt:496
#, fuzzy
msgid ""
"If you run \"git branch\" at this point, you'll see that git has temporarily "
"moved you in \"(no branch)\". HEAD is now detached from any branch and "
"points directly to a commit (with commit id 65934...) that is reachable from "
"\"master\" but not from v2.6.18. Compile and test it, and see whether it "
"crashes. Assume it does crash. Then:"
msgstr ""
"この時点で \"git branch\" を実行すると、git は一時的に \"(no branch)\" に移動"
"していることが確認できます。 HEADはいまやあらゆるブランチから分離されてお"
"り、 \"master\" からは到達可能だが、v2.6.18 からは到達できない コミット(id "
"が 65934... のコミット)を指しています。 コンパイルとテストをし、クラッシュす"
"るかを確認します。 もしクラッシュするのなら、以下のように："

#. type: delimited block -
#: ../../user-manual.txt:501
#, fuzzy, no-wrap
msgid ""
"$ git bisect bad\n"
"Bisecting: 1769 revisions left to test after this\n"
"[7eff82c8b1511017ae605f0c99ac275a7e21b867] i2c-core: Drop useless bitmaskings\n"
msgstr ""
"$ git bisect bad\n"
"Bisecting: 1769 revisions left to test after this\n"
"[7eff82c8b1511017ae605f0c99ac275a7e21b867] i2c-core: Drop useless bitmaskings\n"

#. type: Plain text
#: ../../user-manual.txt:507
#, fuzzy
msgid ""
"checks out an older version.  Continue like this, telling git at each stage "
"whether the version it gives you is good or bad, and notice that the number "
"of revisions left to test is cut approximately in half each time."
msgstr ""
"として、より古いバージョンを確認します。このように git に各段階でそのバージョ"
"ンが good か bad かを伝える作業を続け、 テストすべきリビジョンの残数は各回で"
"約半分ずつに削られていきます。"

#. type: Plain text
#: ../../user-manual.txt:512
#, fuzzy
msgid ""
"After about 13 tests (in this case), it will output the commit id of the "
"guilty commit.  You can then examine the commit with linkgit:git-show[1], "
"find out who wrote it, and mail them your bug report with the commit id.  "
"Finally, run"
msgstr ""
"(今回の場合では)約13回テストした後、罪を犯したコミットの id を 見つけることが"
"できます。そのコミットに対して linkgit:git-show[1] を実行し、 誰がそのコミッ"
"トを書いたかを見つけ出し、コミットの id を添えて、 バグレポートをメールしま"
"す。最後に、"

#. type: Plain text
#: ../../user-manual.txt:518
#, fuzzy
msgid "to return you to the branch you were on before."
msgstr "を実行し、以前いたブランチに戻ます。"

#. type: Plain text
#: ../../user-manual.txt:524
#, fuzzy
msgid ""
"Note that the version which `git bisect` checks out for you at each point is "
"just a suggestion, and you're free to try a different version if you think "
"it would be a good idea.  For example, occasionally you may land on a commit "
"that broke something unrelated; run"
msgstr ""
"ここで注意すべきことは`git bisect` が各状態でチェックアウトする バージョンが"
"単なる提案にすぎないことです。 違うバージョンをテストしてもかまわないので"
"す。 例えば、関係のない変更をしているコミット上にいるかもしれません； その時"
"は以下を実行してください。"

#. type: Plain text
#: ../../user-manual.txt:532
#, fuzzy
msgid ""
"which will run gitk and label the commit it chose with a marker that says "
"\"bisect\".  Choose a safe-looking commit nearby, note its commit id, and "
"check it out with:"
msgstr ""
"こうすると gitk が起動して、選択されたコミットに \"bisect\" という マーカーを"
"つけます。近くの安全そうなコミットを探し、コミットIDをメモして 次のコマンドで"
"チェックアウトします。"

#. type: delimited block -
#: ../../user-manual.txt:535
#, fuzzy, no-wrap
msgid "$ git reset --hard fb47ddb2db...\n"
msgstr "$ git reset --hard fb47ddb2db...\n"

#. type: Plain text
#: ../../user-manual.txt:539
#, fuzzy
msgid ""
"then test, run \"bisect good\" or \"bisect bad\" as appropriate, and "
"continue."
msgstr ""
"そしてテストし、\"bisect good\" または \"bisect bad\" の適切な方を実行し、 作"
"業を続けます。"

#. type: Plain text
#: ../../user-manual.txt:543
#, fuzzy
msgid ""
"Instead of \"git bisect visualize\" and then \"git reset --hard fb47ddb2db..."
"\", you might just want to tell git that you want to skip the current commit:"
msgstr ""
"\"git bisect visualize\"を実行して\"git reset --hard fb47ddb2db...\" を実行す"
"るかわりに、単に現在のコミットをスキップしたいかもしれません。 その場合は以下"
"を実行してください。"

#. type: delimited block -
#: ../../user-manual.txt:546
#, fuzzy, no-wrap
msgid "$ git bisect skip\n"
msgstr "$ git bisect skip\n"

#. type: Plain text
#: ../../user-manual.txt:550
#, fuzzy
msgid ""
"In this case, though, git may not eventually be able to tell the first bad "
"one between some first skipped commits and a later bad commit."
msgstr ""
"しかしこの場合にgitは結果的いくつかの最初のスキップされたコミットと その後の"
"悪いコミットの間にある最初の悪いコミットが わからなくなる可能性があります。"

#. type: Plain text
#: ../../user-manual.txt:555
#, fuzzy
msgid ""
"There are also ways to automate the bisecting process if you have a test "
"script that can tell a good from a bad commit. See linkgit:git-bisect[1] for "
"more information about this and other \"git bisect\" features."
msgstr ""
"もし良いコミットと悪いコミットを判断することが可能な テストスクリプトがあるな"
"ら、bisect作業の自動化には いくつかの方法があります。 詳細はlinkgit:git-"
"bisect[1]をご覧ください。"

#. type: Title -
#: ../../user-manual.txt:558
#, fuzzy, no-wrap
msgid "Naming commits"
msgstr "コミットの指定方法"

#. type: Plain text
#: ../../user-manual.txt:561
#, fuzzy
msgid "We have seen several ways of naming commits already:"
msgstr "既にコミットの指定方法をいくつか紹介してきました："

#. type: Plain text
#: ../../user-manual.txt:563
#, fuzzy
msgid "40-hexdigit object name"
msgstr "40桁の16進数からなるオブジェクト名"

#. type: Plain text
#: ../../user-manual.txt:565
#, fuzzy
msgid "branch name: refers to the commit at the head of the given branch"
msgstr "ブランチ名： 指定したブランチの head を参照します"

#. type: Plain text
#: ../../user-manual.txt:568
#, fuzzy
msgid ""
"tag name: refers to the commit pointed to by the given tag (we've seen "
"branches and tags are special cases of <<how-git-stores-references,"
"references>>)."
msgstr ""
"タグ名： 指定したタグが指し示すコミットを参照します (<<how-git-stores-"
"references,references>> でブランチとタグの特殊な場合について見てきました)"

#. type: Plain text
#: ../../user-manual.txt:569
#, fuzzy
msgid "HEAD: refers to the head of the current branch"
msgstr "HEAD：現在のブランチの head を参照します"

#. type: Plain text
#: ../../user-manual.txt:573
#, fuzzy
msgid ""
"There are many more; see the \"SPECIFYING REVISIONS\" section of the linkgit:"
"git-rev-parse[1] man page for the complete list of ways to name revisions.  "
"Some examples:"
msgstr ""
"他にもたくさんあります；リビジョンの呼び方の完全なリストは linkgit:git-rev-"
"parse[1] の man ページにある \"SPECIFYING REVISIONS\" の節で 確認できます。"

#. type: delimited block -
#: ../../user-manual.txt:580
#, fuzzy, no-wrap
msgid ""
"$ git show fb47ddb2 # the first few characters of the object name\n"
"\t\t    # are usually enough to specify it uniquely\n"
"$ git show HEAD^    # the parent of the HEAD commit\n"
"$ git show HEAD^^   # the grandparent\n"
"$ git show HEAD~4   # the great-great-grandparent\n"
msgstr ""
"$ git show fb47ddb2 # オブジェクト名の先頭の数文字は\n"
"\t\t    # そのコミットを特定するのに通常は十分です。\n"
"$ git show HEAD^    # HEAD コミットの親\n"
"$ git show HEAD^^   # 祖父母\n"
"$ git show HEAD~4   # 祖父母の祖父母\n"

#. type: Plain text
#: ../../user-manual.txt:585
#, fuzzy
msgid ""
"Recall that merge commits may have more than one parent; by default, ^ and ~ "
"follow the first parent listed in the commit, but you can also choose:"
msgstr ""
"マージコミットは１つ以上の親を持ちます；デフォルトでは ^ と ~ はコミットリス"
"トの１つ目の親を指しますが、 次のように指定することもできます；"

#. type: delimited block -
#: ../../user-manual.txt:589
#, fuzzy, no-wrap
msgid ""
"$ git show HEAD^1   # show the first parent of HEAD\n"
"$ git show HEAD^2   # show the second parent of HEAD\n"
msgstr ""
"$ git show HEAD^1   # HEAD の１つ目の親\n"
"$ git show HEAD^2   # HEAD の２つ目の親\n"

#. type: Plain text
#: ../../user-manual.txt:593
#, fuzzy
msgid "In addition to HEAD, there are several other special names for commits:"
msgstr "HEAD の他にも、コミットを指す特殊な名前があります："

#. type: Plain text
#: ../../user-manual.txt:597
#, fuzzy
msgid ""
"Merges (to be discussed later), as well as operations such as `git reset`, "
"which change the currently checked-out commit, generally set ORIG_HEAD to "
"the value HEAD had before the current operation."
msgstr ""
"(後に説明する)マージは、`git reset` のような操作と同じように、 現在チェックア"
"ウトしているコミットを変更し、 一般的には ORIG_HEAD に現在の操作以前にもって"
"いた HEAD の値をセットします。"

#. type: Plain text
#: ../../user-manual.txt:601
#, fuzzy
msgid ""
"The `git fetch` operation always stores the head of the last fetched branch "
"in FETCH_HEAD.  For example, if you run `git fetch` without specifying a "
"local branch as the target of the operation"
msgstr ""
"`git fetch` の操作は、常に最後にフェッチしたブランチのヘッドを FETCH_HEAD に "
"格納します。例えば、操作対象であるローカルブランチを指定せずに `git fetch` "
"を 実行した場合、"

#. type: delimited block -
#: ../../user-manual.txt:604
#, fuzzy, no-wrap
msgid "$ git fetch git://example.com/proj.git theirbranch\n"
msgstr "$ git fetch git://example.com/proj.git theirbranch\n"

#. type: Plain text
#: ../../user-manual.txt:607
#, fuzzy
msgid "the fetched commits will still be available from FETCH_HEAD."
msgstr "フェッチされるコミットは FETCH_HEAD 取得されます。"

#. type: Plain text
#: ../../user-manual.txt:611
#, fuzzy
msgid ""
"When we discuss merges we'll also see the special name MERGE_HEAD, which "
"refers to the other branch that we're merging in to the current branch."
msgstr ""
"マージについて議論するとき、MERGE_HEAD という特別な名前を目にします。 これ"
"は、現在のブランチにマージしようとしているもう一方のブランチを 参照していま"
"す。"

#. type: Plain text
#: ../../user-manual.txt:615
#, fuzzy
msgid ""
"The linkgit:git-rev-parse[1] command is a low-level command that is "
"occasionally useful for translating some name for a commit to the object "
"name for that commit:"
msgstr ""
"linkgit:git-rev-parse[1] コマンドは、低レベルのコマンドであり コミットに対す"
"る名前をコミットのオブジェクト名に変換するのに役立ちます。"

#. type: delimited block -
#: ../../user-manual.txt:619
#, fuzzy, no-wrap
msgid ""
"$ git rev-parse origin\n"
"e05db0fd4f31dde7005f075a84f96b360d05984b\n"
msgstr ""
"$ git rev-parse origin\n"
"e05db0fd4f31dde7005f075a84f96b360d05984b\n"

#. type: Title -
#: ../../user-manual.txt:623
#, fuzzy, no-wrap
msgid "Creating tags"
msgstr "タグの作成方法"

#. type: Plain text
#: ../../user-manual.txt:627
#, fuzzy
msgid "We can also create a tag to refer to a particular commit; after running"
msgstr ""
"特定のコミットを参照する為にタグを作成することができます； 以下の操作を実行す"
"ると、"

#. type: delimited block -
#: ../../user-manual.txt:630
#, fuzzy, no-wrap
msgid "$ git tag stable-1 1b2e1d63ff\n"
msgstr "$ git tag stable-1 1b2e1d63ff\n"

#. type: Plain text
#: ../../user-manual.txt:633
#, fuzzy
msgid "You can use stable-1 to refer to the commit 1b2e1d63ff."
msgstr ""
"stable-1 という名前で 1b2e1d63ff のコミットを参照できるようになります。"

#. type: Plain text
#: ../../user-manual.txt:638
#, fuzzy
msgid ""
"This creates a \"lightweight\" tag.  If you would also like to include a "
"comment with the tag, and possibly sign it cryptographically, then you "
"should create a tag object instead; see the linkgit:git-tag[1] man page for "
"details."
msgstr ""
"これは \"軽量\" タグと呼ばれるものです。 タグにコメントを含めたい場合や、暗号"
"化して署名したい場合には、 その代わりにタグオブジェクトを作成することができま"
"す；詳細は linkgit:git-tag[1] の man ページを参照してください。"

#. type: Title -
#: ../../user-manual.txt:641
#, fuzzy, no-wrap
msgid "Browsing revisions"
msgstr "リビジョンの閲覧方法"

#. type: Plain text
#: ../../user-manual.txt:646
#, fuzzy
msgid ""
"The linkgit:git-log[1] command can show lists of commits.  On its own, it "
"shows all commits reachable from the parent commit; but you can also make "
"more specific requests:"
msgstr ""
"linkgit:git-log[1] コマンドはコミットの一覧を表示します。 現在のブランチ上に"
"ある親コミットから到達可能な全てのコミットを表示します。； しかし、さらに特定"
"のリクエストをすることもできます："

#. type: delimited block -
#: ../../user-manual.txt:658
#, fuzzy, no-wrap
msgid ""
"$ git log v2.5..\t# commits since (not reachable from) v2.5\n"
"$ git log test..master\t# commits reachable from master but not test\n"
"$ git log master..test\t# ...reachable from test but not master\n"
"$ git log master...test\t# ...reachable from either test or master,\n"
"\t\t\t#    but not both\n"
"$ git log --since=\"2 weeks ago\" # commits from the last 2 weeks\n"
"$ git log Makefile      # commits which modify Makefile\n"
"$ git log fs/\t\t# ... which modify any file under fs/\n"
"$ git log -S'foo()'\t# commits which add or remove any file data\n"
"\t\t\t# matching the string 'foo()'\n"
msgstr ""
"$ git log v2.5..\t# v2.5以降のコミット(v2.5から到達不能なコミット)\n"
"$ git log test..master\t# master から到達可能だが、test からは到達可能でないコミット\n"
"$ git log master..test\t# test から到達可能だが、master からは到達可能でないコミット\n"
"$ git log master...test\t# test または master から到達可能だが、\n"
"\t\t\t# 両方からは到達可能でない...\n"
"$ git log --since=\"2 weeks ago\" # 最近２週間のコミット\n"
"$ git log Makefile      # Makefile を修正しているコミット\n"
"$ git log fs/\t\t# fs/ 配下のファイルを修正している...\n"
"$ git log -S'foo()'\t# 文字列 'foo()' に一致する全てのファイルを\n"
"\t\t\t# 追加または削除しているコミット\n"

#. type: Plain text
#: ../../user-manual.txt:662
#, fuzzy
msgid ""
"And of course you can combine all of these; the following finds commits "
"since v2.5 which touch the Makefile or any file under fs:"
msgstr ""
"そしてもちろん、これら全てを組み合わせることもできます； 以下は v2.5 以降のコ"
"ミットで、Makefile 又は fs 配下のファイルを変更している コミットを検索しま"
"す。"

#. type: delimited block -
#: ../../user-manual.txt:665
#, fuzzy, no-wrap
msgid "$ git log v2.5.. Makefile fs/\n"
msgstr "$ git log v2.5.. Makefile fs/\n"

#. type: Plain text
#: ../../user-manual.txt:668
#, fuzzy
msgid "You can also ask git log to show patches:"
msgstr "git log を使用し、パッチを表示することもできます："

#. type: Plain text
#: ../../user-manual.txt:675
#, fuzzy
msgid ""
"See the \"--pretty\" option in the linkgit:git-log[1] man page for more "
"display options."
msgstr ""
"他の表示オプションについては linkgit:git-log[1] の man ページにある \"--"
"pretty\" オプション を参照してください。"

#. type: Plain text
#: ../../user-manual.txt:680
#, fuzzy
msgid ""
"Note that git log starts with the most recent commit and works backwards "
"through the parents; however, since git history can contain multiple "
"independent lines of development, the particular order that commits are "
"listed in may be somewhat arbitrary."
msgstr ""
"git log は最新のコミットから開始し、親を辿って後方に検索します； しかし、git "
"の履歴は複数の独立した開発ラインを含むことができる為、 一覧表示されるコミット"
"の順番はいくらか任意になります。"

#. type: Title -
#: ../../user-manual.txt:683
#, fuzzy, no-wrap
msgid "Generating diffs"
msgstr "差分の生成方法"

#. type: Plain text
#: ../../user-manual.txt:687
#, fuzzy
msgid ""
"You can generate diffs between any two versions using linkgit:git-diff[1]:"
msgstr ""
"linkgit:git-diff[1] を使用すると２つのバージョン間の差分を 生成することができ"
"ます："

#. type: delimited block -
#: ../../user-manual.txt:690
#, fuzzy, no-wrap
msgid "$ git diff master..test\n"
msgstr "$ git diff master..test\n"

#. type: Plain text
#: ../../user-manual.txt:695
#, fuzzy
msgid ""
"That will produce the diff between the tips of the two branches.  If you'd "
"prefer to find the diff from their common ancestor to test, you can use "
"three dots instead of two:"
msgstr ""
"これは２つのブランチの先端の間の差分を表示します。 ２つのブランチの共通の祖先"
"から test までの差分を表示したい場合は ドットを２つではなく３つとし、次のよう"
"にします："

#. type: delimited block -
#: ../../user-manual.txt:698
#, fuzzy, no-wrap
msgid "$ git diff master...test\n"
msgstr "$ git diff master...test\n"

#. type: Plain text
#: ../../user-manual.txt:702
#, fuzzy
msgid ""
"Sometimes what you want instead is a set of patches; for this you can use "
"linkgit:git-format-patch[1]:"
msgstr ""
"時には差分ではなく各パッチの集合が必要な場合もあります；その際には linkgit:"
"git-format-patch[1]: を使用します："

#. type: delimited block -
#: ../../user-manual.txt:705
#, fuzzy, no-wrap
msgid "$ git format-patch master..test\n"
msgstr "$ git format-patch master..test\n"

#. type: Plain text
#: ../../user-manual.txt:709
#, fuzzy
msgid ""
"will generate a file with a patch for each commit reachable from test but "
"not from master."
msgstr ""
"このようにすると、test から到達可能だが、master からは到達できない各コミット"
"の パッチを含むファイルを生成できます。"

#. type: Title -
#: ../../user-manual.txt:712
#, fuzzy, no-wrap
msgid "Viewing old file versions"
msgstr "古いファイルバージョンの参照"

#. type: Plain text
#: ../../user-manual.txt:718
#, fuzzy
msgid ""
"You can always view an old version of a file by just checking out the "
"correct revision first.  But sometimes it is more convenient to be able to "
"view an old version of a single file without checking anything out; this "
"command does that:"
msgstr ""
"特定のリビジョンをチェックアウトすることで、ファイルの古いバージョンを表示さ"
"せる ことができます。しかし時にはある１つのファイルの古いバージョンを チェッ"
"クアウトせずに表示できると便利です； 次のコマンドでそれができます："

#. type: delimited block -
#: ../../user-manual.txt:721
#, fuzzy, no-wrap
msgid "$ git show v2.5:fs/locks.c\n"
msgstr "$ git show v2.5:fs/locks.c\n"

#. type: Plain text
#: ../../user-manual.txt:725
#, fuzzy
msgid ""
"Before the colon may be anything that names a commit, and after it may be "
"any path to a file tracked by git."
msgstr ""
"コロン(:) の前はコミットを指す任意の名前で、その後ろは git が追跡しているファ"
"イルの任意のパスです。"

#. type: Title ~
#: ../../user-manual.txt:732
#, fuzzy, no-wrap
msgid "Counting the number of commits on a branch"
msgstr "ブランチ上のコミット数のカウント"

#. type: Plain text
#: ../../user-manual.txt:736
#, fuzzy
msgid ""
"Suppose you want to know how many commits you've made on \"mybranch\" since "
"it diverged from \"origin\":"
msgstr ""
"\"origin\" から分岐した以降に \"mybranch\" 上で行ったコミットの数を知りたい "
"とします："

#. type: delimited block -
#: ../../user-manual.txt:739
#, fuzzy, no-wrap
msgid "$ git log --pretty=oneline origin..mybranch | wc -l\n"
msgstr "$ git log --pretty=oneline origin..mybranch | wc -l\n"

#. type: Plain text
#: ../../user-manual.txt:744
#, fuzzy
msgid ""
"Alternatively, you may often see this sort of thing done with the lower-"
"level command linkgit:git-rev-list[1], which just lists the SHA-1's of all "
"the given commits:"
msgstr ""
"あるいは、下位レベルのコマンド linkgit:git-rev-list[1] を使用し、 指定したコ"
"ミットすべての SHA-1 をリスト表示することで行うこともできます："

#. type: delimited block -
#: ../../user-manual.txt:747
#, fuzzy, no-wrap
msgid "$ git rev-list origin..mybranch | wc -l\n"
msgstr "$ git rev-list origin..mybranch | wc -l\n"

#. type: Title ~
#: ../../user-manual.txt:751
#, fuzzy, no-wrap
msgid "Check whether two branches point at the same history"
msgstr "２つのブランチが同じ履歴点にあるかの確認"

#. type: Plain text
#: ../../user-manual.txt:755
#, fuzzy
msgid ""
"Suppose you want to check whether two branches point at the same point in "
"history."
msgstr "２つのブランチが同じ履歴点にいるかどうかを確認したいとします。"

#. type: delimited block -
#: ../../user-manual.txt:758
#, fuzzy, no-wrap
msgid "$ git diff origin..master\n"
msgstr "$ git diff origin..master\n"

#. type: Plain text
#: ../../user-manual.txt:764
#, fuzzy
msgid ""
"will tell you whether the contents of the project are the same at the two "
"branches; in theory, however, it's possible that the same project contents "
"could have been arrived at by two different historical routes.  You could "
"compare the object names:"
msgstr ""
"この操作により、プロジェクトの中身が２つのブランチで同じであるか どうかを確認"
"できます；しかし、理論的には同じプロジェクト内容が ２つの異なる履歴ルートに"
"よって作られることもありえます。 (訳注：コミットIDは違うが中身が一緒の場合も"
"ありえる)  従って、オブジェクト名を比較すべきです："

#. type: delimited block -
#: ../../user-manual.txt:770
#, fuzzy, no-wrap
msgid ""
"$ git rev-list origin\n"
"e05db0fd4f31dde7005f075a84f96b360d05984b\n"
"$ git rev-list master\n"
"e05db0fd4f31dde7005f075a84f96b360d05984b\n"
msgstr ""
"$ git rev-list origin\n"
"e05db0fd4f31dde7005f075a84f96b360d05984b\n"
"$ git rev-list master\n"
"e05db0fd4f31dde7005f075a84f96b360d05984b\n"

#. type: Plain text
#: ../../user-manual.txt:775
#, fuzzy
msgid ""
"Or you could recall that the ... operator selects all commits contained "
"reachable from either one reference or the other but not both: so"
msgstr ""
"あるいは、\"...\" のオペレータを使用し、一方からのみ到達可能な 全てのコミット"
"を表示してみることです：つまり、"

#. type: delimited block -
#: ../../user-manual.txt:778
#, fuzzy, no-wrap
msgid "$ git log origin...master\n"
msgstr "$ git log origin...master\n"

#. type: Plain text
#: ../../user-manual.txt:781
#, fuzzy
msgid "will return no commits when the two branches are equal."
msgstr "を行い、２つのブランチが等しい時は、コミットが全く表示されません。"

#. type: Title ~
#: ../../user-manual.txt:784
#, fuzzy, no-wrap
msgid "Find first tagged version including a given fix"
msgstr "与えられた fix を含む最初にタグ付けしたバージョンを探す"

#. type: Plain text
#: ../../user-manual.txt:789
#, fuzzy
msgid ""
"Suppose you know that the commit e05db0fd fixed a certain problem.  You'd "
"like to find the earliest tagged release that contains that fix."
msgstr ""
"e05db0fd がある問題を解決したコミットであるとし、 その解決を含む最も早いタグ"
"付けされたリリースを探したいとします。"

#. type: Plain text
#: ../../user-manual.txt:793
#, fuzzy
msgid ""
"Of course, there may be more than one answer--if the history branched after "
"commit e05db0fd, then there could be multiple \"earliest\" tagged releases."
msgstr ""
"もちろん、その答えは１つ以上あります--コミット e05db0fd 以降に 履歴が分岐して"
"いるなら、複数の \"最も早い\" タグ付けされたリリースが存在します。"

#. type: Plain text
#: ../../user-manual.txt:795
#, fuzzy
msgid "You could just visually inspect the commits since e05db0fd:"
msgstr "e05db0fd 以降のコミットを視覚的に調査することで行えます："

#. type: delimited block -
#: ../../user-manual.txt:798
#, fuzzy, no-wrap
msgid "$ gitk e05db0fd..\n"
msgstr "$ gitk e05db0fd..\n"

#. type: Plain text
#: ../../user-manual.txt:803
#, fuzzy
msgid ""
"Or you can use linkgit:git-name-rev[1], which will give the commit a name "
"based on any tag it finds pointing to one of the commit's descendants:"
msgstr ""
"あるいは linkgit:git-name-rev[1] を使用し、あるタグに基づいた そのコミットの"
"子孫の１つを指し示す名前を表示することができます： (訳注：訳が不正確かな)"

#. type: delimited block -
#: ../../user-manual.txt:807
#, fuzzy, no-wrap
msgid ""
"$ git name-rev --tags e05db0fd\n"
"e05db0fd tags/v1.5.0-rc1^0~23\n"
msgstr ""
"$ git name-rev --tags e05db0fd\n"
"e05db0fd tags/v1.5.0-rc1^0~23\n"

#. type: Plain text
#: ../../user-manual.txt:811
#, fuzzy
msgid ""
"The linkgit:git-describe[1] command does the opposite, naming the revision "
"using a tag on which the given commit is based:"
msgstr ""
"linkgit:git-describe[1] コマンドはこれとは反対のことをします。 指定したコミッ"
"トのベースになるタグ名を使用してそのリビジョンの名前を 表示します。"

#. type: delimited block -
#: ../../user-manual.txt:815
#, fuzzy, no-wrap
msgid ""
"$ git describe e05db0fd\n"
"v1.5.0-rc0-260-ge05db0f\n"
msgstr ""
"$ git describe e05db0fd\n"
"v1.5.0-rc0-260-ge05db0f\n"

#. type: Plain text
#: ../../user-manual.txt:819
#, fuzzy
msgid ""
"but that may sometimes help you guess which tags might come after the given "
"commit."
msgstr ""
"しかし、それは時にはどのタグが指定したコミットの後に現れるかを 推測する手助け"
"になります。"

#. type: Plain text
#: ../../user-manual.txt:822
#, fuzzy
msgid ""
"If you just want to verify whether a given tagged version contains a given "
"commit, you could use linkgit:git-merge-base[1]:"
msgstr ""
"指定したタグ付けされたバージョンが特定のコミットを含むかどうかを 確認したい場"
"合は、linkgit:git-merge-base[1] を使用します："

#. type: delimited block -
#: ../../user-manual.txt:826
#, fuzzy, no-wrap
msgid ""
"$ git merge-base e05db0fd v1.5.0-rc1\n"
"e05db0fd4f31dde7005f075a84f96b360d05984b\n"
msgstr ""
"$ git merge-base e05db0fd v1.5.0-rc1\n"
"e05db0fd4f31dde7005f075a84f96b360d05984b\n"

#. type: Plain text
#: ../../user-manual.txt:832
#, fuzzy
msgid ""
"The merge-base command finds a common ancestor of the given commits, and "
"always returns one or the other in the case where one is a descendant of the "
"other; so the above output shows that e05db0fd actually is an ancestor of "
"v1.5.0-rc1."
msgstr ""
"merge-base コマンドは指定したコミットの共通の祖先を検索し、 一方が他方の子孫"
"である場合にはそのどちらかを表示します； 従って上記出力は e05db0fd が実際に "
"v1.5.0-rc1 の祖先であることを 示しています。"

#. type: Plain text
#: ../../user-manual.txt:834
#, fuzzy
msgid "Alternatively, note that"
msgstr "代わりに、"

#. type: delimited block -
#: ../../user-manual.txt:837
#, fuzzy, no-wrap
msgid "$ git log v1.5.0-rc1..e05db0fd\n"
msgstr "$ git log v1.5.0-rc1..e05db0fd\n"

#. type: Plain text
#: ../../user-manual.txt:841
#, fuzzy
msgid ""
"will produce empty output if and only if v1.5.0-rc1 includes e05db0fd, "
"because it outputs only commits that are not reachable from v1.5.0-rc1."
msgstr ""
"とすると、v1.5.0-rc1 が e05db0fd を含んでいる場合に限り何も出力をしません、 "
"何故なら v1.5.0-rc1 から到達できないコミットだけが表示されるからです。"

#. type: Plain text
#: ../../user-manual.txt:846
#, fuzzy
msgid ""
"As yet another alternative, the linkgit:git-show-branch[1] command lists the "
"commits reachable from its arguments with a display on the left-hand side "
"that indicates which arguments that commit is reachable from.  So, you can "
"run something like"
msgstr ""
"As yet another alternative, the linkgit:git-show-branch[1] command lists the "
"commits reachable from its arguments with a display on the left-hand side "
"that indicates which arguments that commit is reachable from.  So, you can "
"run something like (訳注：訳せないので、原文のまま載せます)"

#. type: delimited block -
#: ../../user-manual.txt:855
#, fuzzy, no-wrap
msgid ""
"$ git show-branch e05db0fd v1.5.0-rc0 v1.5.0-rc1 v1.5.0-rc2\n"
"! [e05db0fd] Fix warnings in sha1_file.c - use C99 printf format if\n"
"available\n"
" ! [v1.5.0-rc0] GIT v1.5.0 preview\n"
"  ! [v1.5.0-rc1] GIT v1.5.0-rc1\n"
"   ! [v1.5.0-rc2] GIT v1.5.0-rc2\n"
"...\n"
msgstr ""
"$ git show-branch e05db0fd v1.5.0-rc0 v1.5.0-rc1 v1.5.0-rc2\n"
"! [e05db0fd] Fix warnings in sha1_file.c - use C99 printf format if\n"
"available\n"
" ! [v1.5.0-rc0] GIT v1.5.0 preview\n"
"  ! [v1.5.0-rc1] GIT v1.5.0-rc1\n"
"   ! [v1.5.0-rc2] GIT v1.5.0-rc2\n"
"...\n"

#. type: Plain text
#: ../../user-manual.txt:858
#, fuzzy
msgid "then search for a line that looks like"
msgstr "then search for a line that looks like"

#. type: delimited block -
#: ../../user-manual.txt:862
#, fuzzy, no-wrap
msgid ""
"+ ++ [e05db0fd] Fix warnings in sha1_file.c - use C99 printf format if\n"
"available\n"
msgstr ""
"+ ++ [e05db0fd] Fix warnings in sha1_file.c - use C99 printf format if\n"
"available\n"

#. type: Plain text
#: ../../user-manual.txt:866
#, fuzzy
msgid ""
"Which shows that e05db0fd is reachable from itself, from v1.5.0-rc1, and "
"from v1.5.0-rc2, but not from v1.5.0-rc0."
msgstr ""
"Which shows that e05db0fd is reachable from itself, from v1.5.0-rc1, and "
"from v1.5.0-rc2, but not from v1.5.0-rc0."

#. type: Title ~
#: ../../user-manual.txt:869
#, fuzzy, no-wrap
msgid "Showing commits unique to a given branch"
msgstr "指定したブランチにだけ存在するコミットを表示する"

#. type: Plain text
#: ../../user-manual.txt:873
#, fuzzy
msgid ""
"Suppose you would like to see all the commits reachable from the branch head "
"named \"master\" but not from any other head in your repository."
msgstr ""
"\"master\" という名前のブランチヘッドから到達可能だが自分のリポジトリ上の 他"
"のヘッドからは到達できないコミットを全て参照したいとします。"

#. type: Plain text
#: ../../user-manual.txt:876
#, fuzzy
msgid ""
"We can list all the heads in this repository with linkgit:git-show-ref[1]:"
msgstr ""
"linkgit:git-show-ref[1] を使用するとこのリポジトリの全てのヘッドを 一覧表示で"
"きます："

#. type: delimited block -
#: ../../user-manual.txt:884
#, fuzzy, no-wrap
msgid ""
"$ git show-ref --heads\n"
"bf62196b5e363d73353a9dcf094c59595f3153b7 refs/heads/core-tutorial\n"
"db768d5504c1bb46f63ee9d6e1772bd047e05bf9 refs/heads/maint\n"
"a07157ac624b2524a059a3414e99f6f44bebc1e7 refs/heads/master\n"
"24dbc180ea14dc1aebe09f14c8ecf32010690627 refs/heads/tutorial-2\n"
"1e87486ae06626c2f31eaa63d26fc0fd646c8af2 refs/heads/tutorial-fixes\n"
msgstr ""
"$ git show-ref --heads\n"
"bf62196b5e363d73353a9dcf094c59595f3153b7 refs/heads/core-tutorial\n"
"db768d5504c1bb46f63ee9d6e1772bd047e05bf9 refs/heads/maint\n"
"a07157ac624b2524a059a3414e99f6f44bebc1e7 refs/heads/master\n"
"24dbc180ea14dc1aebe09f14c8ecf32010690627 refs/heads/tutorial-2\n"
"1e87486ae06626c2f31eaa63d26fc0fd646c8af2 refs/heads/tutorial-fixes\n"

#. type: Plain text
#: ../../user-manual.txt:888
#, fuzzy
msgid ""
"We can get just the branch-head names, and remove \"master\", with the help "
"of the standard utilities cut and grep:"
msgstr ""
"ブランチヘッドの名前を取得し、\"master\" の行を削除しすることができます。 標"
"準ユーティリティである cut と grep の助けを使用して："

#. type: delimited block -
#: ../../user-manual.txt:895
#, fuzzy, no-wrap
msgid ""
"$ git show-ref --heads | cut -d' ' -f2 | grep -v '^refs/heads/master'\n"
"refs/heads/core-tutorial\n"
"refs/heads/maint\n"
"refs/heads/tutorial-2\n"
"refs/heads/tutorial-fixes\n"
msgstr ""
"$ git show-ref --heads | cut -d' ' -f2 | grep -v '^refs/heads/master'\n"
"refs/heads/core-tutorial\n"
"refs/heads/maint\n"
"refs/heads/tutorial-2\n"
"refs/heads/tutorial-fixes\n"

#. type: Plain text
#: ../../user-manual.txt:899
#, fuzzy
msgid ""
"And then we can ask to see all the commits reachable from master but not "
"from these other heads:"
msgstr ""
"そして、master から到達可能だがそれ以外のヘッドからは到達できない 全てのコ"
"ミットをたずねることができます："

#. type: delimited block -
#: ../../user-manual.txt:903
#, fuzzy, no-wrap
msgid ""
"$ gitk master --not $( git show-ref --heads | cut -d' ' -f2 |\n"
"\t\t\t\tgrep -v '^refs/heads/master' )\n"
msgstr ""
"$ gitk master --not $( git show-ref --heads | cut -d' ' -f2 |\n"
"\t\t\t\tgrep -v '^refs/heads/master' )\n"

#. type: Plain text
#: ../../user-manual.txt:907
#, fuzzy
msgid ""
"Obviously, endless variations are possible; for example, to see all commits "
"reachable from some head but not from any tag in the repository:"
msgstr ""
"明らかに、絶え間ない変形もありえます；例えば、いくつかのヘッドからは到達可能"
"だが、 リポジトリ内のどのタグからも到達できないコミットを全て表示するには："

#. type: delimited block -
#: ../../user-manual.txt:910
#, fuzzy, no-wrap
msgid "$ gitk $( git show-ref --heads ) --not  $( git show-ref --tags )\n"
msgstr "$ gitk $( git show-ref --heads ) --not  $( git show-ref --tags )\n"

#. type: Plain text
#: ../../user-manual.txt:914
#, fuzzy
msgid ""
"(See linkgit:git-rev-parse[1] for explanations of commit-selecting syntax "
"such as `--not`.)"
msgstr ""
"(`--not` のようなコミットを選択する構文の説明は linkgit:git-rev-parse[1] を参"
"照してください)"

#. type: Title ~
#: ../../user-manual.txt:917
#, fuzzy, no-wrap
msgid "Creating a changelog and tarball for a software release"
msgstr "チェンジログとソフトウェアリリース用の tarball を作成する"

#. type: Plain text
#: ../../user-manual.txt:921
#, fuzzy
msgid ""
"The linkgit:git-archive[1] command can create a tar or zip archive from any "
"version of a project; for example:"
msgstr ""
"linkgit:git-archive[1] コマンドはどのプロジェクトのバージョンからも tar 又は "
"zip アーカイブを作成できます；例えば："

#. type: delimited block -
#: ../../user-manual.txt:924
#, fuzzy, no-wrap
msgid "$ git archive --format=tar --prefix=project/ HEAD | gzip >latest.tar.gz\n"
msgstr "$ git archive --format=tar --prefix=project/ HEAD | gzip >latest.tar.gz\n"

#. type: Plain text
#: ../../user-manual.txt:928
#, fuzzy
msgid ""
"will use HEAD to produce a tar archive in which each filename is preceded by "
"\"project/\"."
msgstr ""
"これは HEAD を使用し、各ファイルが \"project/\" が先行する tar アーカイブを "
"生成します。"

#. type: Plain text
#: ../../user-manual.txt:932
#, fuzzy
msgid ""
"If you're releasing a new version of a software project, you may want to "
"simultaneously make a changelog to include in the release announcement."
msgstr ""
"ソフトウェアプロジェクトの新しいバージョンをリリースする場合、 リリースアナウ"
"ンスを含める為、チェンジログを同時に作成したいかもしれません。"

#. type: Plain text
#: ../../user-manual.txt:935
#, fuzzy
msgid ""
"Linus Torvalds, for example, makes new kernel releases by tagging them, then "
"running:"
msgstr ""
"Linux Torvalds は例えば、それらにタグを付け、以下を実行することで 新しいカー"
"ネルリリースを作ります："

#. type: delimited block -
#: ../../user-manual.txt:938
#, fuzzy, no-wrap
msgid "$ release-script 2.6.12 2.6.13-rc6 2.6.13-rc7\n"
msgstr "$ release-script 2.6.12 2.6.13-rc6 2.6.13-rc7\n"

#. type: Plain text
#: ../../user-manual.txt:941
#, fuzzy
msgid "where release-script is a shell script that looks like:"
msgstr "ここで、release-script はシェルスクリプトで、以下のような内容です："

#. type: delimited block -
#: ../../user-manual.txt:953
#, fuzzy, no-wrap
msgid ""
"#!/bin/sh\n"
"stable=\"$1\"\n"
"last=\"$2\"\n"
"new=\"$3\"\n"
"echo \"# git tag v$new\"\n"
"echo \"git archive --prefix=linux-$new/ v$new | gzip -9 > ../linux-$new.tar.gz\"\n"
"echo \"git diff v$stable v$new | gzip -9 > ../patch-$new.gz\"\n"
"echo \"git log --no-merges v$new ^v$last > ../ChangeLog-$new\"\n"
"echo \"git shortlog --no-merges v$new ^v$last > ../ShortLog\"\n"
"echo \"git diff --stat --summary -M v$last v$new > ../diffstat-$new\"\n"
msgstr ""
"#!/bin/sh\n"
"stable=\"$1\"\n"
"last=\"$2\"\n"
"new=\"$3\"\n"
"echo \"# git tag v$new\"\n"
"echo \"git archive --prefix=linux-$new/ v$new | gzip -9 > ../linux-$new.tar.gz\"\n"
"echo \"git diff v$stable v$new | gzip -9 > ../patch-$new.gz\"\n"
"echo \"git log --no-merges v$new ^v$last > ../ChangeLog-$new\"\n"
"echo \"git shortlog --no-merges v$new ^v$last > ../ShortLog\"\n"
"echo \"git diff --stat --summary -M v$last v$new > ../diffstat-$new\"\n"

#. type: Plain text
#: ../../user-manual.txt:957
#, fuzzy
msgid ""
"and then he just cut-and-pastes the output commands after verifying that "
"they look OK."
msgstr ""
"そして、彼はそれらを確認してOKであることを見た後、単に出力されたコマンドを "
"カット＆ペーストします。"

#. type: Title ~
#: ../../user-manual.txt:960
#, fuzzy, no-wrap
msgid "Finding commits referencing a file with given content"
msgstr "指定した中身をもつファイルを参照するコミットを検索する"

#. type: Plain text
#: ../../user-manual.txt:965
#, fuzzy
msgid ""
"Somebody hands you a copy of a file, and asks which commits modified a file "
"such that it contained the given content either before or after the commit.  "
"You can find out with this:"
msgstr ""
"誰かがあなたにファイルのコピーを手渡し、どのコミットがそのように修正し、 コ"
"ミットの前または後にそのような内容を含んだのかを問い合わせたとします。 その場"
"合、次のようにしてそれを見つけ出します："

#. type: delimited block -
#: ../../user-manual.txt:969
#, fuzzy, no-wrap
msgid ""
"$  git log --raw --abbrev=40 --pretty=oneline |\n"
"\tgrep -B 1 `git hash-object filename`\n"
msgstr ""
"$  git log --raw --abbrev=40 --pretty=oneline |\n"
"\tgrep -B 1 `git hash-object filename`\n"

#. type: Plain text
#: ../../user-manual.txt:974
#, fuzzy
msgid ""
"Figuring out why this works is left as an exercise to the (advanced)  "
"student.  The linkgit:git-log[1], linkgit:git-diff-tree[1], and linkgit:git-"
"hash-object[1] man pages may prove helpful."
msgstr ""
"これが何故動作するかの説明は、(上級の)学生の演習として残しておきます。 "
"linkgit:git-log[1]、linkgit:git-diff-tree[1] そして、linkgit:git-hash-object"
"[1] の man ページが理解の助けになります。"

#. type: Title =
#: ../../user-manual.txt:977
#, fuzzy, no-wrap
msgid "Developing with git"
msgstr "git を使用した開発"

#. type: Title -
#: ../../user-manual.txt:981
#, fuzzy, no-wrap
msgid "Telling git your name"
msgstr "git に自分の名前を教える"

#. type: Plain text
#: ../../user-manual.txt:986
#, fuzzy
msgid ""
"Before creating any commits, you should introduce yourself to git.  The "
"easiest way to do so is to make sure the following lines appear in a file "
"named .gitconfig in your home directory:"
msgstr ""
"コミットをする前に、git に自己紹介をすべきです。 一番簡単な方法はホームディレ"
"クトリ下にある .gitconfig というファイルに 次の行が表示されていることを確認す"
"ることです。"

#. type: delimited block -
#: ../../user-manual.txt:991
#, fuzzy, no-wrap
msgid ""
"[user]\n"
"\tname = Your Name Comes Here\n"
"\temail = you@yourdomain.example.com\n"
msgstr ""
"[user]\n"
"\tname = Your Name Comes Here\n"
"\temail = you@yourdomain.example.com\n"

#. type: Plain text
#: ../../user-manual.txt:995
#, fuzzy
msgid ""
"(See the \"CONFIGURATION FILE\" section of linkgit:git-config[1] for details "
"on the configuration file.)"
msgstr ""
"(設定ファイルの詳細は linkgit:git-config[1] の \"CONFIGURATION FILE\" 節を 参"
"照してください)"

#. type: Title -
#: ../../user-manual.txt:999 ../../user-manual.txt:4290
#, fuzzy, no-wrap
msgid "Creating a new repository"
msgstr "新規リポジトリの作成"

#. type: Plain text
#: ../../user-manual.txt:1002
#, fuzzy
msgid "Creating a new repository from scratch is very easy:"
msgstr "ゼロから新規リポジトリを作成するのはとても簡単です："

#. type: delimited block -
#: ../../user-manual.txt:1007
#, fuzzy, no-wrap
msgid ""
"$ mkdir project\n"
"$ cd project\n"
"$ git init\n"
msgstr ""
"$ mkdir project\n"
"$ cd project\n"
"$ git init\n"

#. type: Plain text
#: ../../user-manual.txt:1010
#, fuzzy
msgid "If you have some initial content (say, a tarball):"
msgstr "最初に登録したいものがある場合は (tarball の場合)："

#. type: delimited block -
#: ../../user-manual.txt:1017
#, fuzzy, no-wrap
msgid ""
"$ tar xzvf project.tar.gz\n"
"$ cd project\n"
"$ git init\n"
"$ git add . # include everything below ./ in the first commit:\n"
"$ git commit\n"
msgstr ""
"$ tar xzvf project.tar.gz\n"
"$ cd project\n"
"$ git init\n"
"$ git add . # ./ 以下にある全てを最初のコミットに含めます\n"
"$ git commit\n"

#. type: Title -
#: ../../user-manual.txt:1021
#, fuzzy, no-wrap
msgid "How to make a commit"
msgstr "コミットの方法"

#. type: Plain text
#: ../../user-manual.txt:1024
#, fuzzy
msgid "Creating a new commit takes three steps:"
msgstr "新しいコミットを作成するには３つのステップが必要です："

#. type: Plain text
#: ../../user-manual.txt:1027
#, fuzzy
msgid ""
"Making some changes to the working directory using your favorite editor."
msgstr "好きなエディタを使用し、作業ディレクトリに変更を加えます。"

#. type: Plain text
#: ../../user-manual.txt:1028
#, fuzzy
msgid "Telling git about your changes."
msgstr "変更したことを git に伝えます。"

#. type: Plain text
#: ../../user-manual.txt:1030
#, fuzzy
msgid "Creating the commit using the content you told git about in step 2."
msgstr "ステップ２で git に伝えた内容を使用してコミットを作成します。"

#. type: Plain text
#: ../../user-manual.txt:1035
#, fuzzy
msgid ""
"In practice, you can interleave and repeat steps 1 and 2 as many times as "
"you want: in order to keep track of what you want committed at step 3, git "
"maintains a snapshot of the tree's contents in a special staging area called "
"\"the index.\""
msgstr ""
"実際には、ステップ１と２を相互に好きなだけ繰り返すことができます： ステップ３"
"でコミットしたいものの追跡を保つ為、git は \"索引(index)\" と呼ばれる 特別な"
"エリア内にツリーの中身のスナップショットを保管しています。"

#. type: Plain text
#: ../../user-manual.txt:1040
#, fuzzy
msgid ""
"At the beginning, the content of the index will be identical to that of the "
"HEAD.  The command \"git diff --cached\", which shows the difference between "
"the HEAD and the index, should therefore produce no output at that point."
msgstr ""
"最初は索引の中身は HEAD の中身と同じです。 コマンド \"git diff --cached\" は "
"HEAD と索引間の差分を表示する為、 この時点では何も出力しません。"

#. type: Plain text
#: ../../user-manual.txt:1042
#, fuzzy
msgid "Modifying the index is easy:"
msgstr "索引を変更するのは容易です："

#. type: Plain text
#: ../../user-manual.txt:1044
#, fuzzy
msgid "To update the index with the new contents of a modified file, use"
msgstr "索引を新しく修正したファイルの中身で更新するには、以下のようにします。"

#. type: delimited block -
#: ../../user-manual.txt:1047 ../../user-manual.txt:1053
#, fuzzy, no-wrap
msgid "$ git add path/to/file\n"
msgstr "$ git add path/to/file\n"

#. type: Plain text
#: ../../user-manual.txt:1050
#, fuzzy
msgid "To add the contents of a new file to the index, use"
msgstr "新しいファイルの中身を索引に追加するにも、以下のようにします。"

#. type: Plain text
#: ../../user-manual.txt:1056
#, fuzzy
msgid "To remove a file from the index and from the working tree,"
msgstr "索引と作業ツリー上からファイルを削除するには、"

#. type: delimited block -
#: ../../user-manual.txt:1059
#, fuzzy, no-wrap
msgid "$ git rm path/to/file\n"
msgstr "$ git rm path/to/file\n"

#. type: Plain text
#: ../../user-manual.txt:1062
#, fuzzy
msgid "After each step you can verify that"
msgstr "各ステップを行った後には、"

#. type: Plain text
#: ../../user-manual.txt:1069
#, fuzzy
msgid ""
"always shows the difference between the HEAD and the index file--this is "
"what you'd commit if you created the commit now--and that"
msgstr ""
"を行うことで HEAD と索引ファイル間の差分を確認することができます。-- これはコ"
"ミットした時に作成される内容です。-- そして"

#. type: Plain text
#: ../../user-manual.txt:1075
#, fuzzy
msgid "shows the difference between the working tree and the index file."
msgstr "は、作業ツリーと索引ファイル間の差分を表示します。"

#. type: Plain text
#: ../../user-manual.txt:1079
#, fuzzy
msgid ""
"Note that \"git add\" always adds just the current contents of a file to the "
"index; further changes to the same file will be ignored unless you run `git "
"add` on the file again."
msgstr ""
"\"git add\" は常に現在のファイルの中身を索引に追加することに注意 してくださ"
"い；さらに同じファイルに変更を加えても再度 `git add` をそのファイルに 行わな"
"い限りは無視されます。"

#. type: Plain text
#: ../../user-manual.txt:1081
#, fuzzy
msgid "When you're ready, just run"
msgstr "準備ができたら、"

#. type: Plain text
#: ../../user-manual.txt:1088
#, fuzzy
msgid ""
"and git will prompt you for a commit message and then create the new "
"commit.  Check to make sure it looks like what you expected with"
msgstr ""
"を実行します。git はコミットのメッセージの入力を促してから 新しいコミットを作"
"成します。意図した結果になっているかを確認するには、以下のようにします。"

#. type: delimited block -
#: ../../user-manual.txt:1091
#, fuzzy, no-wrap
msgid "$ git show\n"
msgstr "$ git show\n"

#. type: Plain text
#: ../../user-manual.txt:1094
#, fuzzy
msgid "As a special shortcut,"
msgstr "特別なショートカットとして"

#. type: Plain text
#: ../../user-manual.txt:1101
#, fuzzy
msgid ""
"will update the index with any files that you've modified or removed and "
"create a commit, all in one step."
msgstr ""
"というのがあります。これは変更又は削除した全てのファイルの索引を更新し コミッ"
"トを作成する操作を、１回のステップで全て行います。"

#. type: Plain text
#: ../../user-manual.txt:1104
#, fuzzy
msgid ""
"A number of commands are useful for keeping track of what you're about to "
"commit:"
msgstr ""
"たくさんのコマンドがコミットしようとしているものの追跡を保つ為に 役に立ちま"
"す："

#. type: delimited block -
#: ../../user-manual.txt:1114
#, fuzzy, no-wrap
msgid ""
"$ git diff --cached # difference between HEAD and the index; what\n"
"\t\t    # would be committed if you ran \"commit\" now.\n"
"$ git diff\t    # difference between the index file and your\n"
"\t\t    # working directory; changes that would not\n"
"\t\t    # be included if you ran \"commit\" now.\n"
"$ git diff HEAD\t    # difference between HEAD and working tree; what\n"
"\t\t    # would be committed if you ran \"commit -a\" now.\n"
"$ git status\t    # a brief per-file summary of the above.\n"
msgstr ""
"$ git diff --cached # HEAD と索引間の差分；\n"
"\t\t    # つまり、\"commit\" を実行したときにコミットされる内容\n"
"$ git diff\t    # 索引と作業ディレクトリ間の差分；\n"
"\t\t    # つまり、\"commit\" を実行したときに含まれない\n"
"\t\t    # 変更内容\n"
"$ git diff HEAD\t    # HEAD と作業ツリー間の差分：\n"
"\t\t    # つまり、\"commit -a\" を実行したときにコミットされる内容\n"
"$ git status\t    # 上記のサマリをファイル毎に簡潔に表示\n"

#. type: Plain text
#: ../../user-manual.txt:1120
#, fuzzy
msgid ""
"You can also use linkgit:git-gui[1] to create commits, view changes in the "
"index and the working tree files, and individually select diff hunks for "
"inclusion in the index (by right-clicking on the diff hunk and choosing "
"\"Stage Hunk For Commit\")."
msgstr ""
"これらのことをするために linkgit:git-gui[1] を使用することもできます。 git-"
"gui は コミットの作成や、索引と作業ツリー間の差分の参照、 索引に含めるべき差"
"分ハンクを個々に選択する(差分ハンクを右クリックして、 \"Stage Hunk For Commit"
"\" を選択する) ことができます。"

#. type: Title -
#: ../../user-manual.txt:1123
#, fuzzy, no-wrap
msgid "Creating good commit messages"
msgstr "良いコミットメッセージの書き方"

#. type: Plain text
#: ../../user-manual.txt:1131
#, fuzzy
msgid ""
"Though not required, it's a good idea to begin the commit message with a "
"single short (less than 50 character) line summarizing the change, followed "
"by a blank line and then a more thorough description.  Tools that turn "
"commits into email, for example, use the first line on the Subject line and "
"the rest of the commit in the body."
msgstr ""
"必須ではありませんが、格納メッセージを 次のようにするのは良い考えです。１行の"
"短文(50文字未満)で変更のサマリを書き、 その後に空白行を挟んで、最後により綿密"
"な記述をまとめる。 そうすることで、例えばコミットした内容を E-Mail に変更する"
"ツールにて、 Subjectに最初の行を使用し、残りの行を本文にすることができます。"

#. type: Title -
#: ../../user-manual.txt:1134
#, fuzzy, no-wrap
msgid "Ignoring files"
msgstr "無視するファイル"

#. type: Plain text
#: ../../user-manual.txt:1143
#, fuzzy
msgid ""
"A project will often generate files that you do 'not' want to track with "
"git.  This typically includes files generated by a build process or "
"temporary backup files made by your editor. Of course, 'not' tracking files "
"with git is just a matter of 'not' calling `git add` on them. But it quickly "
"becomes annoying to have these untracked files lying around; e.g. they make "
"`git add .` practically useless, and they keep showing up in the output of "
"`git status`."
msgstr ""
"プロジェクトはよく git に追跡してほしく'ない'ファイルを生成します。 典型的な"
"ものとしては、ビルドプロセッサーが生成するファイルや、 エディタが生成するバッ"
"クアップファイルなどです。もちろん、 git が追跡しないファイルに対して `git "
"add`をしなければ良いだけの問題です。 しかし、これら追跡しないファイルがいるこ"
"とでイライラさせられることがあります； 例えば、それらファイルに対しての `git "
"add .` は実際に不要であるにも、 関わらず、 `git status` の出力でそれらが表示"
"されてしまいます。"

#. type: Plain text
#: ../../user-manual.txt:1146
#, fuzzy
msgid ""
"You can tell git to ignore certain files by creating a file called ."
"gitignore in the top level of your working directory, with contents such as:"
msgstr ""
"作業ディレクトリのトップレベルに .gitignore という名前のファイルを作成するこ"
"とで、 無視するファイルを git に伝えることができます。"

#. type: delimited block -
#: ../../user-manual.txt:1157
#, fuzzy, no-wrap
msgid ""
"# Lines starting with '#' are considered comments.\n"
"# Ignore any file named foo.txt.\n"
"foo.txt\n"
"# Ignore (generated) html files,\n"
"*.html\n"
"# except foo.html which is maintained by hand.\n"
"!foo.html\n"
"# Ignore objects and archives.\n"
"*.[oa]\n"
msgstr ""
"# '#' で始まる行は無視されます\n"
"# foo.txt という名前の全てのファイルを無視する\n"
"foo.txt\n"
"# (生成された) html ファイルは無視する\n"
"*.html\n"
"# foo.html は例外とし、手でメンテナンスします\n"
"!foo.html\n"
"# object と archive ファイルは無視する\n"
"*.[oa]\n"

#. type: Plain text
#: ../../user-manual.txt:1165
#, fuzzy
msgid ""
"See linkgit:gitignore[5] for a detailed explanation of the syntax.  You can "
"also place .gitignore files in other directories in your working tree, and "
"they will apply to those directories and their subdirectories.  The `."
"gitignore` files can be added to your repository like any other files (just "
"run `git add .gitignore` and `git commit`, as usual), which is convenient "
"when the exclude patterns (such as patterns matching build output files) "
"would also make sense for other users who clone your repository."
msgstr ""
"記述形式の詳細は linkgit:gitignore[5] を参照してください。 作業ツリーの他の"
"ディレクトリに .gitignore を置くこともできます。 その場合、そのディレクトリと"
"サブディレクトリに適用されます。`.gitignore` ファイルは他のファイルと同様、リ"
"ポジトリに追加することができます(通常と同じで `git add .gitignore` と `git "
"commit` を実行するだけです)。(ビルド時の出力ファイルに一致するパターンのよう"
"な) 除外パターンを git で管理することは、 あなたのリポジトリを複製する他の"
"ユーザにとっても便利なことです。"

#. type: Plain text
#: ../../user-manual.txt:1172
#, fuzzy
msgid ""
"If you wish the exclude patterns to affect only certain repositories "
"(instead of every repository for a given project), you may instead put them "
"in a file in your repository named .git/info/exclude, or in any file "
"specified by the `core.excludesfile` configuration variable.  Some git "
"commands can also take exclude patterns directly on the command line.  See "
"linkgit:gitignore[5] for the details."
msgstr ""
"(プロジェクトの全てのリポジトリの代わりに)ある特定のリポジトリでだけ 除外パ"
"ターンを適用したい場合は、リポジトリ内の .git/info/exclude という場所に それ"
"らを置くか、コンフィグレーション変数 `core.excludesfile` によって 指定するこ"
"とができます。git コマンドによってはコマンドラインで除外するパターンを 直接指"
"定することもできます。 詳細は linkgit:gitignore[5] を参照してください。"

#. type: Title -
#: ../../user-manual.txt:1175
#, fuzzy, no-wrap
msgid "How to merge"
msgstr "マージの方法"

#. type: Plain text
#: ../../user-manual.txt:1179
#, fuzzy
msgid ""
"You can rejoin two diverging branches of development using linkgit:git-merge"
"[1]:"
msgstr ""
"２つの分散した開発ブランチは linkgit:git-merge[1] を使用して マージできます："

#. type: delimited block -
#: ../../user-manual.txt:1182
#, fuzzy, no-wrap
msgid "$ git merge branchname\n"
msgstr "$ git merge branchname\n"

#. type: Plain text
#: ../../user-manual.txt:1188
#, fuzzy
msgid ""
"merges the development in the branch \"branchname\" into the current "
"branch.  If there are conflicts--for example, if the same file is modified "
"in two different ways in the remote branch and the local branch--then you "
"are warned; the output may look something like this:"
msgstr ""
"上記はブランチ \"branchname\" の開発を現在のブランチにマージします。 コンフリ"
"クトが発生した場合は -- 例えば、リモートブランチとローカルブランチで 同じファ"
"イルが２つの異なる方法で変更された場合 -- 警告が表示されます； 出力される内容"
"は以下のようなものです："

#. type: delimited block -
#: ../../user-manual.txt:1195
#, fuzzy, no-wrap
msgid ""
"$ git merge next\n"
" 100% (4/4) done\n"
"Auto-merged file.txt\n"
"CONFLICT (content): Merge conflict in file.txt\n"
"Automatic merge failed; fix conflicts and then commit the result.\n"
msgstr ""
"$ git merge next\n"
" 100% (4/4) done\n"
"Auto-merged file.txt\n"
"CONFLICT (content): Merge conflict in file.txt\n"
"Automatic merge failed; fix conflicts and then commit the result.\n"

#. type: Plain text
#: ../../user-manual.txt:1201
#, fuzzy
msgid ""
"Conflict markers are left in the problematic files, and after you resolve "
"the conflicts manually, you can update the index with the contents and run "
"git commit, as you normally would when creating a new file."
msgstr ""
"コンフリクトマーカーは問題のあるファイルに残り、コンフリクトを 手作業で解消し"
"た後は、索引をそのファイルの中身で更新し、 git commit を実行することができま"
"す。通常の新しいファイルを作成するときと 同じようにです。"

#. type: Plain text
#: ../../user-manual.txt:1205
#, fuzzy
msgid ""
"If you examine the resulting commit using gitk, you will see that it has two "
"parents, one pointing to the top of the current branch, and one to the top "
"of the other branch."
msgstr ""
"gitk を使用しコミット結果を確認すると、それが２つの親を持っていて、 現在のブ"
"ランチの先頭と、もうひとつのブランチの先頭とを位置している ことが分かります。"

#. type: Title -
#: ../../user-manual.txt:1208
#, fuzzy, no-wrap
msgid "Resolving a merge"
msgstr "マージの解決"

#. type: Plain text
#: ../../user-manual.txt:1213
#, fuzzy
msgid ""
"When a merge isn't resolved automatically, git leaves the index and the "
"working tree in a special state that gives you all the information you need "
"to help resolve the merge."
msgstr ""
"マージが自動的に解決されない場合、git は索引と作業ツリーを 特別な状態にし、"
"マージの解決を手助けするのに必要な全ての情報を与えて くれます。"

#. type: Plain text
#: ../../user-manual.txt:1217
#, fuzzy
msgid ""
"Files with conflicts are marked specially in the index, so until you resolve "
"the problem and update the index, linkgit:git-commit[1] will fail:"
msgstr ""
"コンフリクトしたファイルは、索引内で特別なマージが付けられ、 その為問題を解決"
"し索引を更新するまで、linkgit:git-commit[1] は 失敗します："

#. type: delimited block -
#: ../../user-manual.txt:1221
#, fuzzy, no-wrap
msgid ""
"$ git commit\n"
"file.txt: needs merge\n"
msgstr ""
"$ git commit\n"
"file.txt: needs merge\n"

#. type: Plain text
#: ../../user-manual.txt:1225
#, fuzzy
msgid ""
"Also, linkgit:git-status[1] will list those files as \"unmerged\", and the "
"files with conflicts will have conflict markers added, like this:"
msgstr ""
"また、linkgit:git-status[1] はそれらのファイルを \"unmerged\" として表示し、 "
"コンフリクトしたファイルには以下のようなコンフリクトマーカーが追加されていま"
"す："

#. type: delimited block -
#: ../../user-manual.txt:1232
#, fuzzy, no-wrap
msgid ""
"<<<<<<< HEAD:file.txt\n"
"Hello world\n"
"=======\n"
"Goodbye\n"
">>>>>>> 77976da35a11db4580b80ae27e8d65caf5208086:file.txt\n"
msgstr ""
"<<<<<<< HEAD:file.txt\n"
"Hello world\n"
"=======\n"
"Goodbye\n"
">>>>>>> 77976da35a11db4580b80ae27e8d65caf5208086:file.txt\n"

#. type: Plain text
#: ../../user-manual.txt:1235
#, fuzzy
msgid "All you need to do is edit the files to resolve the conflicts, and then"
msgstr ""
"すべきことは、ファイルを編集してコンフリクトを解決し以下のようにすることで"
"す。"

#. type: delimited block -
#: ../../user-manual.txt:1239
#, fuzzy, no-wrap
msgid ""
"$ git add file.txt\n"
"$ git commit\n"
msgstr ""
"$ git add file.txt\n"
"$ git commit\n"

#. type: Plain text
#: ../../user-manual.txt:1245
#, fuzzy
msgid ""
"Note that the commit message will already be filled in for you with some "
"information about the merge.  Normally you can just use this default message "
"unchanged, but you may add additional commentary of your own if desired."
msgstr ""
"コミットメッセージは既にマージに関する情報が埋められていることに 注意してくだ"
"さい。通常このデフォルトのメッセージは変更せずに使用できますが、 必要であれば"
"自身のコメントを追加することもできます。"

#. type: Plain text
#: ../../user-manual.txt:1248
#, fuzzy
msgid ""
"The above is all you need to know to resolve a simple merge.  But git also "
"provides more information to help resolve conflicts:"
msgstr ""
"上記は単純なマージを解決する為に知る必要のある全てです。 しかし、git はコンフ"
"リクトの解決を手助けするさらなる情報を与えてくれます。"

#. type: Title ~
#: ../../user-manual.txt:1251
#, fuzzy, no-wrap
msgid "Getting conflict-resolution help during a merge"
msgstr "コンフリクトを解消する為の助けを得る"

#. type: Plain text
#: ../../user-manual.txt:1256
#, fuzzy
msgid ""
"All of the changes that git was able to merge automatically are already "
"added to the index file, so linkgit:git-diff[1] shows only the conflicts.  "
"It uses an unusual syntax:"
msgstr ""
"git が自動的にマージできた全ての変更は既に索引ファイルに 追加されています。そ"
"して linkgit:git-diff[1] はコンフリクトだけを 表示します。そうするには通常の"
"構文を使用します："

#. type: delimited block -
#: ../../user-manual.txt:1269
#, fuzzy, no-wrap
msgid ""
"$ git diff\n"
"diff --cc file.txt\n"
"index 802992c,2b60207..0000000\n"
"--- a/file.txt\n"
"+++ b/file.txt\n"
"@@@ -1,1 -1,1 +1,5 @@@\n"
"++<<<<<<< HEAD:file.txt\n"
" +Hello world\n"
"++=======\n"
"+ Goodbye\n"
"++>>>>>>> 77976da35a11db4580b80ae27e8d65caf5208086:file.txt\n"
msgstr ""
"$ git diff\n"
"diff --cc file.txt\n"
"index 802992c,2b60207..0000000\n"
"--- a/file.txt\n"
"+++ b/file.txt\n"
"@@@ -1,1 -1,1 +1,5 @@@\n"
"++<<<<<<< HEAD:file.txt\n"
" +Hello world\n"
"++=======\n"
"+ Goodbye\n"
"++>>>>>>> 77976da35a11db4580b80ae27e8d65caf5208086:file.txt\n"

#. type: Plain text
#: ../../user-manual.txt:1275
#, fuzzy
msgid ""
"Recall that the commit which will be committed after we resolve this "
"conflict will have two parents instead of the usual one: one parent will be "
"HEAD, the tip of the current branch; the other will be the tip of the other "
"branch, which is stored temporarily in MERGE_HEAD."
msgstr ""
"このコンフリクトを解決した後、コミットされる予定の内容は 通常と違って２つの親"
"を持っていることを思い出してください；一方は HEAD、つまり現在のブランチの先"
"端；もう一方はもうひとつのブランチの先端で MERGE_HEAD に格納されています。"

#. type: Plain text
#: ../../user-manual.txt:1278
#, fuzzy
msgid ""
"During the merge, the index holds three versions of each file.  Each of "
"these three \"file stages\" represents a different version of the file:"
msgstr ""
"マージしている間、索引は各ファイルの３つのバージョンを持っています。 この３つ"
"はそれぞれファイルの異なる３つの \"ファイルステージ\" を表現しています："

#. type: delimited block -
#: ../../user-manual.txt:1283
#, fuzzy, no-wrap
msgid ""
"$ git show :1:file.txt\t# the file in a common ancestor of both branches\n"
"$ git show :2:file.txt\t# the version from HEAD.\n"
"$ git show :3:file.txt\t# the version from MERGE_HEAD.\n"
msgstr ""
"$ git show :1:file.txt\t# 両方のブランチの共通祖先のファイル\n"
"$ git show :2:file.txt\t# HEAD にあるバージョン\n"
"$ git show :3:file.txt\t# MERGE_HEAD にあるバージョン\n"

#. type: Plain text
#: ../../user-manual.txt:1290
#, fuzzy
msgid ""
"When you ask linkgit:git-diff[1] to show the conflicts, it runs a three-way "
"diff between the conflicted merge results in the work tree with stages 2 and "
"3 to show only hunks whose contents come from both sides, mixed (in other "
"words, when a hunk's merge results come only from stage 2, that part is not "
"conflicting and is not shown.  Same for stage 3)."
msgstr ""
"コンフリクトが起こっている箇所を表示するために linkgit:git-diff[1]を実行する"
"と、 コンフリクトが起こったマージ結果の間の 三方向の差分(three-way diff)が表"
"示されます。 差分にはステージ2と3双方からきたコンテンツ が混ざった状態で含ま"
"れています。 (言い換えるとハンクのマージ結果が ステージ2だけからなされる場合"
"その部分ではコンフリクトは起こらず 表示されません。ステージ3についても同じで"
"す)"

#. type: Plain text
#: ../../user-manual.txt:1298
#, fuzzy
msgid ""
"The diff above shows the differences between the working-tree version of "
"file.txt and the stage 2 and stage 3 versions.  So instead of preceding each "
"line by a single \"+\" or \"-\", it now uses two columns: the first column "
"is used for differences between the first parent and the working directory "
"copy, and the second for differences between the second parent and the "
"working directory copy.  (See the \"COMBINED DIFF FORMAT\" section of "
"linkgit:git-diff-files[1] for a details of the format.)"
msgstr ""
"上記の差分は file.txt の作業ツリーのバージョンとステージ２とステージ３の バー"
"ジョン間の差分を表示します。その為、各行の先頭に１つの \"+\" または \"-\" が "
"付けられるかわりに、２つの列が使用されます：１つ目は １つ目の親と作業ディレク"
"トリコピーの間の差分を表すのに利用され、 ２つ目は２つ目の親と作業ディレクトリ"
"コピーの間の差分を表示するのに利用されます。 (このフォーマットの詳細は "
"linkgit:git-diff-files[1] の \"COMBINED DIFF FORMAT\" の 節を参照してくださ"
"い)"

#. type: Plain text
#: ../../user-manual.txt:1301
#, fuzzy
msgid ""
"After resolving the conflict in the obvious way (but before updating the "
"index), the diff will look like:"
msgstr ""
"コンフリクトを通常と同じ方法で解決した後、(indexの更新前に) diff を 実行する"
"と次のように表示されます："

#. type: delimited block -
#: ../../user-manual.txt:1312
#, fuzzy, no-wrap
msgid ""
"$ git diff\n"
"diff --cc file.txt\n"
"index 802992c,2b60207..0000000\n"
"--- a/file.txt\n"
"+++ b/file.txt\n"
"@@@ -1,1 -1,1 +1,1 @@@\n"
"- Hello world\n"
" -Goodbye\n"
"++Goodbye world\n"
msgstr ""
"$ git diff\n"
"diff --cc file.txt\n"
"index 802992c,2b60207..0000000\n"
"--- a/file.txt\n"
"+++ b/file.txt\n"
"@@@ -1,1 -1,1 +1,1 @@@\n"
"- Hello world\n"
" -Goodbye\n"
"++Goodbye world\n"

#. type: Plain text
#: ../../user-manual.txt:1317
#, fuzzy
msgid ""
"This shows that our resolved version deleted \"Hello world\" from the first "
"parent, deleted \"Goodbye\" from the second parent, and added \"Goodbye world"
"\", which was previously absent from both."
msgstr ""
"これは、解決済みのバージョンが 一つ目の親から \"Hello world\" を削除し、 ２つ"
"目の親から \"Goodbye\" を削除し、 両方の親に存在しない \"Goodbye world\" を追"
"加したことを表しています。"

#. type: Plain text
#: ../../user-manual.txt:1320
#, fuzzy
msgid ""
"Some special diff options allow diffing the working directory against any of "
"these stages:"
msgstr ""
"他の特別な diff オプションを使用すると、これら任意のステージと 作業ディレクト"
"リとの差分を表示することができます。"

#. type: delimited block -
#: ../../user-manual.txt:1328
#, fuzzy, no-wrap
msgid ""
"$ git diff -1 file.txt\t\t# diff against stage 1\n"
"$ git diff --base file.txt\t# same as the above\n"
"$ git diff -2 file.txt\t\t# diff against stage 2\n"
"$ git diff --ours file.txt\t# same as the above\n"
"$ git diff -3 file.txt\t\t# diff against stage 3\n"
"$ git diff --theirs file.txt\t# same as the above.\n"
msgstr ""
"$ git diff -1 file.txt\t\t# ステージ１との diff\n"
"$ git diff --base file.txt\t# 上記と同じ\n"
"$ git diff -2 file.txt\t\t# ステージ２との diff\n"
"$ git diff --ours file.txt\t# 上記と同じ\n"
"$ git diff -3 file.txt\t\t# ステージ３との diff\n"
"$ git diff --theirs file.txt\t# 上記と同じ\n"

#. type: Plain text
#: ../../user-manual.txt:1332
#, fuzzy
msgid ""
"The linkgit:git-log[1] and linkgit:gitk[1] commands also provide special "
"help for merges:"
msgstr ""
"linkgit:git-log[1] と linkgit:gitk[1] コマンドもまた merge の手助けをしてくれ"
"ます。"

#. type: delimited block -
#: ../../user-manual.txt:1336
#, fuzzy, no-wrap
msgid ""
"$ git log --merge\n"
"$ gitk --merge\n"
msgstr ""
"$ git log --merge\n"
"$ gitk --merge\n"

#. type: Plain text
#: ../../user-manual.txt:1340
#, fuzzy
msgid ""
"These will display all commits which exist only on HEAD or on MERGE_HEAD, "
"and which touch an unmerged file."
msgstr ""
"これらは、HEAD または MERGE_HEAD にだけ存在する全てのコミットを表示し、 マー"
"ジされていないファイルを表示します。"

#. type: Plain text
#: ../../user-manual.txt:1343
#, fuzzy
msgid ""
"You may also use linkgit:git-mergetool[1], which lets you merge the unmerged "
"files using external tools such as Emacs or kdiff3."
msgstr ""
"linkgit:git-mergetool を利用することもできます。これを利用すると Emacs や "
"kdiff3 のような外部ツールを使用してマージを行うことができます。"

#. type: Plain text
#: ../../user-manual.txt:1345
#, fuzzy
msgid "Each time you resolve the conflicts in a file and update the index:"
msgstr "ファイルのコンフリクトを解決した後には、索引を更新してください："

#. type: delimited block -
#: ../../user-manual.txt:1348
#, fuzzy, no-wrap
msgid "$ git add file.txt\n"
msgstr "$ git add file.txt\n"

#. type: Plain text
#: ../../user-manual.txt:1352
#, fuzzy
msgid ""
"the different stages of that file will be \"collapsed\", after which `git "
"diff` will (by default) no longer show diffs for that file."
msgstr ""
"すると、そのファイルの各ステージは \"崩壊\" され、 `git diff` はもはや (デ"
"フォルトでは) そのファイルに対する差分を表示しません。"

#. type: Title -
#: ../../user-manual.txt:1355
#, fuzzy, no-wrap
msgid "Undoing a merge"
msgstr "マージの取り消し"

#. type: Plain text
#: ../../user-manual.txt:1359
#, fuzzy
msgid ""
"If you get stuck and decide to just give up and throw the whole mess away, "
"you can always return to the pre-merge state with"
msgstr ""
"マージ作業に行き詰まり、全ての処置を捨て去る場合には、 いつでもマージ前の状態"
"に戻ることができます。次のようにします。"

#. type: delimited block -
#: ../../user-manual.txt:1362 ../../user-manual.txt:1400
#, fuzzy, no-wrap
msgid "$ git reset --hard HEAD\n"
msgstr "$ git reset --hard HEAD\n"

#. type: Plain text
#: ../../user-manual.txt:1365
#, fuzzy
msgid "Or, if you've already committed the merge that you want to throw away,"
msgstr ""
"あるいは、既に削除したいマージ結果をコミット済みの場合には、次のようにしま"
"す。"

#. type: delimited block -
#: ../../user-manual.txt:1368
#, fuzzy, no-wrap
msgid "$ git reset --hard ORIG_HEAD\n"
msgstr "$ git reset --hard ORIG_HEAD\n"

#. type: Plain text
#: ../../user-manual.txt:1374
#, fuzzy
msgid ""
"However, this last command can be dangerous in some cases--never throw away "
"a commit you have already committed if that commit may itself have been "
"merged into another branch, as doing so may confuse further merges."
msgstr ""
"しかし、最後のコマンドは、幾つかの場合に危険となりえます。-- そのコミットが "
"他のブランチにマージされている場合は、決してそのコミットを削除しないでくださ"
"い。 もしそうしたなら、さらにマージする場合に混乱が起きます。"

#. type: Title -
#: ../../user-manual.txt:1377
#, fuzzy, no-wrap
msgid "Fast-forward merges"
msgstr "高速前進(Fast-forward)マージ"

#. type: Plain text
#: ../../user-manual.txt:1383
#, fuzzy
msgid ""
"There is one special case not mentioned above, which is treated "
"differently.  Normally, a merge results in a merge commit, with two parents, "
"one pointing at each of the two lines of development that were merged."
msgstr ""
"上記で説明してこなかった特別なケースがあります。 通常マージコミットにおける"
"マージ結果は２つの親を持ち、 各親はマージした２つの開発ラインのそれぞれを指し"
"示しています。"

#. type: Plain text
#: ../../user-manual.txt:1389
#, fuzzy
msgid ""
"However, if the current branch is a descendant of the other--so every commit "
"present in the one is already contained in the other--then git just performs "
"a \"fast forward\"; the head of the current branch is moved forward to point "
"at the head of the merged-in branch, without any new commits being created."
msgstr ""
"そのため、現在のブランチが他方の子孫である場合には -- つまり 全てのコミットが"
"既に他方のコミットに含まれている場合には -- git は \"fast forward\" を行いま"
"す；現在のブランチの先頭はマージされるブランチの 先頭の位置に進められ、新しい"
"コミットは作成されません。"

#. type: Title -
#: ../../user-manual.txt:1392
#, fuzzy, no-wrap
msgid "Fixing mistakes"
msgstr "修正間違い"

#. type: Plain text
#: ../../user-manual.txt:1397
#, fuzzy
msgid ""
"If you've messed up the working tree, but haven't yet committed your "
"mistake, you can return the entire working tree to the last committed state "
"with"
msgstr ""
"作業ツリーに手を入れたが、間違いをまだコミットしていない場合は、 以下のように"
"して作業ツリーを最後にコミットした状態に戻すことができます。"

#. type: Plain text
#: ../../user-manual.txt:1404
#, fuzzy
msgid ""
"If you make a commit that you later wish you hadn't, there are two "
"fundamentally different ways to fix the problem:"
msgstr ""
"コミットした後ですべきではなかったと気が付いた時は、 ２つの異なる解決方法があ"
"ります："

#. type: Plain text
#: ../../user-manual.txt:1406
#, fuzzy
msgid "You can create a new commit that undoes whatever was done"
msgstr "変更を取り消す新しいコミットを作成する。"

#. type: Plain text
#: ../../user-manual.txt:1408
#, fuzzy
msgid ""
"by the old commit.  This is the correct thing if your mistake has already "
"been made public."
msgstr "既に間違いを公開してしまった場合にはこれは正しいやり方です。"

#. type: Plain text
#: ../../user-manual.txt:1410
#, fuzzy
msgid "You can go back and modify the old commit.  You should"
msgstr "元に戻して古いコミットを修正する。"

#. type: Plain text
#: ../../user-manual.txt:1414
#, fuzzy
msgid ""
"never do this if you have already made the history public; git does not "
"normally expect the \"history\" of a project to change, and cannot correctly "
"perform repeated merges from a branch that has had its history changed."
msgstr ""
"履歴を公開した後の場合は、決してこれをしてはいけません； 通常、git は プロ"
"ジェクトの履歴が変更されないことを想定しています。 そして、履歴が変更されたブ"
"ランチからは正しくマージを繰り返すことが できません。"

#. type: Title ~
#: ../../user-manual.txt:1417
#, fuzzy, no-wrap
msgid "Fixing a mistake with a new commit"
msgstr "新しいコミットで間違いを修正する"

#. type: Plain text
#: ../../user-manual.txt:1422
#, fuzzy
msgid ""
"Creating a new commit that reverts an earlier change is very easy; just pass "
"the linkgit:git-revert[1] command a reference to the bad commit; for "
"example, to revert the most recent commit:"
msgstr ""
"前の変更を取り消す新しいコミットを作成するのはとても簡単です； 単に linkgit:"
"git-revert[1] コマンドに間違ったコミットへの参照を 渡すだけです；例えば、直前"
"のコミットを元に戻すには："

#. type: delimited block -
#: ../../user-manual.txt:1425
#, fuzzy, no-wrap
msgid "$ git revert HEAD\n"
msgstr "$ git revert HEAD\n"

#. type: Plain text
#: ../../user-manual.txt:1429
#, fuzzy
msgid ""
"This will create a new commit which undoes the change in HEAD.  You will be "
"given a chance to edit the commit message for the new commit."
msgstr ""
"この操作により、HEAD の変更を取り消す新しいコミットが作成されます。 また、新"
"しいコミットに対するコミットメッセージが促されます。"

#. type: Plain text
#: ../../user-manual.txt:1431
#, fuzzy
msgid "You can also revert an earlier change, for example, the next-to-last:"
msgstr "より過去の変更を取り消すこともできます、例えば、２つ前の場合："

#. type: delimited block -
#: ../../user-manual.txt:1434
#, fuzzy, no-wrap
msgid "$ git revert HEAD^\n"
msgstr "$ git revert HEAD^\n"

#. type: Plain text
#: ../../user-manual.txt:1441
#, fuzzy
msgid ""
"In this case git will attempt to undo the old change while leaving intact "
"any changes made since then.  If more recent changes overlap with the "
"changes to be reverted, then you will be asked to fix conflicts manually, "
"just as in the case of <<resolving-a-merge, resolving a merge>>."
msgstr ""
"この場合 git はそれ以前の変更はそのまま残し、指定したコミットの変更だけを 取"
"り消そうとします。指定コミットより後の変更内容が取り消す変更内容とオーバー"
"ラップ している場合は、<<resolving-a-merge,マージの解決>> の場合と同じく、 コ"
"ンフリクトを手動で解決するよう促されます。"

#. type: Title ~
#: ../../user-manual.txt:1444
#, fuzzy, no-wrap
msgid "Fixing a mistake by rewriting history"
msgstr "履歴を再編集して間違いを訂正する"

#. type: Plain text
#: ../../user-manual.txt:1449
#, fuzzy
msgid ""
"If the problematic commit is the most recent commit, and you have not yet "
"made that commit public, then you may just <<undoing-a-merge,destroy it "
"using `git reset`>>."
msgstr ""
"問題のあるコミットが直前のコミットであり、まだ公開していない場合は、 単に"
"<<undoing-a-merge,`git reset`を使用した削除>>を行うと良いです。"

#. type: Plain text
#: ../../user-manual.txt:1454
#, fuzzy
msgid ""
"Alternatively, you can edit the working directory and update the index to "
"fix your mistake, just as if you were going to <<how-to-make-a-commit,create "
"a new commit>>, then run"
msgstr ""
"また、代わりに、作業ディレクトリを編集し間違いを訂正した後、索引を更新 するこ"
"ともできます。<<how-to-make-a-commit,新しいコミットの作成>> で 示した手順で作"
"業していたなら、次のようにします。"

#. type: delimited block -
#: ../../user-manual.txt:1457 ../../user-manual.txt:2496
#, fuzzy, no-wrap
msgid "$ git commit --amend\n"
msgstr "$ git commit --amend\n"

#. type: Plain text
#: ../../user-manual.txt:1461 ../../user-manual.txt:2500
#, fuzzy
msgid ""
"which will replace the old commit by a new commit incorporating your "
"changes, giving you a chance to edit the old commit message first."
msgstr ""
"#-#-#-#-#  translated/user-manual.txt:1435  #-#-#-#-#\n"
"これにより、古いコミットが変更内容が記録された新しいコミットに置き換わり、 過"
"去にコミットしたメッセージを編集することもできます。\n"
"#-#-#-#-#  translated/user-manual.txt:2461  #-#-#-#-#\n"
"この操作は、過去のコミットをあなたが変更を受け入れる新しいコミットに 置き換"
"え、過去のコミットメッセージを編集する機会を与えてくれます。"

#. type: Plain text
#: ../../user-manual.txt:1465
#, fuzzy
msgid ""
"Again, you should never do this to a commit that may already have been "
"merged into another branch; use linkgit:git-revert[1] instead in that case."
msgstr ""
"再注意となりますが、他のブランチに既にマージしているコミットに対しては 決して"
"この操作を行わないでください；その場合は、linkgit:git-revert[1] を使用してく"
"ださい。"

#. type: Plain text
#: ../../user-manual.txt:1469
#, fuzzy
msgid ""
"It is also possible to replace commits further back in the history, but this "
"is an advanced topic to be left for <<cleaning-up-history,another chapter>>."
msgstr ""
"履歴内のさらに過去のコミットを置き換えることもできますが、 <<cleaning-up-"
"history,次章>> の上級トピックスとして残しておきます。"

#. type: Title ~
#: ../../user-manual.txt:1472
#, fuzzy, no-wrap
msgid "Checking out an old version of a file"
msgstr "古いバージョンファイルのチェックアウト"

#. type: Plain text
#: ../../user-manual.txt:1479
#, fuzzy
msgid ""
"In the process of undoing a previous bad change, you may find it useful to "
"check out an older version of a particular file using linkgit:git-checkout"
"[1].  We've used `git checkout` before to switch branches, but it has quite "
"different behavior if it is given a path name: the command"
msgstr ""
"以前の間違った変更を取消作業の中で、linkgit:git-checkout[1] を使用して 特定"
"ファイルの古いバージョンをチェックアウトすると便利な場合があるかもしれませ"
"ん。 これまで branch を切り替える際に `git checkout` を使用してきましたが、 "
"パス名が与えられた場合には全くことなる動作をします： 次のコマンド"

#. type: delimited block -
#: ../../user-manual.txt:1482
#, fuzzy, no-wrap
msgid "$ git checkout HEAD^ path/to/file\n"
msgstr "$ git checkout HEAD^ path/to/file\n"

#. type: Plain text
#: ../../user-manual.txt:1486
#, fuzzy
msgid ""
"replaces path/to/file by the contents it had in the commit HEAD^, and also "
"updates the index to match.  It does not change branches."
msgstr ""
"は、path/to/file をコミット HEAD^ の時の内容で置き換え、 索引の更新も行ないま"
"す。ブランチは変更しません。"

#. type: Plain text
#: ../../user-manual.txt:1490
#, fuzzy
msgid ""
"If you just want to look at an old version of the file, without modifying "
"the working directory, you can do that with linkgit:git-show[1]:"
msgstr ""
"作業ディレクトリを修正せずに単にそのファイルの古いバージョンを参照したいだけ"
"の時は、 linkgit:git-show[1] を使用します："

#. type: delimited block -
#: ../../user-manual.txt:1493
#, fuzzy, no-wrap
msgid "$ git show HEAD^:path/to/file\n"
msgstr "$ git show HEAD^:path/to/file\n"

#. type: Plain text
#: ../../user-manual.txt:1496
#, fuzzy
msgid "which will display the given version of the file."
msgstr "そうすることでそのバージョンのファイルを表示できます。"

#. type: Title ~
#: ../../user-manual.txt:1499
#, fuzzy, no-wrap
msgid "Temporarily setting aside work in progress"
msgstr "作業中の仕事を一時的に脇に片付ける"

#. type: Plain text
#: ../../user-manual.txt:1507
#, fuzzy
msgid ""
"While you are in the middle of working on something complicated, you find an "
"unrelated but obvious and trivial bug.  You would like to fix it before "
"continuing.  You can use linkgit:git-stash[1] to save the current state of "
"your work, and after fixing the bug (or, optionally after doing so on a "
"different branch and then coming back), unstash the work-in-progress changes."
msgstr ""
"あなたが何か複雑な作業をしている途中に、今の作業とは関係のない明らかなバグを "
"みつけたとします。作業を中断してそのバグを処置したいとします。 linkgit:git-"
"stash[1] を使用すると、現在の作業状態を保存し、 バグ処置をした後 (あるいは、"
"異なるブランチ上で処置を行い、元に戻り)、 作業中の状態に戻すことができます。"

#. type: delimited block -
#: ../../user-manual.txt:1510
#, fuzzy, no-wrap
msgid "$ git stash save \"work in progress for foo feature\"\n"
msgstr "$ git stash save \"work in progress for foo feature\"\n"

#. type: Plain text
#: ../../user-manual.txt:1515
#, fuzzy
msgid ""
"This command will save your changes away to the `stash`, and reset your "
"working tree and the index to match the tip of your current branch.  Then "
"you can make your fix as usual."
msgstr ""
"このコマンドはあなたの変更を `stash` に保存し、 作業ディレクトリをリセット"
"し、索引を現在のブランチの tip に一致 させます。通常の手順でバグの処置をして"
"ください。"

#. type: delimited block -
#: ../../user-manual.txt:1519
#, fuzzy, no-wrap
msgid ""
"... edit and test ...\n"
"$ git commit -a -m \"blorpl: typofix\"\n"
msgstr ""
"... edit and test ...\n"
"$ git commit -a -m \"blorpl: typofix\"\n"

#. type: Plain text
#: ../../user-manual.txt:1523
#, fuzzy
msgid ""
"After that, you can go back to what you were working on with `git stash "
"apply`:"
msgstr ""
"その後、`git stash apply` を用いて作業していた時の状態に 戻ることができます。"

#. type: delimited block -
#: ../../user-manual.txt:1526
#, fuzzy, no-wrap
msgid "$ git stash apply\n"
msgstr "$ git stash apply\n"

#. type: Title -
#: ../../user-manual.txt:1531
#, fuzzy, no-wrap
msgid "Ensuring good performance"
msgstr "パフォーマンスを確保する"

#. type: Plain text
#: ../../user-manual.txt:1535
#, fuzzy
msgid ""
"On large repositories, git depends on compression to keep the history "
"information from taking up too much space on disk or in memory."
msgstr ""
"大きなリポジトリでは、git はディスクとメモリの使用量を節約するため、 履歴の情"
"報を圧縮して管理することができます。"

#. type: Plain text
#: ../../user-manual.txt:1538
#, fuzzy
msgid ""
"This compression is not performed automatically.  Therefore you should "
"occasionally run linkgit:git-gc[1]:"
msgstr ""
"この圧縮は自動的には行なわれません。従って 時々 linkgit:git-gc[1] を実行する"
"必要があります："

#. type: delimited block -
#: ../../user-manual.txt:1541 ../../user-manual.txt:4513
#, fuzzy, no-wrap
msgid "$ git gc\n"
msgstr "$ git gc\n"

#. type: Plain text
#: ../../user-manual.txt:1545
#, fuzzy
msgid ""
"to recompress the archive.  This can be very time-consuming, so you may "
"prefer to run `git gc` when you are not doing other work."
msgstr ""
"アーカイブを圧縮する処理はたくさんの時間がかかるため、 `git gc` をするとき"
"は、他の作業をしない方が良いでしょう。"

#. type: Title -
#: ../../user-manual.txt:1549
#, fuzzy, no-wrap
msgid "Ensuring reliability"
msgstr "信頼性の確保"

#. type: Title ~
#: ../../user-manual.txt:1553
#, fuzzy, no-wrap
msgid "Checking the repository for corruption"
msgstr "リポジトリの不正を確認する"

#. type: Plain text
#: ../../user-manual.txt:1558
#, fuzzy
msgid ""
"The linkgit:git-fsck[1] command runs a number of self-consistency checks on "
"the repository, and reports on any problems.  This may take some time.  The "
"most common warning by far is about \"dangling\" objects:"
msgstr ""
"linkgit:git-fsck[1] コマンドはリポジトリに対してたくさんの自己一貫性チェック"
"を 実行し、あらゆる問題を報告します。この作業にはいくらかの時間が かかりま"
"す。最も多い警告は \"dangling\" オブジェクトに関するものです："

#. type: delimited block -
#: ../../user-manual.txt:1570
#, fuzzy, no-wrap
msgid ""
"$ git fsck\n"
"dangling commit 7281251ddd2a61e38657c827739c57015671a6b3\n"
"dangling commit 2706a059f258c6b245f298dc4ff2ccd30ec21a63\n"
"dangling commit 13472b7c4b80851a1bc551779171dcb03655e9b5\n"
"dangling blob 218761f9d90712d37a9c5e36f406f92202db07eb\n"
"dangling commit bf093535a34a4d35731aa2bd90fe6b176302f14f\n"
"dangling commit 8e4bec7f2ddaa268bef999853c25755452100f8e\n"
"dangling tree d50bb86186bf27b681d25af89d3b5b68382e4085\n"
"dangling tree b24c2473f1fd3d91352a624795be026d64c8841f\n"
"...\n"
msgstr ""
"$ git fsck\n"
"dangling commit 7281251ddd2a61e38657c827739c57015671a6b3\n"
"dangling commit 2706a059f258c6b245f298dc4ff2ccd30ec21a63\n"
"dangling commit 13472b7c4b80851a1bc551779171dcb03655e9b5\n"
"dangling blob 218761f9d90712d37a9c5e36f406f92202db07eb\n"
"dangling commit bf093535a34a4d35731aa2bd90fe6b176302f14f\n"
"dangling commit 8e4bec7f2ddaa268bef999853c25755452100f8e\n"
"dangling tree d50bb86186bf27b681d25af89d3b5b68382e4085\n"
"dangling tree b24c2473f1fd3d91352a624795be026d64c8841f\n"
"...\n"

#. type: Plain text
#: ../../user-manual.txt:1575
#, fuzzy
msgid ""
"Dangling objects are not a problem.  At worst they may take up a little "
"extra disk space.  They can sometimes provide a last-resort method for "
"recovering lost work--see <<dangling-objects>> for details."
msgstr ""
"Dangling オブジェクトは無害です。悪くとも幾らかのディスクスペースを 余計に消"
"費するだけです。これらは時に紛失した作業内容を復旧させる 最後の機会を与えてく"
"れます -- 詳細は <<dangling-objects>> を参照してください。"

#. type: Title ~
#: ../../user-manual.txt:1578
#, fuzzy, no-wrap
msgid "Recovering lost changes"
msgstr "過去の変更を復旧させる"

#. type: Title ^
#: ../../user-manual.txt:1582
#, fuzzy, no-wrap
msgid "Reflogs"
msgstr "参照ログ(Reflogs)"

#. type: Plain text
#: ../../user-manual.txt:1587
#, fuzzy
msgid ""
"Say you modify a branch with `linkgit:git-reset[1] --hard`, and then realize "
"that the branch was the only reference you had to that point in history."
msgstr ""
"`linkgit:git-reset[1] --hard` を使用してブランチを修正した後に 履歴上でそれを"
"参照しているのがそのブランチであることに気がついたと します。"

#. type: Plain text
#: ../../user-manual.txt:1591
#, fuzzy
msgid ""
"Fortunately, git also keeps a log, called a \"reflog\", of all the previous "
"values of each branch.  So in this case you can still find the old history "
"using, for example,"
msgstr ""
"幸運なことに、git は \"reflog\" と呼ばれるログを保持しており、 各ブランチの過"
"去全ての値を保持しています。従ってこの場合 古い履歴を例えば次のようにして見つ"
"け出すことができます："

#. type: delimited block -
#: ../../user-manual.txt:1594
#, fuzzy, no-wrap
msgid "$ git log master@{1}\n"
msgstr "$ git log master@{1}\n"

#. type: Plain text
#: ../../user-manual.txt:1599
#, fuzzy
msgid ""
"This lists the commits reachable from the previous version of the \"master\" "
"branch head.  This syntax can be used with any git command that accepts a "
"commit, not just with git log.  Some other examples:"
msgstr ""
"このコマンドは \"master\" ブランチヘッドの１つ前のバージョンから到達可能なコ"
"ミットの一覧を表示します。 この構文は git log 以外にもコミットを引数に持つ任"
"意の git コマンドに利用 できます。以下は例です："

#. type: delimited block -
#: ../../user-manual.txt:1606
#, fuzzy, no-wrap
msgid ""
"$ git show master@{2}\t\t# See where the branch pointed 2,\n"
"$ git show master@{3}\t\t# 3, ... changes ago.\n"
"$ gitk master@{yesterday}\t# See where it pointed yesterday,\n"
"$ gitk master@{\"1 week ago\"}\t# ... or last week\n"
"$ git log --walk-reflogs master\t# show reflog entries for master\n"
msgstr ""
"$ git show master@{2}\t\t# ２つ前のブランチの状態を表示\n"
"$ git show master@{3}\t\t# ３つ前のブランチの状態を表示\n"
"$ gitk master@{yesterday}\t# 昨日の状態を表示\n"
"$ gitk master@{\"1 week ago\"}\t# １週間前の状態を表示\n"
"$ git log --walk-reflogs master\t# master に対する reflog エントリを表示します\n"

#. type: Plain text
#: ../../user-manual.txt:1609
#, fuzzy
msgid "A separate reflog is kept for the HEAD, so"
msgstr "分割された reflog は HEAD を保つため、"

#. type: delimited block -
#: ../../user-manual.txt:1612
#, fuzzy, no-wrap
msgid "$ git show HEAD@{\"1 week ago\"}\n"
msgstr "$ git show HEAD@{\"1 week ago\"}\n"

#. type: Plain text
#: ../../user-manual.txt:1617
#, fuzzy
msgid ""
"will show what HEAD pointed to one week ago, not what the current branch "
"pointed to one week ago.  This allows you to see the history of what you've "
"checked out."
msgstr ""
"は、１週間前に現在のブランチが指していた場所を指すのではなく、 １週間前に "
"HEAD が指していた場所を表示します。 これにより、チェックアウトしていた場所の"
"履歴を確認することができます。"

#. type: Plain text
#: ../../user-manual.txt:1622
#, fuzzy
msgid ""
"The reflogs are kept by default for 30 days, after which they may be "
"pruned.  See linkgit:git-reflog[1] and linkgit:git-gc[1] to learn how to "
"control this pruning, and see the \"SPECIFYING REVISIONS\" section of "
"linkgit:git-rev-parse[1] for details."
msgstr ""
"reflog はデフォルトでは30日間保存され、その後削除されます。 linkgit:git-"
"reflog[1] と linkgit:git-gc[1] を参照すると、 reflog がどのように削除されるか"
"を学ぶことができます。 詳細は linkgit:git-rev-parse[1] の \"SPECIFYING "
"REVISIONS\" の節を参照してください。"

#. type: Plain text
#: ../../user-manual.txt:1627
#, fuzzy
msgid ""
"Note that the reflog history is very different from normal git history.  "
"While normal history is shared by every repository that works on the same "
"project, the reflog history is not shared: it tells you only about how the "
"branches in your local repository have changed over time."
msgstr ""
"reflog の履歴は通常の git の履歴と大きく違うことに注意してください。 通常の履"
"歴は同じプロジェクトの各リポジトリ間で共有されますが、 reflog は共有されませ"
"ん：あなたのローカルリポジトリのブランチが時間と ともにどのように変更されたか"
"を説明するだけです。"

#. type: Title ^
#: ../../user-manual.txt:1630
#, fuzzy, no-wrap
msgid "Examining dangling objects"
msgstr "dangling オブジェクトを試す"

#. type: Plain text
#: ../../user-manual.txt:1638
#, fuzzy
msgid ""
"In some situations the reflog may not be able to save you.  For example, "
"suppose you delete a branch, then realize you need the history it "
"contained.  The reflog is also deleted; however, if you have not yet pruned "
"the repository, then you may still be able to find the lost commits in the "
"dangling objects that `git fsck` reports.  See <<dangling-objects>> for the "
"details."
msgstr ""
"いくつかの場面で、reflog を用いても救済できない場合があります。例えば、 ブラ"
"ンチを削除した後に、そこにあった履歴が必要になったような場合です。 この時は "
"reflog もまた削除されます；しかし、リポジトリをまだ削除していない場合は、 "
"`git fsck` がリポートする dangling オブジェクト内に削除したコミットを見つけら"
"れる 場合があります。詳細は <<dangling-objects>> を参照してください。"

#. type: delimited block -
#: ../../user-manual.txt:1645
#, fuzzy, no-wrap
msgid ""
"$ git fsck\n"
"dangling commit 7281251ddd2a61e38657c827739c57015671a6b3\n"
"dangling commit 2706a059f258c6b245f298dc4ff2ccd30ec21a63\n"
"dangling commit 13472b7c4b80851a1bc551779171dcb03655e9b5\n"
"...\n"
msgstr ""
"$ git fsck\n"
"dangling commit 7281251ddd2a61e38657c827739c57015671a6b3\n"
"dangling commit 2706a059f258c6b245f298dc4ff2ccd30ec21a63\n"
"dangling commit 13472b7c4b80851a1bc551779171dcb03655e9b5\n"
"...\n"

#. type: Plain text
#: ../../user-manual.txt:1649
#, fuzzy
msgid "You can examine one of those dangling commits with, for example,"
msgstr ""
"これら dangling コミットの一つを例えば以下のようにして見ることができます。"

#. type: delimited block -
#: ../../user-manual.txt:1652
#, fuzzy, no-wrap
msgid "$ gitk 7281251ddd --not --all\n"
msgstr "$ gitk 7281251ddd --not --all\n"

#. type: Plain text
#: ../../user-manual.txt:1661
#, fuzzy
msgid ""
"which does what it sounds like: it says that you want to see the commit "
"history that is described by the dangling commit(s), but not the history "
"that is described by all your existing branches and tags.  Thus you get "
"exactly the history reachable from that commit that is lost.  (And notice "
"that it might not be just one commit: we only report the \"tip of the line\" "
"as being dangling, but there might be a whole deep and complex commit "
"history that was dropped.)"
msgstr ""
"これは見たままのことをします：つまり、dangling コミットが表示する コミット履"
"歴のうち、存在する全てのブランチとタグに含まれていないコミットを 表示します。"
"従って、紛失したそのコミットから到達可能な履歴を全て 得ることができます。 (そ"
"れは単に１つのコミットではないかもしれない点に注意してください： \"ラインの先"
"端(tip)\"を dangling として報告するだけであり、捨てられた深く複雑な コミット"
"の全てであるかもしれないからです)"

#. type: Plain text
#: ../../user-manual.txt:1664
#, fuzzy
msgid ""
"If you decide you want the history back, you can always create a new "
"reference pointing to it, for example, a new branch:"
msgstr ""
"履歴を元に戻したい時は、それを参照する新しいブランチを作成してください。 例え"
"ば、次のようにします："

#. type: delimited block -
#: ../../user-manual.txt:1667
#, fuzzy, no-wrap
msgid "$ git branch recovered-branch 7281251ddd\n"
msgstr "$ git branch recovered-branch 7281251ddd\n"

#. type: Plain text
#: ../../user-manual.txt:1671
#, fuzzy
msgid ""
"Other types of dangling objects (blobs and trees) are also possible, and "
"dangling objects can arise in other situations."
msgstr ""
"dangling オブジェクトの他の型 (blob や tree)も存在します。 それらは他の状況で"
"発生します。"

#. type: Title =
#: ../../user-manual.txt:1675
#, fuzzy, no-wrap
msgid "Sharing development with others"
msgstr "他のユーザと開発を共有する"

#. type: Title -
#: ../../user-manual.txt:1679
#, fuzzy, no-wrap
msgid "Getting updates with git pull"
msgstr "git pull を使用して更新する"

#. type: Plain text
#: ../../user-manual.txt:1684
#, fuzzy
msgid ""
"After you clone a repository and make a few changes of your own, you may "
"wish to check the original repository for updates and merge them into your "
"own work."
msgstr ""
"リポジトリを複製し、自分でソースを変更した後には、 元のリポジトリが更新されて"
"いるかを確認し、自分の作業ディレクトリ上に マージしたいと思うでしょう。"

#. type: Plain text
#: ../../user-manual.txt:1689
#, fuzzy
msgid ""
"We have already seen <<Updating-a-repository-With-git-fetch,how to keep "
"remote tracking branches up to date>> with linkgit:git-fetch[1], and how to "
"merge two branches.  So you can merge in changes from the original "
"repository's master branch with:"
msgstr ""
"既に linkgit:git-fetch[1] を用いて <<Updating-a-repository-With-git-fetch,外"
"部追跡ブランチを最新に保つ方法>> と２つのブランチをマージする方法を見てきまし"
"た。 従って、元のリポジトリのマスターブランチの変更をマージすることができま"
"す："

#. type: delimited block -
#: ../../user-manual.txt:1693
#, fuzzy, no-wrap
msgid ""
"$ git fetch\n"
"$ git merge origin/master\n"
msgstr ""
"$ git fetch\n"
"$ git merge origin/master\n"

#. type: Plain text
#: ../../user-manual.txt:1697
#, fuzzy
msgid ""
"However, the linkgit:git-pull[1] command provides a way to do this in one "
"step:"
msgstr ""
"しかし、linkgit:git-pull[1] コマンドを使用すれば、１回のステップで この操作を"
"行うことができます。"

#. type: delimited block -
#: ../../user-manual.txt:1700
#, fuzzy, no-wrap
msgid "$ git pull origin master\n"
msgstr "$ git pull origin master\n"

#. type: Plain text
#: ../../user-manual.txt:1705
#, fuzzy
msgid ""
"In fact, if you have \"master\" checked out, then by default \"git pull\" "
"merges from the HEAD branch of the origin repository.  So often you can "
"accomplish the above with just a simple"
msgstr ""
"実際のところ、あなたが \"master\" をチェックアウトしていたなら、\"git pull\" "
"はデフォルトでは 元のリポジトリの HEAD ブランチからマージを行ないます。従っ"
"て たいていは単に以下のようにするだけで、上記のことが出来ます。"

#. type: delimited block -
#: ../../user-manual.txt:1708
#, fuzzy, no-wrap
msgid "$ git pull\n"
msgstr "$ git pull\n"

#. type: Plain text
#: ../../user-manual.txt:1715
#, fuzzy
msgid ""
"More generally, a branch that is created from a remote branch will pull by "
"default from that branch.  See the descriptions of the branch.<name>.remote "
"and branch.<name>.merge options in linkgit:git-config[1], and the discussion "
"of the `--track` option in linkgit:git-checkout[1], to learn how to control "
"these defaults."
msgstr ""
"より一般的には、リモートブランチで作成されたブランチは、 デフォルトではそのブ"
"ランチから pull されます。 それらデフォルト値のコントロール方法を理解するに"
"は、 linkgit:git-config[1] の branch.<name>.remote と branch.<name>.merge の"
"オプション の記述と、linkgit:git-checkout[1] の `--track` オプションの説明を"
"参照してください。"

#. type: Plain text
#: ../../user-manual.txt:1719
#, fuzzy
msgid ""
"In addition to saving you keystrokes, \"git pull\" also helps you by "
"producing a default commit message documenting the branch and repository "
"that you pulled from."
msgstr ""
"さらに、キータイプを省略する為に \"git pull\" は pull 元のブランチとリポジト"
"リを説明したデフォルトのコミットメッセージを 生成してくれます。"

#. type: Plain text
#: ../../user-manual.txt:1723
#, fuzzy
msgid ""
"(But note that no such commit will be created in the case of a <<fast-"
"forwards,fast forward>>; instead, your branch will just be updated to point "
"to the latest commit from the upstream branch.)"
msgstr ""
"(しかし、<<fast-forwards,fast forward>> の場合にはそのようなコミットは 作成さ"
"れないことに注意してください；その代わり、あなたのブランチには 上流のブランチ"
"の最新のコミット位置に更新されます。)"

#. type: Plain text
#: ../../user-manual.txt:1727
#, fuzzy
msgid ""
"The `git pull` command can also be given \".\" as the \"remote\" repository, "
"in which case it just merges in a branch from the current repository; so the "
"commands"
msgstr ""
"`git pull` コマンドは \".\" を \"remote\" のリポジトリとして扱い、 その場合、"
"単に現在のリポジトリからブランチにマージを行います； 従って次のコマンド"

#. type: delimited block -
#: ../../user-manual.txt:1731
#, fuzzy, no-wrap
msgid ""
"$ git pull . branch\n"
"$ git merge branch\n"
msgstr ""
"$ git pull . branch\n"
"$ git merge branch\n"

#. type: Plain text
#: ../../user-manual.txt:1734
#, fuzzy
msgid "are roughly equivalent.  The former is actually very commonly used."
msgstr "は、大雑把に言えば同じです。前者は実際に広く一般に使われています。"

#. type: Title -
#: ../../user-manual.txt:1737
#, fuzzy, no-wrap
msgid "Submitting patches to a project"
msgstr "プロジェクトにパッチを投稿する"

#. type: Plain text
#: ../../user-manual.txt:1741
#, fuzzy
msgid ""
"If you just have a few changes, the simplest way to submit them may just be "
"to send them as patches in email:"
msgstr ""
"行なった変更を投稿する一番簡単な方法は email でパッチとして それらの変更を送"
"信することです。"

#. type: Plain text
#: ../../user-manual.txt:1743
#, fuzzy
msgid "First, use linkgit:git-format-patch[1]; for example:"
msgstr "初めに、linkgit:git-format-patch[1] を使用します。；例えば："

#. type: delimited block -
#: ../../user-manual.txt:1746
#, fuzzy, no-wrap
msgid "$ git format-patch origin\n"
msgstr "$ git format-patch origin\n"

#. type: Plain text
#: ../../user-manual.txt:1750
#, fuzzy
msgid ""
"will produce a numbered series of files in the current directory, one for "
"each patch in the current branch but not in origin/HEAD."
msgstr ""
"により、カレントディレクトリ内に番号付けされた一連のファイルが生成されます。 "
"それらはカレントブランチには含まれるが origin/HEAD には含まれないパッチです。"

#. type: Plain text
#: ../../user-manual.txt:1756
#, fuzzy
msgid ""
"You can then import these into your mail client and send them by hand.  "
"However, if you have a lot to send at once, you may prefer to use the "
"linkgit:git-send-email[1] script to automate the process.  Consult the "
"mailing list for your project first to determine how they prefer such "
"patches be handled."
msgstr ""
"これらをあなたのメールクライアントにインポートし、手作業でそれらを 送信できま"
"す。しかし、一度にたくさん送信したい時は、むしろ linkgit:git-send-email[1] ス"
"クリプトを使用してこの作業を自動化させたいでしょう。 メーリングリストで助言を"
"求め、あなたのプロジェクトがそのようなパッチを どのように扱うことを望むのか決"
"定すると良いでしょう。"

#. type: Title -
#: ../../user-manual.txt:1759
#, fuzzy, no-wrap
msgid "Importing patches to a project"
msgstr "プロジェクトにパッチをインポートする"

#. type: Plain text
#: ../../user-manual.txt:1765
#, fuzzy
msgid ""
"Git also provides a tool called linkgit:git-am[1] (am stands for \"apply "
"mailbox\"), for importing such an emailed series of patches.  Just save all "
"of the patch-containing messages, in order, into a single mailbox file, say "
"\"patches.mbox\", then run"
msgstr ""
"Git は linkgit:git-am[1] (am は \"apply mailbox(メールボックスを適用する\" と"
"いう意味です)  と呼ばれるツールを提供しており、このようなメールされた一連の"
"パッチを インポートすることができます。 パッチが含まれるメッセージ全部を順番"
"に１つの mailbox ファイル、\"patches.mbox\" と言います、 に保存してください。"
"そして、以下を実行します。"

#. type: delimited block -
#: ../../user-manual.txt:1768
#, fuzzy, no-wrap
msgid "$ git am -3 patches.mbox\n"
msgstr "$ git am -3 patches.mbox\n"

#. type: Plain text
#: ../../user-manual.txt:1775
#, fuzzy
msgid ""
"Git will apply each patch in order; if any conflicts are found, it will "
"stop, and you can fix the conflicts as described in \"<<resolving-a-merge,"
"Resolving a merge>>\".  (The \"-3\" option tells git to perform a merge; if "
"you would prefer it just to abort and leave your tree and index untouched, "
"you may omit that option.)"
msgstr ""
"Git は各パッチを順番に適用します；もしコンフリクトが見つかった場合は、 適用は"
"中止され、\"<<resolving-a-merge,マージの解決>>\" で説明されているように コン"
"フリクトを解決してください。( \"-3\" のオプションは git に マージすることを伝"
"えます；もし単純に変更を取り消し、 ツリーと索引を変更したくない場合"
"は、\"-3\" のオプションを省略してください。)"

#. type: Plain text
#: ../../user-manual.txt:1778
#, fuzzy
msgid ""
"Once the index is updated with the results of the conflict resolution, "
"instead of creating a new commit, just run"
msgstr ""
"コンフリクトを解消して索引を更新した後は、 新しいコミットを作成する変わりに、"

#. type: delimited block -
#: ../../user-manual.txt:1781
#, fuzzy, no-wrap
msgid "$ git am --resolved\n"
msgstr "$ git am --resolved\n"

#. type: Plain text
#: ../../user-manual.txt:1785
#, fuzzy
msgid ""
"and git will create the commit for you and continue applying the remaining "
"patches from the mailbox."
msgstr ""
"を実行すると、コミットが生成され、mailbox にある残りのパッチの適用が 再開され"
"ます。"

#. type: Plain text
#: ../../user-manual.txt:1789
#, fuzzy
msgid ""
"The final result will be a series of commits, one for each patch in the "
"original mailbox, with authorship and commit log message each taken from the "
"message containing each patch."
msgstr ""
"最終的には、一連のコミットとなり、一つ一つが元の mailbox の パッチに対応し、"
"各パッチに含まれているメッセージから取得された 著者とコミットログメッセージが"
"利用されます。"

#. type: Title -
#: ../../user-manual.txt:1792
#, fuzzy, no-wrap
msgid "Public git repositories"
msgstr "git リポジトリの公開"

#. type: Plain text
#: ../../user-manual.txt:1800
#, fuzzy
msgid ""
"Another way to submit changes to a project is to tell the maintainer of that "
"project to pull the changes from your repository using linkgit:git-pull[1].  "
"In the section \"<<getting-updates-With-git-pull, Getting updates with `git "
"pull`>>\" we described this as a way to get updates from the \"main\" "
"repository, but it works just as well in the other direction."
msgstr ""
"プロジェクトに変更を投稿するもう一つの方法はプロジェクトの管理者に あなたのリ"
"ポジトリから linkgit:git-pull[1] を使用して変更を pull してもらうことです。 "
"\"<<getting-updates-With-git-pull, `git pull` を使用して更新する>>\" のセク"
"ションで 我々は \"main\" リポジトリから更新を取得する方法を説明してきました"
"が、 逆の方向についても同じことができます。"

#. type: Plain text
#: ../../user-manual.txt:1805
#, fuzzy
msgid ""
"If you and the maintainer both have accounts on the same machine, then you "
"can just pull changes from each other's repositories directly; commands that "
"accept repository URLs as arguments will also accept a local directory name:"
msgstr ""
"あなたと管理者が同じマシン上にアカウントを持っている場合は、 互いのリポジトリ"
"から直接変更を pull することができます； リポジトリの URL を引数として受け取"
"ることのできるコマンドは ローカルのディレクトリ名もまた受け取ることができま"
"す："

#. type: delimited block -
#: ../../user-manual.txt:1809
#, fuzzy, no-wrap
msgid ""
"$ git clone /path/to/repository\n"
"$ git pull /path/to/other/repository\n"
msgstr ""
"$ git clone /path/to/repository\n"
"$ git pull /path/to/other/repository\n"

#. type: Plain text
#: ../../user-manual.txt:1812
#, fuzzy
msgid "or an ssh URL:"
msgstr "又は、ssh の URL :"

#. type: delimited block -
#: ../../user-manual.txt:1815
#, fuzzy, no-wrap
msgid "$ git clone ssh://yourhost/~you/repository\n"
msgstr "$ git clone ssh://yourhost/~you/repository\n"

#. type: Plain text
#: ../../user-manual.txt:1819
#, fuzzy
msgid ""
"For projects with few developers, or for synchronizing a few private "
"repositories, this may be all you need."
msgstr ""
"開発者の少ないプロジェクトや、少ないプライベートなリポジトリを同期 するような"
"場合、これらが必要な全てとなりえます。"

#. type: Plain text
#: ../../user-manual.txt:1824
#, fuzzy
msgid ""
"However, the more common way to do this is to maintain a separate public "
"repository (usually on a different host) for others to pull changes from.  "
"This is usually more convenient, and allows you to cleanly separate private "
"work in progress from publicly visible work."
msgstr ""
"しかしながら、より一般的にこれを行なうには、 他のユーザが変更を pull する為の"
"独立した公開リポジトリを(通常は別のホスト上に)  準備する必要があります。この"
"ほうが通常はより便利で、こうすることで 個人の作業中の変更と公開する変更とをき"
"れいに分けることができます。"

#. type: Plain text
#: ../../user-manual.txt:1831
#, fuzzy
msgid ""
"You will continue to do your day-to-day work in your personal repository, "
"but periodically \"push\" changes from your personal repository into your "
"public repository, allowing other developers to pull from that repository.  "
"So the flow of changes, in a situation where there is one other developer "
"with a public repository, looks like this:"
msgstr ""
"日々の作業は自分の個人用リポジトリ上で行い、 定期的に個人用リポジトリから公開"
"リポジトリに変更を \"push\" することで 他の開発者は公開リポジトリから変更を "
"pull できるようになります。 従って、変更のフローは、公開リポジトリを持つ別の"
"開発者が１人いるような場合には、 次のようになります："

#. type: Plain text
#: ../../user-manual.txt:1841
#, fuzzy, no-wrap
msgid ""
"                        you push\n"
"  your personal repo ------------------> your public repo\n"
"\t^                                     |\n"
"\t|                                     |\n"
"\t| you pull                            | they pull\n"
"\t|                                     |\n"
"\t|                                     |\n"
"        |               they push             V\n"
"  their public repo <------------------- their repo\n"
msgstr ""
"                              あなたが push\n"
" あなたの個人リポジトリ --------------------------> あなたの公開リポジトリ\n"
"                                                           |\n"
"       |                                                   |\n"
"       | あなたが pull                                     | 彼らが pull\n"
"       |                                                   |\n"
"       |                                                   |\n"
"       |                      彼らが push                  V\n"
" 彼らの公開リポジトリ <--------------------------- 彼らのリポジトリ\n"

#. type: Plain text
#: ../../user-manual.txt:1843
#, fuzzy
msgid "We explain how to do this in the following sections."
msgstr "次のセクションでどのようにこれを行なうかを説明します。"

#. type: Title ~
#: ../../user-manual.txt:1846
#, fuzzy, no-wrap
msgid "Setting up a public repository"
msgstr "公開リポジトリの設定"

#. type: Plain text
#: ../../user-manual.txt:1851
#, fuzzy
msgid ""
"Assume your personal repository is in the directory ~/proj.  We first create "
"a new clone of the repository and tell `git daemon` that it is meant to be "
"public:"
msgstr ""
"~/proj ディレクトリにあなたの個人用リポジトリがあるとします。 初めにリポジト"
"リのクローンを新規作成し、`git daemon` にそれを公開することを 伝えます；"

#. type: delimited block -
#: ../../user-manual.txt:1855
#, fuzzy, no-wrap
msgid ""
"$ git clone --bare ~/proj proj.git\n"
"$ touch proj.git/git-daemon-export-ok\n"
msgstr ""
"$ git clone --bare ~/proj proj.git\n"
"$ touch proj.git/git-daemon-export-ok\n"

#. type: Plain text
#: ../../user-manual.txt:1860
#, fuzzy
msgid ""
"The resulting directory proj.git contains a \"bare\" git repository--it is "
"just the contents of the \".git\" directory, without any files checked out "
"around it."
msgstr ""
"作成される ディレクトリ proj.git は \"裸の(bare)\" git リポジトリが含まれてい"
"ます。-- すなわち、\".git\" ディレクトリの中身だけが含まれ、チェックアウトさ"
"れたファイルは含みません。"

#. type: Plain text
#: ../../user-manual.txt:1864
#, fuzzy
msgid ""
"Next, copy proj.git to the server where you plan to host the public "
"repository.  You can use scp, rsync, or whatever is most convenient."
msgstr ""
"次に、proj.git を公開リポジトリのホストとするサーバにコピーします。 scp, "
"rsync その他使いやすいもの何を使っても良いです。"

#. type: Title ~
#: ../../user-manual.txt:1867
#, fuzzy, no-wrap
msgid "Exporting a git repository via the git protocol"
msgstr "git プロトコル経由での git リポジトリのエクスポート"

#. type: Plain text
#: ../../user-manual.txt:1870
#, fuzzy
msgid "This is the preferred method."
msgstr "これは好ましい方法です。"

#. type: Plain text
#: ../../user-manual.txt:1876
#, fuzzy
msgid ""
"If someone else administers the server, they should tell you what directory "
"to put the repository in, and what git:// URL it will appear at.  You can "
"then skip to the section \"<<pushing-changes-to-a-public-repository,Pushing "
"changes to a public repository>>\", below."
msgstr ""
"他のだれかがサーバ管理をしている場合は、その人に どこのディレクトリにリポジト"
"リを置くと、git:// URL のどこに現れるかを 教えてもらってください。その場合は"
"以下の説明はスキップして \"<<pushing-changes-to-a-public-repository,公開リポ"
"ジトリへ変更を push する>>\" のセクションに進んでください。"

#. type: Plain text
#: ../../user-manual.txt:1882
#, fuzzy
msgid ""
"Otherwise, all you need to do is start linkgit:git-daemon[1]; it will listen "
"on port 9418.  By default, it will allow access to any directory that looks "
"like a git directory and contains the magic file git-daemon-export-ok.  "
"Passing some directory paths as `git daemon` arguments will further restrict "
"the exports to those paths."
msgstr ""
"そうでない場合にあなたがすべき事は linkgit:git-daemon[1] を開始することだけで"
"す； このデーモンは 9418 ポートを使用します。デフォルトでは、git ディレクトリ"
"と思われ、 git-daemon-export-ok ファイルが存在する全てのディレクトリへのアク"
"セスを許可します。 `git daemon` の引数にディレクトリのパスを与えることで、 そ"
"れらパスに対してさらに制限をかけることができます。"

#. type: Plain text
#: ../../user-manual.txt:1886
#, fuzzy
msgid ""
"You can also run `git daemon` as an inetd service; see the linkgit:git-daemon"
"[1] man page for details.  (See especially the examples section.)"
msgstr ""
"`git daemon` は inetd サービスで動かすこともできます； 詳細は linkgit:git-"
"daemon[1] を参照してください。 (特に、例 のセクションを参照)"

#. type: Title ~
#: ../../user-manual.txt:1889
#, fuzzy, no-wrap
msgid "Exporting a git repository via http"
msgstr "http経由での git リポジトリのエクスポート"

#. type: Plain text
#: ../../user-manual.txt:1893
#, fuzzy
msgid ""
"The git protocol gives better performance and reliability, but on a host "
"with a web server set up, http exports may be simpler to set up."
msgstr ""
"git プロトコルはパフォーマンスと信頼性の面でより良いですが、 web サーバが設定"
"されているホストでは、http によるエクスポートの方がより簡単に設定 できるかも"
"しれません。"

#. type: Plain text
#: ../../user-manual.txt:1897
#, fuzzy
msgid ""
"All you need to do is place the newly created bare git repository in a "
"directory that is exported by the web server, and make some adjustments to "
"give web clients some extra information they need:"
msgstr ""
"その場合に行なうべきことは、web サーバが export できるディレクトリ内に 裸の "
"git リポジトリを新規作成し、webクライアントがアクセスする際に必要となる いく"
"つかの追加情報を設定することだけです。："

#. type: delimited block -
#: ../../user-manual.txt:1903
#, fuzzy, no-wrap
msgid ""
"$ mv proj.git /home/you/public_html/proj.git\n"
"$ cd proj.git\n"
"$ git --bare update-server-info\n"
"$ mv hooks/post-update.sample hooks/post-update\n"
msgstr ""
"$ mv proj.git /home/you/public_html/proj.git\n"
"$ cd proj.git\n"
"$ git --bare update-server-info\n"
"$ mv hooks/post-update.sample hooks/post-update\n"

#. type: Plain text
#: ../../user-manual.txt:1907
#, fuzzy
msgid ""
"(For an explanation of the last two lines, see linkgit:git-update-server-info"
"[1] and linkgit:githooks[5].)"
msgstr ""
"(最後の２行の説明は、linkgit:git-update-server-info[1] と、 linkgit:githooks"
"[5] のドキュメントを参照してください。)"

#. type: Plain text
#: ../../user-manual.txt:1910
#, fuzzy
msgid ""
"Advertise the URL of proj.git.  Anybody else should then be able to clone or "
"pull from that URL, for example with a command line like:"
msgstr ""
"proj.git の URL を通知してください。 他のユーザがそのURLから clone 又は pull "
"できるようになっているはずです。 例えば、次のように実行します："

#. type: delimited block -
#: ../../user-manual.txt:1913
#, fuzzy, no-wrap
msgid "$ git clone http://yourserver.com/~you/proj.git\n"
msgstr "$ git clone http://yourserver.com/~you/proj.git\n"

#. type: Plain text
#: ../../user-manual.txt:1919
#, fuzzy
msgid ""
"(See also link:howto/setup-git-server-over-http.txt[setup-git-server-over-"
"http] for a slightly more sophisticated setup using WebDAV which also allows "
"pushing over http.)"
msgstr ""
"(WebDAV を使用することで http で push を行なえるようにすることもできます。 詳"
"細は link:howto/setup-git-server-over-http.txt[setup-git-server-over-http] を"
"参照してください)"

#. type: Title ~
#: ../../user-manual.txt:1922
#, fuzzy, no-wrap
msgid "Pushing changes to a public repository"
msgstr "公開リポジトリへ変更を送信する"

#. type: Plain text
#: ../../user-manual.txt:1929
#, fuzzy
msgid ""
"Note that the two techniques outlined above (exporting via <<exporting-via-"
"http,http>> or <<exporting-via-git,git>>) allow other maintainers to fetch "
"your latest changes, but they do not allow write access, which you will need "
"to update the public repository with the latest changes created in your "
"private repository."
msgstr ""
"上記で説明した技術(<<exporting-via-http,http>> または <<exporting-via-git,"
"git>> 経由でのエクスポート) により、他の管理者があなたの最後の変更を取得でき"
"るようにはなりますが、 それらを編集することはできません。 個人用リポジトリで"
"行なった最新の変更を公開リポジトリに反映するには編集操作が必要です。"

#. type: Plain text
#: ../../user-manual.txt:1933
#, fuzzy
msgid ""
"The simplest way to do this is using linkgit:git-push[1] and ssh; to update "
"the remote branch named \"master\" with the latest state of your branch "
"named \"master\", run"
msgstr ""
"編集を行なう一番簡単な方法は linkgit:git-push[1] と ssh を使用する方法です； "
"あなたのブランチ \"master\" の最新の状態で、リモートブランチ \"master\" を更"
"新するには、"

#. type: delimited block -
#: ../../user-manual.txt:1936
#, fuzzy, no-wrap
msgid "$ git push ssh://yourserver.com/~you/proj.git master:master\n"
msgstr "$ git push ssh://yourserver.com/~you/proj.git master:master\n"

#. type: Plain text
#: ../../user-manual.txt:1939
#, fuzzy
msgid "or just"
msgstr "または単に"

#. type: delimited block -
#: ../../user-manual.txt:1942
#, fuzzy, no-wrap
msgid "$ git push ssh://yourserver.com/~you/proj.git master\n"
msgstr "$ git push ssh://yourserver.com/~you/proj.git master\n"

#. type: Plain text
#: ../../user-manual.txt:1947
#, fuzzy
msgid ""
"As with `git fetch`, `git push` will complain if this does not result in a "
"<<fast-forwards,fast forward>>; see the following section for details on "
"handling this case."
msgstr ""
"を実行します。 `git fetch` と同じように `git push` は <<fast-forwards,fast "
"forward>> されない場合に 文句を言います；このような場合の対応については次節を"
"参照してください。"

#. type: Plain text
#: ../../user-manual.txt:1953
#, fuzzy
msgid ""
"Note that the target of a \"push\" is normally a <<def_bare_repository,"
"bare>> repository.  You can also push to a repository that has a checked-out "
"working tree, but the working tree will not be updated by the push.  This "
"may lead to unexpected results if the branch you push to is the currently "
"checked-out branch!"
msgstr ""
"\"push\" のターゲットは通常は <<def_bare_repository,bare>> リポジトリであるこ"
"とに 注意してください。チェックアウトした作業ツリーを持つリポジトリに対して"
"も push することはできますが、push しても作業ツリーは更新されません。 その"
"為、push したブランチが現在チェックアウトしているブランチの場合、 予期しない"
"結果となります！"

#. type: Plain text
#: ../../user-manual.txt:1956
#, fuzzy
msgid ""
"As with `git fetch`, you may also set up configuration options to save "
"typing; so, for example, after"
msgstr ""
"`git fetch` と同じように、タイピングを節約する為のオプションを 設定することが"
"できます；例えば、次のようにします。"

#. type: delimited block -
#: ../../user-manual.txt:1962
#, fuzzy, no-wrap
msgid ""
"$ cat >>.git/config <<EOF\n"
"[remote \"public-repo\"]\n"
"\turl = ssh://yourserver.com/~you/proj.git\n"
"EOF\n"
msgstr ""
"$ cat >>.git/config <<EOF\n"
"[remote \"public-repo\"]\n"
"\turl = ssh://yourserver.com/~you/proj.git\n"
"EOF\n"

#. type: Plain text
#: ../../user-manual.txt:1965
#, fuzzy
msgid "you should be able to perform the above push with just"
msgstr "こうすることで次のように上記場所に push できるようになります。"

#. type: delimited block -
#: ../../user-manual.txt:1968
#, fuzzy, no-wrap
msgid "$ git push public-repo master\n"
msgstr "$ git push public-repo master\n"

#. type: Plain text
#: ../../user-manual.txt:1973
#, fuzzy
msgid ""
"See the explanations of the remote.<name>.url, branch.<name>.remote, and "
"remote.<name>.push options in linkgit:git-config[1] for details."
msgstr ""
"remote.<name>.url, branch.<name>.remote, remote.<name>.push の詳細は linkgit:"
"git-config[1] のオプションを参照してください。"

#. type: Title ~
#: ../../user-manual.txt:1976
#, fuzzy, no-wrap
msgid "What to do when a push fails"
msgstr "push に失敗した場合の対処"

#. type: Plain text
#: ../../user-manual.txt:1980
#, fuzzy
msgid ""
"If a push would not result in a <<fast-forwards,fast forward>> of the remote "
"branch, then it will fail with an error like:"
msgstr ""
"push の結果がリモートブランチの <<fast-forwards,fast forward>> とならない場"
"合、 次のようなエラーが発生して push は失敗します："

#. type: delimited block -
#: ../../user-manual.txt:1986
#, fuzzy, no-wrap
msgid ""
"error: remote 'refs/heads/master' is not an ancestor of\n"
" local  'refs/heads/master'.\n"
" Maybe you are not up-to-date and need to pull first?\n"
"error: failed to push to 'ssh://yourserver.com/~you/proj.git'\n"
msgstr ""
"error: remote 'refs/heads/master' is not an ancestor of\n"
" local  'refs/heads/master'.\n"
" Maybe you are not up-to-date and need to pull first?\n"
"error: failed to push to 'ssh://yourserver.com/~you/proj.git'\n"

#. type: Plain text
#: ../../user-manual.txt:1989
#, fuzzy
msgid "This can happen, for example, if you:"
msgstr "これは、例えば次のような場合におきます："

#. type: Plain text
#: ../../user-manual.txt:1991
#, fuzzy
msgid "use `git reset --hard` to remove already-published commits, or"
msgstr ""
"`git reset --hard` を使用し、すでに発行していたコミットを削除した場合、または"

#. type: Plain text
#: ../../user-manual.txt:1993
#, fuzzy
msgid ""
"use `git commit --amend` to replace already-published commits (as in "
"<<fixing-a-mistake-by-rewriting-history>>), or"
msgstr ""
"`git commit --amend` を使用し、すでに発行していたコミットを差し替えた場合 "
"（<<fixing-a-mistake-by-rewriting-history,履歴を再編集して間違いを訂正する>>"
"の手順で）、または"

#. type: Plain text
#: ../../user-manual.txt:1995
#, fuzzy
msgid ""
"use `git rebase` to rebase any already-published commits (as in <<using-git-"
"rebase>>)."
msgstr ""
"`git rebase` を使用し、すでに発行したコミットをリベースした場合 （<<using-"
"git-rebase,git rebase を使用する>> の手順で）"

#. type: Plain text
#: ../../user-manual.txt:1998
#, fuzzy
msgid ""
"You may force `git push` to perform the update anyway by preceding the "
"branch name with a plus sign:"
msgstr ""
"ブランチ名の前に＋記号を付けることで、強制的に `git push` を実行 することがで"
"きます："

#. type: delimited block -
#: ../../user-manual.txt:2001
#, fuzzy, no-wrap
msgid "$ git push ssh://yourserver.com/~you/proj.git +master\n"
msgstr "$ git push ssh://yourserver.com/~you/proj.git +master\n"

#. type: Plain text
#: ../../user-manual.txt:2007
#, fuzzy
msgid ""
"Normally whenever a branch head in a public repository is modified, it is "
"modified to point to a descendant of the commit that it pointed to before.  "
"By forcing a push in this situation, you break that convention.  (See "
"<<problems-With-rewriting-history>>.)"
msgstr ""
"通常、公開したリポジトリ内のブランチヘッドを修正した時はいつでも、 以前指し示"
"していた子孫のコミットを指し示すように変更されます。 このような場合に強制的"
"に push を行うと、規約を壊すことになります)  (<<problems-With-rewriting-"
"history,履歴の書き換えによって生じる問題>> を参照)"

#. type: Plain text
#: ../../user-manual.txt:2012
#, fuzzy
msgid ""
"Nevertheless, this is a common practice for people that need a simple way to "
"publish a work-in-progress patch series, and it is an acceptable compromise "
"as long as you warn other developers that this is how you intend to manage "
"the branch."
msgstr ""
"にもかかわらず、この方法は作業中の一連のパッチを簡単な方法で発行する必要があ"
"る場合に 一般に行われる方法であり、あなたがブランチを管理する方針を他の開発者"
"に 伝えている限りは許容できるでしょう。"

#. type: Plain text
#: ../../user-manual.txt:2019
#, fuzzy
msgid ""
"It's also possible for a push to fail in this way when other people have the "
"right to push to the same repository.  In that case, the correct solution is "
"to retry the push after first updating your work: either by a pull, or by a "
"fetch followed by a rebase; see the <<setting-up-a-shared-repository,next "
"section>> and linkgit:gitcvs-migration[7] for more."
msgstr ""
"push が失敗するもう一つのケースとして、同じリポジトリの push 権限を他の人に"
"も 与えている場合が考えられます。その場合、はじめに pull するか rebase によっ"
"て変更を取得した後に再度 push を試みてください； 詳しくは <<setting-up-a-"
"shared-repository,次の節>> と linkgit:gitcvs-migration[7] を参照してくださ"
"い。"

#. type: Title ~
#: ../../user-manual.txt:2022
#, fuzzy, no-wrap
msgid "Setting up a shared repository"
msgstr "共有リポジトリの設定"

#. type: Plain text
#: ../../user-manual.txt:2029
#, fuzzy
msgid ""
"Another way to collaborate is by using a model similar to that commonly used "
"in CVS, where several developers with special rights all push to and pull "
"from a single shared repository.  See linkgit:gitcvs-migration[7] for "
"instructions on how to set this up."
msgstr ""
"共同作業をする為のもう一つの方法は CVSで一般に使用されているのと同じような モ"
"デルを使用するやり方で、特別な権限を持った複数の開発者が １つの共有リポジトリ"
"に対する push と pull の全てを行なうやり方です。 この場合の設定方法について"
"は linkgit:gitcvs-migration[7] を 参照してください。"

#. type: Plain text
#: ../../user-manual.txt:2035
#, fuzzy
msgid ""
"However, while there is nothing wrong with git's support for shared "
"repositories, this mode of operation is not generally recommended, simply "
"because the mode of collaboration that git supports--by exchanging patches "
"and pulling from public repositories--has so many advantages over the "
"central shared repository:"
msgstr ""
"しかし、git は共有リポジトリを使った運用で何も問題を起こすことはありません"
"が、 この運用モードは一般には推奨されません。 それは単に、git がサポートする"
"共同開発のモード(つまり、パッチを交換し、 公開リポジトリからpull する方法)の"
"方が、中央リポジトリよりも多くの点で 利点があるからです："

#. type: Plain text
#: ../../user-manual.txt:2042
#, fuzzy
msgid ""
"Git's ability to quickly import and merge patches allows a single maintainer "
"to process incoming changes even at very high rates.  And when that becomes "
"too much, `git pull` provides an easy way for that maintainer to delegate "
"this job to other maintainers while still allowing optional review of "
"incoming changes."
msgstr ""
"Git はパッチのインポートとマージを高速に行なう能力をもっており、 とても頻繁に"
"変更が行なわれる場合でもそれらのマージを一人の管理者で 行なうことができます。"
"そして、変更が多すぎる場合でも `git pull` の機能により 寄せられる変更の任意レ"
"ビューを行なう一方で、変更の受け入れ作業を 他の管理者に容易に委任することがで"
"きます。"

#. type: Plain text
#: ../../user-manual.txt:2047
#, fuzzy
msgid ""
"Since every developer's repository has the same complete copy of the project "
"history, no repository is special, and it is trivial for another developer "
"to take over maintenance of a project, either by mutual agreement, or "
"because a maintainer becomes unresponsive or difficult to work with."
msgstr ""
"各開発者が専用のリポジトリを持ち、プロジェクトの履歴の完全なコピーを 持つこと"
"ができるので、どれが特別なリポジトリというわけではないので、 他の開発者がプロ"
"ジェクトのメンテナンスを引き継ぐのもとても簡単です。"

#. type: Plain text
#: ../../user-manual.txt:2050
#, fuzzy
msgid ""
"The lack of a central group of \"committers\" means there is less need for "
"formal decisions about who is \"in\" and who is \"out\"."
msgstr ""
"\"コミッター\"と呼ばれる中央のグループが存在しないことにより 誰が \"内側\" "
"で、だれが \"外側\" であるかに関する正式な決定を する必要がなくなります。"

#. type: Title ~
#: ../../user-manual.txt:2053
#, fuzzy, no-wrap
msgid "Allowing web browsing of a repository"
msgstr "リポジトリのWebブラウジング"

#. type: Plain text
#: ../../user-manual.txt:2058
#, fuzzy
msgid ""
"The gitweb cgi script provides users an easy way to browse your project's "
"files and history without having to install git; see the file gitweb/INSTALL "
"in the git source tree for instructions on setting it up."
msgstr ""
"gitweb という CGI スクリプトを使用すると、プロジェクトのファイルと履歴を git "
"をインストールすることなしに参照することができます： gitweb の設定方法は、"
"git のソースツリーに含まれる gitweb/INSTALL ファイルを参照してください。"

#. type: Title ~
#: ../../user-manual.txt:2065
#, fuzzy, no-wrap
msgid "Maintaining topic branches for a Linux subsystem maintainer"
msgstr "Linux のサブシステム管理者が topic ブランチを管理する方法"

#. type: Plain text
#: ../../user-manual.txt:2069
#, fuzzy
msgid ""
"This describes how Tony Luck uses git in his role as maintainer of the IA64 "
"architecture for the Linux kernel."
msgstr ""
"ここでは、Linux カーネルの IA64 アーキテクチャのメンテナンスを担当している "
"Tony Luck の git の利用方法を紹介します。"

#. type: Plain text
#: ../../user-manual.txt:2071
#, fuzzy
msgid "He uses two public branches:"
msgstr "彼は２つの公開リポジトリを使用します："

#. type: Plain text
#: ../../user-manual.txt:2076
#, fuzzy
msgid ""
"A \"test\" tree into which patches are initially placed so that they can get "
"some exposure when integrated with other ongoing development.  This tree is "
"available to Andrew for pulling into -mm whenever he wants."
msgstr ""
"\"test\" ツリーはパッチが最初に入れられる場所です。 ここで他の進行中の開発と"
"一緒に統合されて公表されます。 このツリーは Andrew がいつでも -mm に pull で"
"きるようにする為のものです。(訳注：\"-mm\" とは Andrew Morton によってリリー"
"スされる実験的なカーネルパッチ群のこと。-mm に入って価値を証明されると Linus "
"のツリーに反映される)"

#. type: Plain text
#: ../../user-manual.txt:2080
#, fuzzy
msgid ""
"A \"release\" tree into which tested patches are moved for final sanity "
"checking, and as a vehicle to send them upstream to Linus (by sending him a "
"\"please pull\" request.)"
msgstr ""
"\"release\" ツリーはテストされたパッチが最終的に健全であることが確認された後"
"に 移動され、Linus に変更を送付する乗り物として使用されます。(Linus に このツ"
"リーを \"pull してください\" というリクエストをします)"

#. type: Plain text
#: ../../user-manual.txt:2083
#, fuzzy
msgid ""
"He also uses a set of temporary branches (\"topic branches\"), each "
"containing a logical grouping of patches."
msgstr ""
"彼は他にも一時的なブランチ(\"topic branches\")を使用します。 それぞれのブラン"
"チはパッチの論理的なグループを含んでいます。"

#. type: Plain text
#: ../../user-manual.txt:2086
#, fuzzy
msgid ""
"To set this up, first create your work tree by cloning Linus's public tree:"
msgstr ""
"この設定をする為には、最初に Linus の公開ツリーを複製することで 作業ツリーを"
"作成します："

#. type: delimited block -
#: ../../user-manual.txt:2090
#, fuzzy, no-wrap
msgid ""
"$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git work\n"
"$ cd work\n"
msgstr ""
"$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git work\n"
"$ cd work\n"

#. type: Plain text
#: ../../user-manual.txt:2097
#, fuzzy
msgid ""
"Linus's tree will be stored in the remote branch named origin/master, and "
"can be updated using linkgit:git-fetch[1]; you can track other public trees "
"using linkgit:git-remote[1] to set up a \"remote\" and linkgit:git-fetch[1] "
"to keep them up-to-date; see <<repositories-and-branches>>."
msgstr ""
"Linus のツリーは origin/master という名前のリモートブランチに格納され、 "
"linkgit:git-fetch[1] を使用して更新できます；他の公開ツリーも linkgit:git-"
"remote[1] を使用して \"remote\" を設定し linkgit:git-fetch[1] で それらを最新"
"に保ちます；<<repositories-and-branches>> を参照してください。"

#. type: Plain text
#: ../../user-manual.txt:2102
#, fuzzy
msgid ""
"Now create the branches in which you are going to work; these start out at "
"the current tip of origin/master branch, and should be set up (using the --"
"track option to linkgit:git-branch[1]) to merge changes in from Linus by "
"default."
msgstr ""
"さて、あなたが作業する為のブランチを作成しました； このブランチは origin/"
"master ブランチの現在の先端から開始していて、 (linkgit:git-branch[1] の --"
"track オプションを使用して)  デフォルトでは Linus からの変更をマージする設定"
"にすべきです。"

#. type: delimited block -
#: ../../user-manual.txt:2106
#, fuzzy, no-wrap
msgid ""
"$ git branch --track test origin/master\n"
"$ git branch --track release origin/master\n"
msgstr ""
"$ git branch --track test origin/master\n"
"$ git branch --track release origin/master\n"

#. type: Plain text
#: ../../user-manual.txt:2109
#, fuzzy
msgid "These can be easily kept up to date using linkgit:git-pull[1]."
msgstr "これらは linkgit:git-pull[1] を用いて簡単に最新に保つことができます。"

#. type: delimited block -
#: ../../user-manual.txt:2113
#, fuzzy, no-wrap
msgid ""
"$ git checkout test && git pull\n"
"$ git checkout release && git pull\n"
msgstr ""
"$ git checkout test && git pull\n"
"$ git checkout release && git pull\n"

#. type: Plain text
#: ../../user-manual.txt:2122
#, fuzzy
msgid ""
"Important note! If you have any local changes in these branches, then this "
"merge will create a commit object in the history (with no local changes git "
"will simply do a \"Fast forward\" merge).  Many people dislike the \"noise\" "
"that this creates in the Linux history, so you should avoid doing this "
"capriciously in the \"release\" branch, as these noisy commits will become "
"part of the permanent history when you ask Linus to pull from the release "
"branch."
msgstr ""
"重要な注意点！ これらのブランチにローカルな変更を加えると、 このマージは履歴"
"内にコミットオブジェクトを生成します (ローカルで 変更を加えていない時は単に "
"\"Fast forward\" でマージされます)。 多くの人は Linux の履歴にこれが作成され"
"ることを \"ノイズ\" として嫌います。 その為 \"release\" ブランチにこの気まぐ"
"れが行なわれるのを避けるべきです。 これらノイズとなるコミットはあなたが "
"Linus にリリースブランチへの pull を依頼するときに恒久的な履歴の一部になって"
"しまいます。"

#. type: Plain text
#: ../../user-manual.txt:2126
#, fuzzy
msgid ""
"A few configuration variables (see linkgit:git-config[1]) can make it easy "
"to push both branches to your public tree.  (See <<setting-up-a-public-"
"repository>>.)"
msgstr ""
"幾つかの設定変数(linkgit:git-config[1] 参照)は 両方のブランチをあなたの公開ツ"
"リーに push するのを容易にしてくれます。 (<<setting-up-a-public-repository>> "
"参照。)"

#. type: delimited block -
#: ../../user-manual.txt:2134
#, fuzzy, no-wrap
msgid ""
"$ cat >> .git/config <<EOF\n"
"[remote \"mytree\"]\n"
"\turl =  master.kernel.org:/pub/scm/linux/kernel/git/aegl/linux-2.6.git\n"
"\tpush = release\n"
"\tpush = test\n"
"EOF\n"
msgstr ""
"$ cat >> .git/config <<EOF\n"
"[remote \"mytree\"]\n"
"\turl =  master.kernel.org:/pub/scm/linux/kernel/git/aegl/linux-2.6.git\n"
"\tpush = release\n"
"\tpush = test\n"
"EOF\n"

#. type: Plain text
#: ../../user-manual.txt:2138
#, fuzzy
msgid ""
"Then you can push both the test and release trees using linkgit:git-push[1]:"
msgstr ""
"上記により test と release の両方のツリーに linkgit:git-push[1] を 使用して "
"push することができるようになります："

#. type: delimited block -
#: ../../user-manual.txt:2141
#, fuzzy, no-wrap
msgid "$ git push mytree\n"
msgstr "$ git push mytree\n"

#. type: Plain text
#: ../../user-manual.txt:2144
#, fuzzy
msgid "or push just one of the test and release branches using:"
msgstr "あるいは、test と release のブランチの一方にだけ push する場合は："

#. type: delimited block -
#: ../../user-manual.txt:2147
#, fuzzy, no-wrap
msgid "$ git push mytree test\n"
msgstr "$ git push mytree test\n"

#. type: Plain text
#: ../../user-manual.txt:2150 ../../user-manual.txt:2208
#: ../../user-manual.txt:3574
#, fuzzy
msgid "or"
msgstr ""
"#-#-#-#-#  translated/user-manual.txt:2107  #-#-#-#-#\n"
"あるいは、\n"
"#-#-#-#-#  translated/user-manual.txt:2170  #-#-#-#-#\n"
"あるいは\n"
"#-#-#-#-#  translated/user-manual.txt:3506  #-#-#-#-#\n"
"または"

#. type: delimited block -
#: ../../user-manual.txt:2153
#, fuzzy, no-wrap
msgid "$ git push mytree release\n"
msgstr "$ git push mytree release\n"

#. type: Plain text
#: ../../user-manual.txt:2159
#, fuzzy
msgid ""
"Now to apply some patches from the community.  Think of a short snappy name "
"for a branch to hold this patch (or related group of patches), and create a "
"new branch from the current tip of Linus's branch:"
msgstr ""
"さて、コミュニティからの幾つかのパッチを適用することを考えます。 このパッチ"
"(あるいは関連するパッチグループ)を保管するブランチに 短く分かり易い名前を付け"
"ます。"

#. type: delimited block -
#: ../../user-manual.txt:2162
#, fuzzy, no-wrap
msgid "$ git checkout -b speed-up-spinlocks origin\n"
msgstr "$ git checkout -b speed-up-spinlocks origin\n"

#. type: Plain text
#: ../../user-manual.txt:2167
#, fuzzy
msgid ""
"Now you apply the patch(es), run some tests, and commit the change(s).  If "
"the patch is a multi-part series, then you should apply each as a separate "
"commit to this branch."
msgstr ""
"パッチを適用し、幾つかのテストを実行し、変更をコミットします。 パッチが複数の"
"パートから構成される場合は、それぞれを分割した コミットとしてこのブランチに適"
"用すべきです。"

#. type: delimited block -
#: ../../user-manual.txt:2170
#, fuzzy, no-wrap
msgid "$ ... patch ... test  ... commit [ ... patch ... test ... commit ]*\n"
msgstr "$ ... patch ... test  ... commit [ ... patch ... test ... commit ]*\n"

#. type: Plain text
#: ../../user-manual.txt:2174
#, fuzzy
msgid ""
"When you are happy with the state of this change, you can pull it into the "
"\"test\" branch in preparation to make it public:"
msgstr ""
"この変更状態が良好なら、\"test\" ブランチに pull し 公開する準備をします。"

#. type: delimited block -
#: ../../user-manual.txt:2177
#, fuzzy, no-wrap
msgid "$ git checkout test && git pull . speed-up-spinlocks\n"
msgstr "$ git checkout test && git pull . speed-up-spinlocks\n"

#. type: Plain text
#: ../../user-manual.txt:2181
#, fuzzy
msgid ""
"It is unlikely that you would have any conflicts here ... but you might if "
"you spent a while on this step and had also pulled new versions from "
"upstream."
msgstr ""
"ここではコンフリクトは発生しそうにありません...しかし この段階までの間にしば"
"らくの時間がかかり、上流から新しいバージョンを pull しているかもしれません。"

#. type: Plain text
#: ../../user-manual.txt:2186
#, fuzzy
msgid ""
"Some time later when enough time has passed and testing done, you can pull "
"the same branch into the \"release\" tree ready to go upstream.  This is "
"where you see the value of keeping each patch (or patch series) in its own "
"branch.  It means that the patches can be moved into the \"release\" tree in "
"any order."
msgstr ""
"しばらく後に十分な時間が経ちテストが完了したときに、 同じブランチを \"release"
"\" ツリーに pull し、上流に向かう準備をします。 これは、それぞれのパッチ(ある"
"いは一連のパッチ)をパッチ用のブランチ に留めておくありがたみを理解する場面で"
"す。この作業は一連のパッチが \"release\" ツリーへ任意の順番で移動できることを"
"意味します。 (訳注: 先を読めばわかりますが、ブランチを作って、パッチを適用す"
"ると、パッチ群 のテストをブランチごとに並行して行なうことができます。そして、"
"テストが完了したパッチ のブランチから順に release ツリーへ移動することができ"
"ます。そして、各パッチ用のブラ ンチの状況も簡単に把握できます。)"

#. type: delimited block -
#: ../../user-manual.txt:2189
#, fuzzy, no-wrap
msgid "$ git checkout release && git pull . speed-up-spinlocks\n"
msgstr "$ git checkout release && git pull . speed-up-spinlocks\n"

#. type: Plain text
#: ../../user-manual.txt:2195
#, fuzzy
msgid ""
"After a while, you will have a number of branches, and despite the well "
"chosen names you picked for each of them, you may forget what they are for, "
"or what status they are in.  To get a reminder of what changes are in a "
"specific branch, use:"
msgstr ""
"その後、たくさんのブランチが作成され、それらブランチの名前を 適切に指定してい"
"たとしても、それらが何であるか又は何が含まれているかを 忘れてしまうかもしれま"
"せん。特定のブランチでどんな変更が行なわれているかを 思い出すには、次のように"
"します："

#. type: delimited block -
#: ../../user-manual.txt:2198
#, fuzzy, no-wrap
msgid "$ git log linux..branchname | git shortlog\n"
msgstr "$ git log linux..branchname | git shortlog\n"

#. type: Plain text
#: ../../user-manual.txt:2202
#, fuzzy
msgid ""
"To see whether it has already been merged into the test or release branches, "
"use:"
msgstr ""
"test または release ブランチに既にマージされたかどうかは 次のようにして確認し"
"ます："

#. type: delimited block -
#: ../../user-manual.txt:2205
#, fuzzy, no-wrap
msgid "$ git log test..branchname\n"
msgstr "$ git log test..branchname\n"

#. type: delimited block -
#: ../../user-manual.txt:2211
#, fuzzy, no-wrap
msgid "$ git log release..branchname\n"
msgstr "$ git log release..branchname\n"

#. type: Plain text
#: ../../user-manual.txt:2215
#, fuzzy
msgid ""
"(If this branch has not yet been merged, you will see some log entries.  If "
"it has been merged, then there will be no output.)"
msgstr ""
"(このブランチがまだマージされていない場合、いくつかのログエントリが表示されま"
"す。 既にマージされている場合は、何も出力されません。)"

#. type: Plain text
#: ../../user-manual.txt:2220
#, fuzzy
msgid ""
"Once a patch completes the great cycle (moving from test to release, then "
"pulled by Linus, and finally coming back into your local \"origin/master\" "
"branch), the branch for this change is no longer needed.  You detect this "
"when the output from:"
msgstr ""
"パッチがこの大きなサイクル(test から release に移動し、 Linus に pull され、"
"最終的に自身の \"origin/master\" ブランチに返却する流れ)  を完遂すると変更に"
"対するブランチは不要になります。 このことは次の出力が空であることを確認するこ"
"とで検出できます："

#. type: delimited block -
#: ../../user-manual.txt:2223
#, fuzzy, no-wrap
msgid "$ git log origin..branchname\n"
msgstr "$ git log origin..branchname\n"

#. type: Plain text
#: ../../user-manual.txt:2226
#, fuzzy
msgid "is empty.  At this point the branch can be deleted:"
msgstr "この時点でブランチは削除することができます："

#. type: delimited block -
#: ../../user-manual.txt:2229
#, fuzzy, no-wrap
msgid "$ git branch -d branchname\n"
msgstr "$ git branch -d branchname\n"

#. type: Plain text
#: ../../user-manual.txt:2235
#, fuzzy
msgid ""
"Some changes are so trivial that it is not necessary to create a separate "
"branch and then merge into each of the test and release branches.  For these "
"changes, just apply directly to the \"release\" branch, and then merge that "
"into the \"test\" branch."
msgstr ""
"幾つかの変更は自明で、分割したブランチを作成し test と release ブランチに そ"
"れぞれマージする必要がない場合もあります。 そういった変更は直接 \"release\" "
"ブランチに適用し、 \"test\" ブランチにマージします。"

#. type: Plain text
#: ../../user-manual.txt:2238
#, fuzzy
msgid ""
"To create diffstat and shortlog summaries of changes to include in a "
"\"please pull\" request to Linus you can use:"
msgstr ""
"Linus に送る \"pull してください\" のリクエストに含める diff 状態と 変更の短"
"いサマリを作成するには、次のようにします："

#. type: delimited block -
#: ../../user-manual.txt:2241
#, fuzzy, no-wrap
msgid "$ git diff --stat origin..release\n"
msgstr "$ git diff --stat origin..release\n"

#. type: Plain text
#: ../../user-manual.txt:2244
#, fuzzy
msgid "and"
msgstr "そして"

#. type: delimited block -
#: ../../user-manual.txt:2247
#, fuzzy, no-wrap
msgid "$ git log -p origin..release | git shortlog\n"
msgstr "$ git log -p origin..release | git shortlog\n"

#. type: Plain text
#: ../../user-manual.txt:2250
#, fuzzy
msgid "Here are some of the scripts that simplify all this even further."
msgstr "以下はこれら全てをさらに単純化するスクリプトです。"

#. type: Title ====
#: ../../user-manual.txt:2252
#, fuzzy, no-wrap
msgid "update script"
msgstr "update script"

#. type: delimited block -
#: ../../user-manual.txt:2256
#, fuzzy
msgid ""
"# Update a branch in my GIT tree.  If the branch to be updated # is origin, "
"then pull from kernel.org.  Otherwise merge # origin/master branch into test|"
"release branch"
msgstr ""
"# GIT ツリーのブランチを更新する。更新すべきブランチが # origin の場合、"
"kernel.org から pull する。そうでない時は # origin/master ブランチを test|"
"release ブランチにマージします。"

#. type: delimited block -
#: ../../user-manual.txt:2275
#, fuzzy, no-wrap
msgid ""
"case \"$1\" in\n"
"test|release)\n"
"\tgit checkout $1 && git pull . origin\n"
"\t;;\n"
"origin)\n"
"\tbefore=$(git rev-parse refs/remotes/origin/master)\n"
"\tgit fetch origin\n"
"\tafter=$(git rev-parse refs/remotes/origin/master)\n"
"\tif [ $before != $after ]\n"
"\tthen\n"
"\t\tgit log $before..$after | git shortlog\n"
"\tfi\n"
"\t;;\n"
"*)\n"
"\techo \"Usage: $0 origin|test|release\" 1>&2\n"
"\texit 1\n"
"\t;;\n"
"esac\n"
msgstr ""
"case \"$1\" in\n"
"test|release)\n"
"\tgit checkout $1 && git pull . origin\n"
"\t;;\n"
"origin)\n"
"\tbefore=$(git rev-parse refs/remotes/origin/master)\n"
"\tgit fetch origin\n"
"\tafter=$(git rev-parse refs/remotes/origin/master)\n"
"\tif [ $before != $after ]\n"
"\tthen\n"
"\t\tgit log $before..$after | git shortlog\n"
"\tfi\n"
"\t;;\n"
"*)\n"
"\techo \"Usage: $0 origin|test|release\" 1>&2\n"
"\texit 1\n"
"\t;;\n"
"esac\n"

#. type: Title ====
#: ../../user-manual.txt:2278
#, fuzzy, no-wrap
msgid "merge script"
msgstr "merge script"

#. type: delimited block -
#: ../../user-manual.txt:2280
#, fuzzy
msgid "# Merge a branch into either the test or release branch"
msgstr "# ブランチを test または release ブランチにマージ"

#. type: delimited block -
#: ../../user-manual.txt:2282
#, fuzzy
msgid "pname=$0"
msgstr "pname=$0"

#. type: delimited block -
#: ../../user-manual.txt:2288
#, fuzzy, no-wrap
msgid ""
"usage()\n"
"{\n"
"\techo \"Usage: $pname branch test|release\" 1>&2\n"
"\texit 1\n"
"}\n"
msgstr ""
"usage()\n"
"{\n"
"\techo \"Usage: $pname branch test|release\" 1>&2\n"
"\texit 1\n"
"}\n"

#. type: delimited block -
#: ../../user-manual.txt:2293
#, fuzzy, no-wrap
msgid ""
"git show-ref -q --verify -- refs/heads/\"$1\" || {\n"
"\techo \"Can't see branch <$1>\" 1>&2\n"
"\tusage\n"
"}\n"
msgstr ""
"git show-ref -q --verify -- refs/heads/\"$1\" || {\n"
"\techo \"Can't see branch <$1>\" 1>&2\n"
"\tusage\n"
"}\n"

#. type: delimited block -
#: ../../user-manual.txt:2307
#, fuzzy, no-wrap
msgid ""
"case \"$2\" in\n"
"test|release)\n"
"\tif [ $(git log $2..$1 | wc -c) -eq 0 ]\n"
"\tthen\n"
"\t\techo $1 already merged into $2 1>&2\n"
"\t\texit 1\n"
"\tfi\n"
"\tgit checkout $2 && git pull . $1\n"
"\t;;\n"
"*)\n"
"\tusage\n"
"\t;;\n"
"esac\n"
msgstr ""
"case \"$2\" in\n"
"test|release)\n"
"\tif [ $(git log $2..$1 | wc -c) -eq 0 ]\n"
"\tthen\n"
"\t\techo $1 already merged into $2 1>&2\n"
"\t\texit 1\n"
"\tfi\n"
"\tgit checkout $2 && git pull . $1\n"
"\t;;\n"
"*)\n"
"\tusage\n"
"\t;;\n"
"esac\n"

#. type: Title ====
#: ../../user-manual.txt:2310
#, fuzzy, no-wrap
msgid "status script"
msgstr "status script"

#. type: delimited block -
#: ../../user-manual.txt:2312
#, fuzzy
msgid "# report on status of my ia64 GIT tree"
msgstr "# ia64 GIT ツリーの状態をレポートする"

#. type: delimited block -
#: ../../user-manual.txt:2316
#, fuzzy
msgid "gb=$(tput setab 2)  rb=$(tput setab 1)  restore=$(tput setab 9)"
msgstr "gb=$(tput setab 2)  rb=$(tput setab 1)  restore=$(tput setab 9)"

#. type: delimited block -
#: ../../user-manual.txt:2322
#, fuzzy, no-wrap
msgid ""
"if [ `git rev-list test..release | wc -c` -gt 0 ]\n"
"then\n"
"\techo $rb Warning: commits in release that are not in test $restore\n"
"\tgit log test..release\n"
"fi\n"
msgstr ""
"if [ `git rev-list test..release | wc -c` -gt 0 ]\n"
"then\n"
"\techo $rb Warning: commits in release that are not in test $restore\n"
"\tgit log test..release\n"
"fi\n"

#. type: delimited block -
#: ../../user-manual.txt:2329
#, fuzzy, no-wrap
msgid ""
"for branch in `git show-ref --heads | sed 's|^.*/||'`\n"
"do\n"
"\tif [ $branch = test -o $branch = release ]\n"
"\tthen\n"
"\t\tcontinue\n"
"\tfi\n"
msgstr ""
"for branch in `git show-ref --heads | sed 's|^.*/||'`\n"
"do\n"
"\tif [ $branch = test -o $branch = release ]\n"
"\tthen\n"
"\t\tcontinue\n"
"\tfi\n"

#. type: delimited block -
#: ../../user-manual.txt:2358
#, fuzzy, no-wrap
msgid ""
"\techo -n $gb ======= $branch ====== $restore \" \"\n"
"\tstatus=\n"
"\tfor ref in test release origin/master\n"
"\tdo\n"
"\t\tif [ `git rev-list $ref..$branch | wc -c` -gt 0 ]\n"
"\t\tthen\n"
"\t\t\tstatus=$status${ref:0:1}\n"
"\t\tfi\n"
"\tdone\n"
"\tcase $status in\n"
"\ttrl)\n"
"\t\techo $rb Need to pull into test $restore\n"
"\t\t;;\n"
"\trl)\n"
"\t\techo \"In test\"\n"
"\t\t;;\n"
"\tl)\n"
"\t\techo \"Waiting for linus\"\n"
"\t\t;;\n"
"\t\"\")\n"
"\t\techo $rb All done $restore\n"
"\t\t;;\n"
"\t*)\n"
"\t\techo $rb \"<$status>\" $restore\n"
"\t\t;;\n"
"\tesac\n"
"\tgit log origin/master..$branch | git shortlog\n"
"done\n"
msgstr ""
"\techo -n $gb ======= $branch ====== $restore \" \"\n"
"\tstatus=\n"
"\tfor ref in test release origin/master\n"
"\tdo\n"
"\t\tif [ `git rev-list $ref..$branch | wc -c` -gt 0 ]\n"
"\t\tthen\n"
"\t\t\tstatus=$status${ref:0:1}\n"
"\t\tfi\n"
"\tdone\n"
"\tcase $status in\n"
"\ttrl)\n"
"\t\techo $rb Need to pull into test $restore\n"
"\t\t;;\n"
"\trl)\n"
"\t\techo \"In test\"\n"
"\t\t;;\n"
"\tl)\n"
"\t\techo \"Waiting for linus\"\n"
"\t\t;;\n"
"\t\"\")\n"
"\t\techo $rb All done $restore\n"
"\t\t;;\n"
"\t*)\n"
"\t\techo $rb \"<$status>\" $restore\n"
"\t\t;;\n"
"\tesac\n"
"\tgit log origin/master..$branch | git shortlog\n"
"done\n"

#. type: Title =
#: ../../user-manual.txt:2363
#, fuzzy, no-wrap
msgid "Rewriting history and maintaining patch series"
msgstr "履歴を再編集し、一連のパッチを管理する"

#. type: Plain text
#: ../../user-manual.txt:2368
#, fuzzy
msgid ""
"Normally commits are only added to a project, never taken away or replaced.  "
"Git is designed with this assumption, and violating it will cause git's "
"merge machinery (for example) to do the wrong thing."
msgstr ""
"通常コミットはプロジェクトに追加されるのみで、削除したり置き換えられる ことは"
"ありません。Git はこの仮定をもとにデザインされており、 この仮定を破ると git "
"のマージ装置は(例えば)間違ったことをしてしまいます。"

#. type: Plain text
#: ../../user-manual.txt:2371
#, fuzzy
msgid ""
"However, there is a situation in which it can be useful to violate this "
"assumption."
msgstr "しかし、この仮定を破ると便利なシチュエーションもあります。"

#. type: Title -
#: ../../user-manual.txt:2374
#, fuzzy, no-wrap
msgid "Creating the perfect patch series"
msgstr "一連の完全なパッチの作成"

#. type: Plain text
#: ../../user-manual.txt:2380
#, fuzzy
msgid ""
"Suppose you are a contributor to a large project, and you want to add a "
"complicated feature, and to present it to the other developers in a way that "
"makes it easy for them to read your changes, verify that they are correct, "
"and understand why you made each change."
msgstr ""
"あなたが大きなプロジェクトのコントリビュータであったと仮定し、 複雑な変更を加"
"えたとします。あなたはそれを他の開発者に公表する為、 その変更を読みやすい手順"
"にし、それが正しいとわかることを証明し、 各変更を行なった理由がわかるようにし"
"たいとします。"

#. type: Plain text
#: ../../user-manual.txt:2383
#, fuzzy
msgid ""
"If you present all of your changes as a single patch (or commit), they may "
"find that it is too much to digest all at once."
msgstr ""
"１つのパッチ(あるいはコミット)として変更全てを公表すると、 大き過ぎる為一度に"
"全てを消化できません。"

#. type: Plain text
#: ../../user-manual.txt:2386
#, fuzzy
msgid ""
"If you present them with the entire history of your work, complete with "
"mistakes, corrections, and dead ends, they may be overwhelmed."
msgstr ""
"あなたの作業の完全な履歴を公表するとなると、間違いや訂正、意味無く終わったも"
"の などが全て含まれ、冗長すぎてしまいます。"

#. type: Plain text
#: ../../user-manual.txt:2388
#, fuzzy
msgid "So the ideal is usually to produce a series of patches such that:"
msgstr "従って、通常は次のような一連のパッチを生成するのが理想的です："

#. type: Plain text
#: ../../user-manual.txt:2390
#, fuzzy
msgid "Each patch can be applied in order."
msgstr "各パッチが順番に適用できる。"

#. type: Plain text
#: ../../user-manual.txt:2393
#, fuzzy
msgid ""
"Each patch includes a single logical change, together with a message "
"explaining the change."
msgstr ""
"各パッチは１つの論理的な変更を含み、その変更を説明する メッセージを一緒に含ん"
"でいる。"

#. type: Plain text
#: ../../user-manual.txt:2397
#, fuzzy
msgid ""
"No patch introduces a regression: after applying any initial part of the "
"series, the resulting project still compiles and works, and has no bugs that "
"it didn't have before."
msgstr ""
"回帰を持ち込むようなパッチがないこと：一連のパッチの最初の部分だけを 適用した"
"場合でも、コンパイルがとおり、動作し、過去に存在しなかったバグが 持ち込まれな"
"い。"

#. type: Plain text
#: ../../user-manual.txt:2400
#, fuzzy
msgid ""
"The complete series produces the same end result as your own (probably much "
"messier!) development process did."
msgstr ""
"一連のパッチを完全に適用すると、最終結果があなた自身が行なった (おそらく散ら"
"かっている!)開発作業の結果と一致する。"

#. type: Plain text
#: ../../user-manual.txt:2404
#, fuzzy
msgid ""
"We will introduce some tools that can help you do this, explain how to use "
"them, and then explain some of the problems that can arise because you are "
"rewriting history."
msgstr ""
"これら作業の手助けをする幾つかのツールを紹介し、 それらの使い方を説明し、履歴"
"を再編集することにより発生する問題の幾つかを 説明します"

#. type: Title -
#: ../../user-manual.txt:2407
#, fuzzy, no-wrap
msgid "Keeping a patch series up to date using git rebase"
msgstr "git rebase を使用して一連のパッチを最新に保つ"

#. type: Plain text
#: ../../user-manual.txt:2411
#, fuzzy
msgid ""
"Suppose that you create a branch \"mywork\" on a remote-tracking branch "
"\"origin\", and create some commits on top of it:"
msgstr ""
"リモート追跡ブランチ \"origin\" の上にブランチ \"mywork\" を作成し、 幾つかコ"
"ミットを作成したとします："

#. type: delimited block -
#: ../../user-manual.txt:2419
#, fuzzy, no-wrap
msgid ""
"$ git checkout -b mywork origin\n"
"$ vi file.txt\n"
"$ git commit\n"
"$ vi otherfile.txt\n"
"$ git commit\n"
"...\n"
msgstr ""
"$ git checkout -b mywork origin\n"
"$ vi file.txt\n"
"$ git commit\n"
"$ vi otherfile.txt\n"
"$ git commit\n"
"...\n"

#. type: Plain text
#: ../../user-manual.txt:2423
#, fuzzy
msgid ""
"You have performed no merges into mywork, so it is just a simple linear "
"sequence of patches on top of \"origin\":"
msgstr ""
"mywork にマージをしていないので、変更は \"origin\" から単純に並行に 行なわれ"
"ています。"

#. type: delimited block .
#: ../../user-manual.txt:2428
#, fuzzy, no-wrap
msgid ""
" o--o--o <-- origin\n"
"        \\\n"
"         o--o--o <-- mywork\n"
msgstr ""
" o--o--o <-- origin\n"
"        \\\n"
"         o--o--o <-- mywork\n"

#. type: Plain text
#: ../../user-manual.txt:2432
#, fuzzy
msgid ""
"Some more interesting work has been done in the upstream project, and "
"\"origin\" has advanced:"
msgstr ""
"プロジェクトの上流では他の興味深い変更が行なわれ、 \"origin\" は発展します："

#. type: delimited block .
#: ../../user-manual.txt:2437
#, fuzzy, no-wrap
msgid ""
" o--o--O--o--o--o <-- origin\n"
"        \\\n"
"         a--b--c <-- mywork\n"
msgstr ""
" o--o--O--o--o--o <-- origin\n"
"        \\\n"
"         a--b--c <-- mywork\n"

#. type: Plain text
#: ../../user-manual.txt:2441
#, fuzzy
msgid ""
"At this point, you could use \"pull\" to merge your changes back in; the "
"result would create a new merge commit, like this:"
msgstr ""
"この時点で、\"pull\" を使用して変更をマージさせることができます； 結果として"
"新しいマージコミットが生成されます、次のようにです："

#. type: delimited block .
#: ../../user-manual.txt:2446
#, fuzzy, no-wrap
msgid ""
" o--o--O--o--o--o <-- origin\n"
"        \\        \\\n"
"         a--b--c--m <-- mywork\n"
msgstr ""
" o--o--O--o--o--o <-- origin\n"
"        \\        \\\n"
"         a--b--c--m <-- mywork\n"

#. type: Plain text
#: ../../user-manual.txt:2451
#, fuzzy
msgid ""
"However, if you prefer to keep the history in mywork a simple series of "
"commits without any merges, you may instead choose to use linkgit:git-rebase"
"[1]:"
msgstr ""
"しかし、自分の履歴をマージ操作の無い、単純な一連のコミットの状態で 保ちたいの"
"であれば、その代わりに linkgit:git-rebase[1] を使用すると 良いでしょう。"

#. type: delimited block -
#: ../../user-manual.txt:2455
#, fuzzy, no-wrap
msgid ""
"$ git checkout mywork\n"
"$ git rebase origin\n"
msgstr ""
"$ git checkout mywork\n"
"$ git rebase origin\n"

#. type: Plain text
#: ../../user-manual.txt:2461
#, fuzzy
msgid ""
"This will remove each of your commits from mywork, temporarily saving them "
"as patches (in a directory named \".git/rebase-apply\"), update mywork to "
"point at the latest version of origin, then apply each of the saved patches "
"to the new mywork.  The result will look like:"
msgstr ""
"これは、mywork からあなたの各コミットを削除し、一時的に (\".git/rebase-apply"
"\" という名前のディレクトリ内に)パッチとして保存し、 mywork を origin の最新"
"バージョンの位置に更新し、その後で保存した 各パッチを新しい mywork ブランチに"
"適用します。結果は次のようになります："

#. type: delimited block .
#: ../../user-manual.txt:2467
#, fuzzy, no-wrap
msgid ""
" o--o--O--o--o--o <-- origin\n"
"\t\t \\\n"
"\t\t  a'--b'--c' <-- mywork\n"
msgstr ""
" o--o--O--o--o--o <-- origin\n"
"\t\t \\\n"
"\t\t  a'--b'--c' <-- mywork\n"

#. type: Plain text
#: ../../user-manual.txt:2473
#, fuzzy
msgid ""
"In the process, it may discover conflicts.  In that case it will stop and "
"allow you to fix the conflicts; after fixing conflicts, use `git add` to "
"update the index with those contents, and then, instead of running `git "
"commit`, just run"
msgstr ""
"この作業中にコンフリクトが発生するかもしれません。その場合は コンフリクトを解"
"決してください；コンフリクトを解消した後に `git add` を使用してそれらの内容で"
"索引を更新し、 `git commit` を実行する代わりに、"

#. type: delimited block -
#: ../../user-manual.txt:2476
#, fuzzy, no-wrap
msgid "$ git rebase --continue\n"
msgstr "$ git rebase --continue\n"

#. type: Plain text
#: ../../user-manual.txt:2479
#, fuzzy
msgid "and git will continue applying the rest of the patches."
msgstr "を実行します。すると、残りのパッチを適用する作業が続けられます。"

#. type: Plain text
#: ../../user-manual.txt:2482
#, fuzzy
msgid ""
"At any point you may use the `--abort` option to abort this process and "
"return mywork to the state it had before you started the rebase:"
msgstr ""
"どの時点でも `--abort` オプションを使用すると、この作業を取り消し、 rebase を"
"開始する前の mywork の状態に戻ることができます："

#. type: delimited block -
#: ../../user-manual.txt:2485
#, fuzzy, no-wrap
msgid "$ git rebase --abort\n"
msgstr "$ git rebase --abort\n"

#. type: Title -
#: ../../user-manual.txt:2489
#, fuzzy, no-wrap
msgid "Rewriting a single commit"
msgstr "１つのコミットを再編集する"

#. type: Plain text
#: ../../user-manual.txt:2493
#, fuzzy
msgid ""
"We saw in <<fixing-a-mistake-by-rewriting-history>> that you can replace the "
"most recent commit using"
msgstr ""
"<<fixing-a-mistake-by-rewriting-history,履歴を再編集して間違いを訂正する>> で"
"見てきたように直前のコミットを 以下のようにして修正することができます。"

#. type: Plain text
#: ../../user-manual.txt:2505
#, fuzzy
msgid ""
"You can also use a combination of this and linkgit:git-rebase[1] to replace "
"a commit further back in your history and recreate the intervening changes "
"on top of it.  First, tag the problematic commit with"
msgstr ""
"これと linkgit:git-rebase[1] を組み合わせることで、履歴内のさらに過去のコミッ"
"トについても 置き換えをし、その先頭の変更に立ち入ることができます。 初めに、"
"次のようにして問題のあるコミットにタグを付けます。"

#. type: delimited block -
#: ../../user-manual.txt:2508
#, fuzzy, no-wrap
msgid "$ git tag bad mywork~5\n"
msgstr "$ git tag bad mywork~5\n"

#. type: Plain text
#: ../../user-manual.txt:2511
#, fuzzy
msgid "(Either gitk or `git log` may be useful for finding the commit.)"
msgstr "(gitk または `git log` が問題のあるコミットを見つけるのに役立ちます。)"

#. type: Plain text
#: ../../user-manual.txt:2515
#, fuzzy
msgid ""
"Then check out that commit, edit it, and rebase the rest of the series on "
"top of it (note that we could check out the commit on a temporary branch, "
"but instead we're using a <<detached-head,detached head>>):"
msgstr ""
"そのコミットをチェックアウトして編集し、残りの一連の変更を その先頭にリベース"
"します(ここでは <<detached-head,引き剥がされたhead>> を 使用する代わりに、一"
"時的なブランチ上にコミットをチェックアウトします。)："

#. type: delimited block -
#: ../../user-manual.txt:2521
#, fuzzy, no-wrap
msgid ""
"$ git checkout bad\n"
"$ # make changes here and update the index\n"
"$ git commit --amend\n"
"$ git rebase --onto HEAD bad mywork\n"
msgstr ""
"$ git checkout bad\n"
"$ # ここで変更と索引の更新をします\n"
"$ git commit --amend\n"
"$ git rebase --onto HEAD bad mywork\n"

#. type: Plain text
#: ../../user-manual.txt:2526
#, fuzzy
msgid ""
"When you're done, you'll be left with mywork checked out, with the top "
"patches on mywork reapplied on top of your modified commit.  You can then "
"clean up with"
msgstr ""
"これらを行なった後、チェックアウトした mywork が保たれ続け、mywork 上の 先頭"
"のパッチは修正したコミットの先頭に再適用されます。 そして、これらを片付けるこ"
"とができます。"

#. type: delimited block -
#: ../../user-manual.txt:2529
#, fuzzy, no-wrap
msgid "$ git tag -d bad\n"
msgstr "$ git tag -d bad\n"

#. type: Plain text
#: ../../user-manual.txt:2534
#, fuzzy
msgid ""
"Note that the immutable nature of git history means that you haven't really "
"\"modified\" existing commits; instead, you have replaced the old commits "
"with new commits having new object names."
msgstr ""
"git の履歴が不変であるという性質は既存のコミットを実際に \"変更\" していない "
"ことを意味していることに注意してください；代わりに、古いコミットを 新しいオブ"
"ジェクト名を持つ新しいコミットで置き換えています。"

#. type: Title -
#: ../../user-manual.txt:2537
#, fuzzy, no-wrap
msgid "Reordering or selecting from a patch series"
msgstr "一連のパッチの並び替えや選択"

#. type: Plain text
#: ../../user-manual.txt:2543
#, fuzzy
msgid ""
"Given one existing commit, the linkgit:git-cherry-pick[1] command allows you "
"to apply the change introduced by that commit and create a new commit that "
"records it.  So, for example, if \"mywork\" points to a series of patches on "
"top of \"origin\", you might do something like:"
msgstr ""
"存在するコミットを引数にして linkgit:git-cherry-pick[1] コマンドを 実行する"
"と、そのコミットが行なった変更を適用し、新しいコミットを 作成することができま"
"す。従って、例えば、\"mywork\" が \"origin\" の先頭の 一連のパッチを指してい"
"るなら、以下のようにすることができます："

#. type: delimited block -
#: ../../user-manual.txt:2547
#, fuzzy, no-wrap
msgid ""
"$ git checkout -b mywork-new origin\n"
"$ gitk origin..mywork &\n"
msgstr ""
"$ git checkout -b mywork-new origin\n"
"$ gitk origin..mywork &\n"

#. type: Plain text
#: ../../user-manual.txt:2555
#, fuzzy
msgid ""
"and browse through the list of patches in the mywork branch using gitk, "
"applying them (possibly in a different order) to mywork-new using cherry-"
"pick, and possibly modifying them as you go using `git commit --amend`.  The "
"linkgit:git-gui[1] command may also help as it allows you to individually "
"select diff hunks for inclusion in the index (by right-clicking on the diff "
"hunk and choosing \"Stage Hunk for Commit\")."
msgstr ""
"そして、gitk を使用して mywork ブランチのパッチの一覧を表示し、 cherry-pick "
"を使用して mywork-new にそれらを(可能なら異なる順番で)適用し、 可能であるな"
"ら `git commit --amend` を使用してそれらを修正します。 linkgit:git-gui[1] コ"
"マンドは個々の選択した diff ハンクを索引に含めるかどうかを 選択するのに役に立"
"つかもしれません。(diff ハンクを右クリックし、 \"Stage Hunk for Commit\" を選"
"択します)"

#. type: Plain text
#: ../../user-manual.txt:2558
#, fuzzy
msgid ""
"Another technique is to use `git format-patch` to create a series of "
"patches, then reset the state to before the patches:"
msgstr ""
"もう一つの技術は `git format-patch` を使用して一連のパッチを作成し、 パッチの"
"前の状態にリセットすることです："

#. type: delimited block -
#: ../../user-manual.txt:2562
#, fuzzy, no-wrap
msgid ""
"$ git format-patch origin\n"
"$ git reset --hard origin\n"
msgstr ""
"$ git format-patch origin\n"
"$ git reset --hard origin\n"

#. type: Plain text
#: ../../user-manual.txt:2566
#, fuzzy
msgid ""
"Then modify, reorder, or eliminate patches as preferred before applying them "
"again with linkgit:git-am[1]."
msgstr ""
"そして、修正し、順番を並び替え、取り除き linkgit:git-am[1] を使用して 再び"
"パッチを適用します。"

#. type: Title -
#: ../../user-manual.txt:2569
#, fuzzy, no-wrap
msgid "Other tools"
msgstr "他のツール"

#. type: Plain text
#: ../../user-manual.txt:2574
#, fuzzy
msgid ""
"There are numerous other tools, such as StGIT, which exist for the purpose "
"of maintaining a patch series.  These are outside of the scope of this "
"manual."
msgstr ""
"他にもツールが多数あります。例えば StGIT です。stgit は一連のパッチを 管理す"
"るツールです。このマニュアルの対照から外れるため、説明は省略します。"

#. type: Title -
#: ../../user-manual.txt:2577
#, fuzzy, no-wrap
msgid "Problems with rewriting history"
msgstr "履歴の書き換えによって生じる問題"

#. type: Plain text
#: ../../user-manual.txt:2582
#, fuzzy
msgid ""
"The primary problem with rewriting the history of a branch has to do with "
"merging.  Suppose somebody fetches your branch and merges it into their "
"branch, with a result something like this:"
msgstr ""
"ブランチの履歴を書き換えることによって生じる主な問題はマージに関する ことで"
"す。誰かがあなたのブランチをフェッチし、自分のブランチにマージ すると、結果は"
"次のようになります："

#. type: delimited block .
#: ../../user-manual.txt:2587
#, fuzzy, no-wrap
msgid ""
" o--o--O--o--o--o <-- origin\n"
"        \\        \\\n"
"         t--t--t--m <-- their branch:\n"
msgstr ""
" o--o--O--o--o--o <-- origin\n"
"        \\        \\\n"
"         t--t--t--m <-- their branch:\n"

#. type: Plain text
#: ../../user-manual.txt:2590
#, fuzzy
msgid "Then suppose you modify the last three commits:"
msgstr "そして、最後の３つのコミットを修正したとします："

#. type: delimited block .
#: ../../user-manual.txt:2595
#, fuzzy, no-wrap
msgid ""
"\t o--o--o <-- new head of origin\n"
"\t/\n"
" o--o--O--o--o--o <-- old head of origin\n"
msgstr ""
"\t o--o--o <-- new head of origin\n"
"\t/\n"
" o--o--O--o--o--o <-- old head of origin\n"

#. type: Plain text
#: ../../user-manual.txt:2599
#, fuzzy
msgid ""
"If we examined all this history together in one repository, it will look "
"like:"
msgstr ""
"もしそれらが１つのリポジトリに入っていたとすると、 次のようになります："

#. type: delimited block .
#: ../../user-manual.txt:2606
#, fuzzy, no-wrap
msgid ""
"\t o--o--o <-- new head of origin\n"
"\t/\n"
" o--o--O--o--o--o <-- old head of origin\n"
"        \\        \\\n"
"         t--t--t--m <-- their branch:\n"
msgstr ""
"\t o--o--o <-- new head of origin\n"
"\t/\n"
" o--o--O--o--o--o <-- old head of origin\n"
"        \\        \\\n"
"         t--t--t--m <-- their branch:\n"

#. type: Plain text
#: ../../user-manual.txt:2615
#, fuzzy
msgid ""
"Git has no way of knowing that the new head is an updated version of the old "
"head; it treats this situation exactly the same as it would if two "
"developers had independently done the work on the old and new heads in "
"parallel.  At this point, if someone attempts to merge the new head in to "
"their branch, git will attempt to merge together the two (old and new) lines "
"of development, instead of trying to replace the old by the new.  The "
"results are likely to be unexpected."
msgstr ""
"Git は新しい head が古い head の更新されたバージョンであることを認識 しませ"
"ん；Git はこのような状態を２つの開発者が古い head と新しい head で 並行に作業"
"したものとして扱います。 その為、だれかが当たらし head を自身のブランチにマー"
"ジしようとすると、 git は old を new に置き換える代わりに、その２つの開発ライ"
"ン(old と new)  をいっしょにマージしようとします。 その結果は、期待したものと"
"はことなります。"

#. type: Plain text
#: ../../user-manual.txt:2620
#, fuzzy
msgid ""
"You may still choose to publish branches whose history is rewritten, and it "
"may be useful for others to be able to fetch those branches in order to "
"examine or test them, but they should not attempt to pull such branches into "
"their own work."
msgstr ""
"履歴が再編集されたブランチをまだ公開しようとするかもしれません。 そして、それ"
"らブランチをフェッチし順番にテストするのは役に立つことだと 思うかもしれませ"
"ん。しかし、そのようなブランチを自分の作業エリアに pull すべきではありませ"
"ん。"

#. type: Plain text
#: ../../user-manual.txt:2623
#, fuzzy
msgid ""
"For true distributed development that supports proper merging, published "
"branches should never be rewritten."
msgstr ""
"適切なマージをサポートする本来の分散開発では、 公開されたブランチは決して再編"
"集されるべきではありません。"

#. type: Title -
#: ../../user-manual.txt:2626
#, fuzzy, no-wrap
msgid "Why bisecting merge commits can be harder than bisecting linear history"
msgstr "マージコミットの分割が１本線の履歴の分割よりも困難となる理由"

#. type: Plain text
#: ../../user-manual.txt:2632
#, fuzzy
msgid ""
"The linkgit:git-bisect[1] command correctly handles history that includes "
"merge commits.  However, when the commit that it finds is a merge commit, "
"the user may need to work harder than usual to figure out why that commit "
"introduced a problem."
msgstr ""
"linkgit:git-bisect[1] コマンドはマージコミットを含んだ履歴を正確に扱います。 "
"しかし、コミットがマージコミットである時は、そのコミットが何故問題を起こして"
"いる かの原因を見つけ出すのに苦労することがあります。"

#. type: Plain text
#: ../../user-manual.txt:2634
#, fuzzy
msgid "Imagine this history:"
msgstr "次の履歴を考えてください："

#. type: delimited block .
#: ../../user-manual.txt:2639
#, fuzzy, no-wrap
msgid ""
"      ---Z---o---X---...---o---A---C---D\n"
"          \\                       /\n"
"           o---o---Y---...---o---B\n"
msgstr ""
"      ---Z---o---X---...---o---A---C---D\n"
"          \\                       /\n"
"           o---o---Y---...---o---B\n"

#. type: Plain text
#: ../../user-manual.txt:2647
#, fuzzy
msgid ""
"Suppose that on the upper line of development, the meaning of one of the "
"functions that exists at Z is changed at commit X.  The commits from Z "
"leading to A change both the function's implementation and all calling sites "
"that exist at Z, as well as new calling sites they add, to be consistent.  "
"There is no bug at A."
msgstr ""
"上側の開発ライン上のコミットXにて Zから存在する関数の意味が 変更されたとしま"
"す。ZからAにつながるコミットは、関数の実装を変更し、 Zの時点で存在する全コー"
"ル箇所と新しく追加したコール箇所の両方を変更して、 矛盾のない状態にしていたと"
"します。 A の時点ではバグはありません。"

#. type: Plain text
#: ../../user-manual.txt:2653
#, fuzzy
msgid ""
"Suppose that in the meantime on the lower line of development somebody adds "
"a new calling site for that function at commit Y.  The commits from Z "
"leading to B all assume the old semantics of that function and the callers "
"and the callee are consistent with each other.  There is no bug at B, either."
msgstr ""
"それと同時に下側の開発ラインではコミットYにてその関数の新しい コール箇所を追"
"加していたとします。 ZからBにつながるコミットの全ては、その関数の古い動作を想"
"定していて コール元とコール先は互いに矛盾していません。Bにもバグはありませ"
"ん。"

#. type: Plain text
#: ../../user-manual.txt:2656
#, fuzzy
msgid ""
"Suppose further that the two development lines merge cleanly at C, so no "
"conflict resolution is required."
msgstr ""
"２つの開発ラインがきれいにマージできたとすると、 コンフリクトの解消要求はあり"
"ません。"

#. type: Plain text
#: ../../user-manual.txt:2663
#, fuzzy
msgid ""
"Nevertheless, the code at C is broken, because the callers added on the "
"lower line of development have not been converted to the new semantics "
"introduced on the upper line of development.  So if all you know is that D "
"is bad, that Z is good, and that linkgit:git-bisect[1] identifies C as the "
"culprit, how will you figure out that the problem is due to this change in "
"semantics?"
msgstr ""
"にもかかわらず、Cのソースは壊れています。なぜなら 下側の開発ラインは上側の開"
"発ラインで行われた新しい動作に変換 されていないからです。 したがって、"
"linkgit:git-bisect[1] は D に問題があり、 Z には問題ないこと、そしてC が問題"
"の原因であると伝えます。 どのようにしたら、問題が動作変更によるものだと見つけ"
"ることが できるでしょうか？"

#. type: Plain text
#: ../../user-manual.txt:2673
#, fuzzy
msgid ""
"When the result of a `git bisect` is a non-merge commit, you should normally "
"be able to discover the problem by examining just that commit.  Developers "
"can make this easy by breaking their changes into small self-contained "
"commits.  That won't help in the case above, however, because the problem "
"isn't obvious from examination of any single commit; instead, a global view "
"of the development is required.  To make matters worse, the change in "
"semantics in the problematic function may be just one small part of the "
"changes in the upper line of development."
msgstr ""
"`git bisect` の結果が非マージコミットの場合、通常、単にそのコミットを 確認す"
"るだけで問題を見つけることができます。 開発者はコミットを自己完結したより小さ"
"いものに分割することで これを容易に行うことができます。しかし、 上記場合には"
"１つのコミットを確認することでは問題が明らかにならない為、 このような方法では"
"解決の役に立ちません；その代わりに開発の大局的な視点が 必要となります。さらに"
"悪いことに、問題となっている関数の動作変更が 上側の開発ラインの単なる小さな部"
"分の変更であるかもしれません。"

#. type: Plain text
#: ../../user-manual.txt:2677
#, fuzzy
msgid ""
"On the other hand, if instead of merging at C you had rebased the history "
"between Z to B on top of A, you would have gotten this linear history:"
msgstr ""
"その一方で、C のマージをする代わりに、ZからBの履歴を Aの先頭 にリベースした場"
"合、次のような１行の履歴を取得することができます："

#. type: delimited block .
#: ../../user-manual.txt:2680
#, fuzzy, no-wrap
msgid "    ---Z---o---X--...---o---A---o---o---Y*--...---o---B*--D*\n"
msgstr "    ---Z---o---X--...---o---A---o---o---Y*--...---o---B*--D*\n"

#. type: Plain text
#: ../../user-manual.txt:2684
#, fuzzy
msgid ""
"Bisecting between Z and D* would hit a single culprit commit Y*, and "
"understanding why Y* was broken would probably be easier."
msgstr ""
"Z と D* の間を git bisect すると、１つの問題の原因となるコミット Y* を見つけ"
"ることができ、Y* が何故問題を引き起こしている理由を 容易に理解することができ"
"るでしょう。"

#. type: Plain text
#: ../../user-manual.txt:2689
#, fuzzy
msgid ""
"Partly for this reason, many experienced git users, even when working on an "
"otherwise merge-heavy project, keep the history linear by rebasing against "
"the latest upstream version before publishing."
msgstr ""
"部分的にですが、この理由により、たくさん経験を積んだ git ユーザは マージが頻"
"繁に行われるプロジェクトで作業する場合でさえも 最新の上流バージョンに対するリ"
"ベースを行うことによって 履歴を１ラインに保つようにしています。"

#. type: Title =
#: ../../user-manual.txt:2692
#, fuzzy, no-wrap
msgid "Advanced branch management"
msgstr "高度なブランチ管理"

#. type: Title -
#: ../../user-manual.txt:2696
#, fuzzy, no-wrap
msgid "Fetching individual branches"
msgstr "個々のブランチをフェッチする"

#. type: Plain text
#: ../../user-manual.txt:2701
#, fuzzy
msgid ""
"Instead of using linkgit:git-remote[1], you can also choose just to update "
"one branch at a time, and to store it locally under an arbitrary name:"
msgstr ""
"linkgit:git-remote[1] を使用する代わりに、時には１つのブランチだけを 更新し、"
"任意の名前でローカルに保存することもできます："

#. type: delimited block -
#: ../../user-manual.txt:2704
#, fuzzy, no-wrap
msgid "$ git fetch origin todo:my-todo-work\n"
msgstr "$ git fetch origin todo:my-todo-work\n"

#. type: Plain text
#: ../../user-manual.txt:2710
#, fuzzy
msgid ""
"The first argument, \"origin\", just tells git to fetch from the repository "
"you originally cloned from.  The second argument tells git to fetch the "
"branch named \"todo\" from the remote repository, and to store it locally "
"under the name refs/heads/my-todo-work."
msgstr ""
"最初の引数 \"origin\" はクローン元のリポジトリからフェッチすることを git に伝"
"えています。２つ目の引数はリモートのリポジトリの \"todo\" という 名前のブラン"
"チをフェッチし、refs/heads/my-todo-work という名前で ローカルに保存すること"
"を git に伝えています。"

#. type: Plain text
#: ../../user-manual.txt:2712
#, fuzzy
msgid "You can also fetch branches from other repositories; so"
msgstr "他のリポジトリにあるブランチをフェッチすることもできます；例えば、"

#. type: delimited block -
#: ../../user-manual.txt:2715
#, fuzzy, no-wrap
msgid "$ git fetch git://example.com/proj.git master:example-master\n"
msgstr "$ git fetch git://example.com/proj.git master:example-master\n"

#. type: Plain text
#: ../../user-manual.txt:2722
#, fuzzy
msgid ""
"will create a new branch named \"example-master\" and store in it the branch "
"named \"master\" from the repository at the given URL.  If you already have "
"a branch named example-master, it will attempt to <<fast-forwards,fast-"
"forward>> to the commit given by example.com's master branch.  In more "
"detail:"
msgstr ""
"は \"example-master\" という名前の新しいブランチを作成し、 指定した URL にあ"
"るリポジトリの \"master\" という名前のブランチの内容を 保存します。既に "
"\"example-master\" という名前のブランチが存在する場合は、 example.com の "
"master ブランチが与えるコミットの <<fast-forwards,fast-forward>> を 試みま"
"す。詳細は次の節で説明します。"

#. type: Title -
#: ../../user-manual.txt:2725
#, fuzzy, no-wrap
msgid "git fetch and fast-forwards"
msgstr "git fetch と fast-forwards"

#. type: Plain text
#: ../../user-manual.txt:2732
#, fuzzy
msgid ""
"In the previous example, when updating an existing branch, \"git fetch\" "
"checks to make sure that the most recent commit on the remote branch is a "
"descendant of the most recent commit on your copy of the branch before "
"updating your copy of the branch to point at the new commit.  Git calls this "
"process a <<fast-forwards,fast forward>>."
msgstr ""
"前節の例では、存在するブランチを更新する時に、\"git fetch\" は リモートブラン"
"チの最新のコミットがあなたのコピーしたブランチの最新の コミットの子孫であるこ"
"とを確認してから、新しいコミットの位置に 更新しようとします。 Git はこのプロ"
"セスを <<fast-forwards,fast forward>> と呼びます。"

#. type: Plain text
#: ../../user-manual.txt:2734
#, fuzzy
msgid "A fast forward looks something like this:"
msgstr "fast forward は、以下のように見えます："

#. type: delimited block .
#: ../../user-manual.txt:2739
#, fuzzy, no-wrap
msgid ""
" o--o--o--o <-- old head of the branch\n"
"           \\\n"
"            o--o--o <-- new head of the branch\n"
msgstr ""
" o--o--o--o <-- old head of the branch\n"
"           \\\n"
"            o--o--o <-- new head of the branch\n"

#. type: Plain text
#: ../../user-manual.txt:2746
#, fuzzy
msgid ""
"In some cases it is possible that the new head will *not* actually be a "
"descendant of the old head.  For example, the developer may have realized "
"she made a serious mistake, and decided to backtrack, resulting in a "
"situation like:"
msgstr ""
"時には、新しい head は古い head の子孫ではない可能性があります。 例えば、開発"
"者が深刻な間違いをしたことに気がつき、変更を 元に戻すことにした場合です、その"
"結果は次のようになります："

#. type: delimited block .
#: ../../user-manual.txt:2751
#, fuzzy, no-wrap
msgid ""
" o--o--o--o--a--b <-- old head of the branch\n"
"           \\\n"
"            o--o--o <-- new head of the branch\n"
msgstr ""
" o--o--o--o--a--b <-- old head of the branch\n"
"           \\\n"
"            o--o--o <-- new head of the branch\n"

#. type: Plain text
#: ../../user-manual.txt:2754
#, fuzzy
msgid "In this case, \"git fetch\" will fail, and print out a warning."
msgstr "この場合、\"git fetch\" は失敗し、警告が表示されます。"

#. type: Plain text
#: ../../user-manual.txt:2760
#, fuzzy
msgid ""
"In that case, you can still force git to update to the new head, as "
"described in the following section.  However, note that in the situation "
"above this may mean losing the commits labeled \"a\" and \"b\", unless "
"you've already created a reference of your own pointing to them."
msgstr ""
"その場合にも、次の節で説明する方法で、強制的に新しい head に\n"
"更新することができます。しかし、上記の場合には それらへの参照を既に作成してい"
"ない限りは\n"
" \"a\" と \"b\" のコミットが紛失することを意味することに注意してください。\n"

#. type: Title -
#: ../../user-manual.txt:2763
#, fuzzy, no-wrap
msgid "Forcing git fetch to do non-fast-forward updates"
msgstr "強制的に fast-forward を使わずに git fetch を行う"

#. type: Plain text
#: ../../user-manual.txt:2767
#, fuzzy
msgid ""
"If git fetch fails because the new head of a branch is not a descendant of "
"the old head, you may force the update with:"
msgstr ""
"新しいブランチの head が古い head の子孫ではない為に、 git fetch 失敗した場合"
"には、次のようにして強制的に 更新することができます："

#. type: delimited block -
#: ../../user-manual.txt:2770
#, fuzzy, no-wrap
msgid "$ git fetch git://example.com/proj.git +master:refs/remotes/example/master\n"
msgstr "$ git fetch git://example.com/proj.git +master:refs/remotes/example/master\n"

#. type: Plain text
#: ../../user-manual.txt:2774
#, fuzzy
msgid ""
"Note the addition of the \"+\" sign.  Alternatively, you can use the \"-f\" "
"flag to force updates of all the fetched branches, as in:"
msgstr ""
"\"+\" 記号を追加していることに注意してください。代わりに \"-f\" を のフラグを"
"使用し、フェッチした全てのブランチを強制的に更新することもできます："

#. type: delimited block -
#: ../../user-manual.txt:2777
#, fuzzy, no-wrap
msgid "$ git fetch -f origin\n"
msgstr "$ git fetch -f origin\n"

#. type: Plain text
#: ../../user-manual.txt:2781
#, fuzzy
msgid ""
"Be aware that commits that the old version of example/master pointed at may "
"be lost, as we saw in the previous section."
msgstr ""
"この操作により、example/master の古いバージョンが指していたコミットは紛失し"
"て しまうことに注意してください。それは、前の節で説明したとおりです。"

#. type: Title -
#: ../../user-manual.txt:2784
#, fuzzy, no-wrap
msgid "Configuring remote branches"
msgstr "リモートブランチの構成"

#. type: Plain text
#: ../../user-manual.txt:2790
#, fuzzy
msgid ""
"We saw above that \"origin\" is just a shortcut to refer to the repository "
"that you originally cloned from.  This information is stored in git "
"configuration variables, which you can see using linkgit:git-config[1]:"
msgstr ""
"既に説明したように、\"origin\" はクローン元のリポジトリを参照する ショート"
"カットです。この情報は git の構成ファイルに格納されており、 linkgit:git-"
"config[1] を使用して参照することができます："

#. type: delimited block -
#: ../../user-manual.txt:2800
#, fuzzy, no-wrap
msgid ""
"$ git config -l\n"
"core.repositoryformatversion=0\n"
"core.filemode=true\n"
"core.logallrefupdates=true\n"
"remote.origin.url=git://git.kernel.org/pub/scm/git/git.git\n"
"remote.origin.fetch=+refs/heads/*:refs/remotes/origin/*\n"
"branch.master.remote=origin\n"
"branch.master.merge=refs/heads/master\n"
msgstr ""
"$ git config -l\n"
"core.repositoryformatversion=0\n"
"core.filemode=true\n"
"core.logallrefupdates=true\n"
"remote.origin.url=git://git.kernel.org/pub/scm/git/git.git\n"
"remote.origin.fetch=+refs/heads/*:refs/remotes/origin/*\n"
"branch.master.remote=origin\n"
"branch.master.merge=refs/heads/master\n"

#. type: Plain text
#: ../../user-manual.txt:2805
#, fuzzy
msgid ""
"If there are other repositories that you also use frequently, you can create "
"similar configuration options to save typing; for example, after"
msgstr ""
"他にも頻繁に参照するリポジトリがある場合は、タイピング数を節約するため、 同じ"
"ように構成ファイルに登録することができます；例えば、"

#. type: delimited block -
#: ../../user-manual.txt:2808
#, fuzzy, no-wrap
msgid "$ git config remote.example.url git://example.com/proj.git\n"
msgstr "$ git config remote.example.url git://example.com/proj.git\n"

#. type: Plain text
#: ../../user-manual.txt:2811
#, fuzzy
msgid "then the following two commands will do the same thing:"
msgstr "とすると、次の２つのコマンドは同じことをするようになります："

#. type: delimited block -
#: ../../user-manual.txt:2815
#, fuzzy, no-wrap
msgid ""
"$ git fetch git://example.com/proj.git master:refs/remotes/example/master\n"
"$ git fetch example master:refs/remotes/example/master\n"
msgstr ""
"$ git fetch git://example.com/proj.git master:refs/remotes/example/master\n"
"$ git fetch example master:refs/remotes/example/master\n"

#. type: Plain text
#: ../../user-manual.txt:2818
#, fuzzy
msgid "Even better, if you add one more option:"
msgstr "さらに、次のオプションを追加すると："

#. type: delimited block -
#: ../../user-manual.txt:2821
#, fuzzy, no-wrap
msgid "$ git config remote.example.fetch master:refs/remotes/example/master\n"
msgstr "$ git config remote.example.fetch master:refs/remotes/example/master\n"

#. type: Plain text
#: ../../user-manual.txt:2824
#, fuzzy
msgid "then the following commands will all do the same thing:"
msgstr "次のコマンドは全て同じことをするようになります："

#. type: delimited block -
#: ../../user-manual.txt:2829
#, fuzzy, no-wrap
msgid ""
"$ git fetch git://example.com/proj.git master:refs/remotes/example/master\n"
"$ git fetch example master:refs/remotes/example/master\n"
"$ git fetch example\n"
msgstr ""
"$ git fetch git://example.com/proj.git master:refs/remotes/example/master\n"
"$ git fetch example master:refs/remotes/example/master\n"
"$ git fetch example\n"

#. type: Plain text
#: ../../user-manual.txt:2832
#, fuzzy
msgid "You can also add a \"+\" to force the update each time:"
msgstr "\"+\" をつけて強制的に更新することもできます："

#. type: delimited block -
#: ../../user-manual.txt:2835
#, fuzzy, no-wrap
msgid "$ git config remote.example.fetch +master:ref/remotes/example/master\n"
msgstr "$ git config remote.example.fetch +master:ref/remotes/example/master\n"

#. type: Plain text
#: ../../user-manual.txt:2839
#, fuzzy
msgid ""
"Don't do this unless you're sure you won't mind \"git fetch\" possibly "
"throwing away commits on 'example/master'."
msgstr ""
"\"git fetch\" が 'example/master' 上のコミットを捨て去る可能性があることを 嫌"
"う場合は、この操作はしないでください。"

#. type: Plain text
#: ../../user-manual.txt:2843
#, fuzzy
msgid ""
"Also note that all of the above configuration can be performed by directly "
"editing the file .git/config instead of using linkgit:git-config[1]."
msgstr ""
"また、上記の構成全ては、linkgit:git-config[1] を使用する代わりに 直接 .git/"
"config ファイルを編集して登録することもできます。"

#. type: Plain text
#: ../../user-manual.txt:2846
#, fuzzy
msgid ""
"See linkgit:git-config[1] for more details on the configuration options "
"mentioned above."
msgstr ""
"詳細は linkgit:git-config[1] 内の 構成オプションについて触れられている 箇所を"
"参照してください。"

#. type: Title =
#: ../../user-manual.txt:2850
#, fuzzy, no-wrap
msgid "Git concepts"
msgstr "Git のコンセプト"

#. type: Plain text
#: ../../user-manual.txt:2855
#, fuzzy
msgid ""
"Git is built on a small number of simple but powerful ideas.  While it is "
"possible to get things done without understanding them, you will find git "
"much more intuitive if you do."
msgstr ""
"Git は少ない数のシンプルだが強力なアイデアで成り立っています。 それらを理解し"
"なくても git を利用することはできますが、 理解することで git をより直感的に理"
"解できます。"

#. type: Plain text
#: ../../user-manual.txt:2858
#, fuzzy
msgid ""
"We start with the most important, the <<def_object_database,object "
"database>> and the <<def_index,index>>."
msgstr ""
"最も重要なコンセプトである <<def_object_database,オブジェクトデータベース>> "
"と <<def_index,索引(index)>> の説明から開始しましょう、"

#. type: Title -
#: ../../user-manual.txt:2861
#, fuzzy, no-wrap
msgid "The Object Database"
msgstr "オブジェクトＤＢ"

#. type: Plain text
#: ../../user-manual.txt:2872
#, fuzzy
msgid ""
"We already saw in <<understanding-commits>> that all commits are stored "
"under a 40-digit \"object name\".  In fact, all the information needed to "
"represent the history of a project is stored in objects with such names.  In "
"each case the name is calculated by taking the SHA-1 hash of the contents of "
"the object.  The SHA-1 hash is a cryptographic hash function.  What that "
"means to us is that it is impossible to find two different objects with the "
"same name.  This has a number of advantages; among others:"
msgstr ""
"既に <<understanding-commits>> で見てきたように、全てのコミットは 40桁の \"オ"
"ブジェクト名\" で格納されています。実際、プロジェクトの履歴を 表現するのに必"
"要な全ての情報は、そのような名前のオブジェクトとして格納されています。 それぞ"
"れの名前はオブジェクト内容の SHA-1 ハッシュによって 計算されています。SHA-1"
"ハッシュは暗号学的ハッシュ関数です。 それはつまり、同じ名前を持つ２つの異なる"
"オブジェクトを見つけるのが 不可能であることを意味します。このことは多くの利点"
"を持っています。 とりわけ："

#. type: Plain text
#: ../../user-manual.txt:2875
#, fuzzy
msgid ""
"Git can quickly determine whether two objects are identical or not, just by "
"comparing names."
msgstr ""
"Git は２つのオブジェクトが同じであるかどうかを 名前を比較するだけで高速に判断"
"できます。"

#. type: Plain text
#: ../../user-manual.txt:2878
#, fuzzy
msgid ""
"Since object names are computed the same way in every repository, the same "
"content stored in two repositories will always be stored under the same name."
msgstr ""
"オブジェクト名が全てのリポジトリに対して同じ方法で計算されるので、 ２つのリポ"
"ジトリに格納した同じ内容は、常に同じ名前で格納されます。"

#. type: Plain text
#: ../../user-manual.txt:2880
#, fuzzy
msgid ""
"Git can detect errors when it reads an object, by checking that the object's "
"name is still the SHA-1 hash of its contents."
msgstr ""
"オブジェクト名が自身の内容の SHA-1 ハッシュ値と一致しているかを 確認すること"
"で、Git はオブジェクトを読み込んだ時に、エラーを検出できます。"

#. type: Plain text
#: ../../user-manual.txt:2883
#, fuzzy
msgid ""
"(See <<object-details>> for the details of the object formatting and SHA-1 "
"calculation.)"
msgstr ""
"(オブジェクトの形式と SHA1 計算の詳細は <<object-details>> を参照してくださ"
"い)"

#. type: Plain text
#: ../../user-manual.txt:2886
#, fuzzy
msgid ""
"There are four different types of objects: \"blob\", \"tree\", \"commit\", "
"and \"tag\"."
msgstr ""
"Gitが扱う オブジェクトには４種類あります：\"blob\", \"tree\", \"commit\" そし"
"て \"tag\" です。"

#. type: Plain text
#: ../../user-manual.txt:2888
#, fuzzy
msgid "A <<def_blob_object,\"blob\" object>> is used to store file data."
msgstr ""
"<<def_blob_object,\"blob\" オブジェクト>> はファイルデータを格納するのに使用"
"されます。"

#. type: Plain text
#: ../../user-manual.txt:2891
#, fuzzy
msgid ""
"A <<def_tree_object,\"tree\" object>> ties one or more \"blob\" objects into "
"a directory structure. In addition, a tree object can refer to other tree "
"objects, thus creating a directory hierarchy."
msgstr ""
"<<def_tree_object,\"tree\" オブジェクト>> は１つ以上の \"blob\" オブジェクト"
"に リンクし、ディレクトリ構成を作ります。さらに、tree オブジェクトは 他の "
"tree オブジェクトを参照できます。従って、ディレクトリ階層を作成できます。"

#. type: Plain text
#: ../../user-manual.txt:2897
#, fuzzy
msgid ""
"A <<def_commit_object,\"commit\" object>> ties such directory hierarchies "
"together into a <<def_DAG,directed acyclic graph>> of revisions--each commit "
"contains the object name of exactly one tree designating the directory "
"hierarchy at the time of the commit. In addition, a commit refers to \"parent"
"\" commit objects that describe the history of how we arrived at that "
"directory hierarchy."
msgstr ""
"<<def_commit_object,\"commit\" オブジェクト>>はディレクトリ階層とリンクし、 "
"リビジョンの <<def_DAG,有向非巡回グラフ>>を作ります。-- 各コミットは そのコ"
"ミット時点でのディレクトリ階層を指し示すオブジェクトの名前を 含みます。さら"
"に、commit はそのディレクトリ階層に到った経路を示す \"親\" のコミットオブジェ"
"クトを参照しています。"

#. type: Plain text
#: ../../user-manual.txt:2901
#, fuzzy
msgid ""
"A <<def_tag_object,\"tag\" object>> symbolically identifies and can be used "
"to sign other objects. It contains the object name and type of another "
"object, a symbolic name (of course!) and, optionally, a signature."
msgstr ""
"<<def_tag_object,\"tag\" オブジェクト>> はあるオブジェクトを特定する シンボル"
"の役目をし、また他のオブジェクトに署名をつける目的でも 利用できます。\"tag\" "
"オブジェクトは、他のオブジェクトの名前と型、 そして(もちろん)シンボリック名を"
"持ち、時には署名も含んでいます。"

#. type: Plain text
#: ../../user-manual.txt:2903
#, fuzzy
msgid "The object types in some more detail:"
msgstr "オブジェクトタイプの詳細："

#. type: Title ~
#: ../../user-manual.txt:2906
#, fuzzy, no-wrap
msgid "Commit Object"
msgstr "Commit オブジェクト"

#. type: Plain text
#: ../../user-manual.txt:2912
#, fuzzy
msgid ""
"The \"commit\" object links a physical state of a tree with a description of "
"how we got there and why.  Use the --pretty=raw option to linkgit:git-show"
"[1] or linkgit:git-log[1] to examine your favorite commit:"
msgstr ""
"\"commit\" オブジェクトはツリーの物理的な状態にリンクし、 また、どのようにし"
"てその記述に至ったかの情報も一緒に含んでいます。 --pretty=raw オプション付き"
"で linkgit:git-show[1] または linkgit:git-log[1] を 実行すると、特定のコミッ"
"トの内容を確認できます："

#. type: delimited block -
#: ../../user-manual.txt:2920
#, fuzzy, no-wrap
msgid ""
"$ git show -s --pretty=raw 2be7fcb476\n"
"commit 2be7fcb4764f2dbcee52635b91fedb1b3dcf7ab4\n"
"tree fb3a8bdd0ceddd019615af4d57a53f43d8cee2bf\n"
"parent 257a84d9d02e90447b149af58b271c19405edb6a\n"
"author Dave Watson <dwatson@mimvista.com> 1187576872 -0400\n"
"committer Junio C Hamano <gitster@pobox.com> 1187591163 -0700\n"
msgstr ""
"$ git show -s --pretty=raw 2be7fcb476\n"
"commit 2be7fcb4764f2dbcee52635b91fedb1b3dcf7ab4\n"
"tree fb3a8bdd0ceddd019615af4d57a53f43d8cee2bf\n"
"parent 257a84d9d02e90447b149af58b271c19405edb6a\n"
"author Dave Watson <dwatson@mimvista.com> 1187576872 -0400\n"
"committer Junio C Hamano <gitster@pobox.com> 1187591163 -0700\n"

#. type: delimited block -
#: ../../user-manual.txt:2922
#, fuzzy, no-wrap
msgid "    Fix misspelling of 'suppress' in docs\n"
msgstr "    Fix misspelling of 'suppress' in docs\n"

#. type: delimited block -
#: ../../user-manual.txt:2924
#, fuzzy, no-wrap
msgid "    Signed-off-by: Junio C Hamano <gitster@pobox.com>\n"
msgstr "    Signed-off-by: Junio C Hamano <gitster@pobox.com>\n"

#. type: Plain text
#: ../../user-manual.txt:2927
#, fuzzy
msgid "As you can see, a commit is defined by:"
msgstr "このように、コミットは次のように定義されています："

#. type: Plain text
#: ../../user-manual.txt:2930
#, fuzzy
msgid ""
"a tree: The SHA-1 name of a tree object (as defined below), representing the "
"contents of a directory at a certain point in time."
msgstr ""
"tree： ある時点のディレクトリの中身を表現する ツリーオブジェクト(以下で定義)"
"の SHA-1 名。"

#. type: Plain text
#: ../../user-manual.txt:2937
#, fuzzy
msgid ""
"parent(s): The SHA-1 name of some number of commits which represent the "
"immediately previous step(s) in the history of the project.  The example "
"above has one parent; merge commits may have more than one.  A commit with "
"no parents is called a \"root\" commit, and represents the initial revision "
"of a project.  Each project must have at least one root.  A project can also "
"have multiple roots, though that isn't common (or necessarily a good idea)."
msgstr ""
"parent(s): プロジェクト履歴内のすぐ１つ前の状態を表している 複数のコミットの "
"SHA-1 名。上記例では１つの parent があります； マージコミットでは、１つ以上の"
"場合があります。 parent のないコミットは \"root\" コミットと呼ばれ、 プロジェ"
"クトの初期リビジョンを表します。各プロジェクトは最低１つの root を 持つ必要が"
"あります。プロジェクトは複数の root を持つこともできますが、 あまり一般的では"
"ありません(良いアイデアではありません)"

#. type: Plain text
#: ../../user-manual.txt:2939
#, fuzzy
msgid ""
"an author: The name of the person responsible for this change, together with "
"its date."
msgstr "author: この変更に対する責任者の名前と日付。"

#. type: Plain text
#: ../../user-manual.txt:2943
#, fuzzy
msgid ""
"a committer: The name of the person who actually created the commit, with "
"the date it was done.  This may be different from the author, for example, "
"if the author was someone who wrote a patch and emailed it to the person who "
"used it to create the commit."
msgstr ""
"committer: このコミットを実際に作成した担当者と日付。 committer は author と"
"は一致しないかもしれません、例えば、 author がパッチを作成しそれを E-Mailで別"
"の人がそのパッチをコミットする ことがあります。"

#. type: Plain text
#: ../../user-manual.txt:2944
#, fuzzy
msgid "a comment describing this commit."
msgstr "このコメントに関するコメント。"

#. type: Plain text
#: ../../user-manual.txt:2952
#, fuzzy
msgid ""
"Note that a commit does not itself contain any information about what "
"actually changed; all changes are calculated by comparing the contents of "
"the tree referred to by this commit with the trees associated with its "
"parents.  In particular, git does not attempt to record file renames "
"explicitly, though it can identify cases where the existence of the same "
"file data at changing paths suggests a rename.  (See, for example, the -M "
"option to linkgit:git-diff[1])."
msgstr ""
"注意：コミット自身は実際にどのような変更がされたかの情報を持っていません； 全"
"ての変更はコミットが参照しているツリーとparents から連想されるツリーとの比較 "
"によって計算されます。特に、git はファイル名の変更を明示的には記録しようと し"
"ません。しかし、同じデータをもつファイルが存在する場合に名前変更であると 認識"
"する方法があります。(例えば、linkgit:git-diff[1] の -M オプションを参照)"

#. type: Plain text
#: ../../user-manual.txt:2956
#, fuzzy
msgid ""
"A commit is usually created by linkgit:git-commit[1], which creates a commit "
"whose parent is normally the current HEAD, and whose tree is taken from the "
"content currently stored in the index."
msgstr ""
"コミットは通常 linkgit:git-commit[1] によって作成されます。 デフォルトではそ"
"の親を現在のHEADとしたコミットが作成され、 そのツリーは現在の索引に格納されて"
"いる内容が使用されます。"

#. type: Title ~
#: ../../user-manual.txt:2959
#, fuzzy, no-wrap
msgid "Tree Object"
msgstr "Tree オブジェクト"

#. type: Plain text
#: ../../user-manual.txt:2964
#, fuzzy
msgid ""
"The ever-versatile linkgit:git-show[1] command can also be used to examine "
"tree objects, but linkgit:git-ls-tree[1] will give you more details:"
msgstr ""
"linkgit:git-show[1] コマンドは tree オブジェクトに対しても 使用することができ"
"ますが、linkgit:git-ls-tree[1] の方が より詳細な情報を表示します："

#. type: delimited block -
#: ../../user-manual.txt:2976
#, fuzzy, no-wrap
msgid ""
"$ git ls-tree fb3a8bdd0ce\n"
"100644 blob 63c918c667fa005ff12ad89437f2fdc80926e21c    .gitignore\n"
"100644 blob 5529b198e8d14decbe4ad99db3f7fb632de0439d    .mailmap\n"
"100644 blob 6ff87c4664981e4397625791c8ea3bbb5f2279a3    COPYING\n"
"040000 tree 2fb783e477100ce076f6bf57e4a6f026013dc745    Documentation\n"
"100755 blob 3c0032cec592a765692234f1cba47dfdcc3a9200    GIT-VERSION-GEN\n"
"100644 blob 289b046a443c0647624607d471289b2c7dcd470b    INSTALL\n"
"100644 blob 4eb463797adc693dc168b926b6932ff53f17d0b1    Makefile\n"
"100644 blob 548142c327a6790ff8821d67c2ee1eff7a656b52    README\n"
"...\n"
msgstr ""
"$ git ls-tree fb3a8bdd0ce\n"
"100644 blob 63c918c667fa005ff12ad89437f2fdc80926e21c    .gitignore\n"
"100644 blob 5529b198e8d14decbe4ad99db3f7fb632de0439d    .mailmap\n"
"100644 blob 6ff87c4664981e4397625791c8ea3bbb5f2279a3    COPYING\n"
"040000 tree 2fb783e477100ce076f6bf57e4a6f026013dc745    Documentation\n"
"100755 blob 3c0032cec592a765692234f1cba47dfdcc3a9200    GIT-VERSION-GEN\n"
"100644 blob 289b046a443c0647624607d471289b2c7dcd470b    INSTALL\n"
"100644 blob 4eb463797adc693dc168b926b6932ff53f17d0b1    Makefile\n"
"100644 blob 548142c327a6790ff8821d67c2ee1eff7a656b52    README\n"
"...\n"

#. type: Plain text
#: ../../user-manual.txt:2981
#, fuzzy
msgid ""
"As you can see, a tree object contains a list of entries, each with a mode, "
"object type, SHA-1 name, and name, sorted by name.  It represents the "
"contents of a single directory tree."
msgstr ""
"このように、tree オブジェクトは名前順でソートされたエントリの一覧を含んでお"
"り、 各エントリは mode, オブジェクトタイプ、SHA-1名、名前を持っています。 "
"tree は １つのディレクトリツリーの中身を表現します。"

#. type: Plain text
#: ../../user-manual.txt:2990
#, fuzzy
msgid ""
"The object type may be a blob, representing the contents of a file, or "
"another tree, representing the contents of a subdirectory.  Since trees and "
"blobs, like all other objects, are named by the SHA-1 hash of their "
"contents, two trees have the same SHA-1 name if and only if their contents "
"(including, recursively, the contents of all subdirectories)  are "
"identical.  This allows git to quickly determine the differences between two "
"related tree objects, since it can ignore any entries with identical object "
"names."
msgstr ""
"オブジェクトタイプが blob の場合はファイルデータであることを表し、 tree であ"
"る場合は、サブディレクトリであることを表しています。 tree と blob は他のオブ"
"ジェクトと同じようにその中身の SHA-1値によって 名前が付けられていて、その中身"
"が(全てのサブディレクトリの内容も含めて)同じ場合 にのみ同じ SHA-1 名となりま"
"す。この仕組みにより git は２つの関連する tree オブジェクト間の差分を高速に調"
"べることができます。"

#. type: Plain text
#: ../../user-manual.txt:2993
#, fuzzy
msgid ""
"(Note: in the presence of submodules, trees may also have commits as "
"entries.  See <<submodules>> for documentation.)"
msgstr ""
"(注意：サブモジュールが存在する場合、tree は commit をエントリに 持つことがあ"
"ります。<<submodules>> のドキュメントを参照。)"

#. type: Plain text
#: ../../user-manual.txt:2996
#, fuzzy
msgid ""
"Note that the files all have mode 644 or 755: git actually only pays "
"attention to the executable bit."
msgstr ""
"注意：ファイルは全て 644 または 755 のモードとなります：実際、git は 実行パー"
"ミッションだけを管理しています。"

#. type: Title ~
#: ../../user-manual.txt:2999
#, fuzzy, no-wrap
msgid "Blob Object"
msgstr "Blob オブジェクト"

#. type: Plain text
#: ../../user-manual.txt:3003
#, fuzzy
msgid ""
"You can use linkgit:git-show[1] to examine the contents of a blob; take, for "
"example, the blob in the entry for \"COPYING\" from the tree above:"
msgstr ""
"linkgit:git-show[1] を使用すると blob の内容を参照できます； 例として、上記ツ"
"リーの blob エントリ \"COPYING\" を確認します："

#. type: delimited block -
#: ../../user-manual.txt:3006
#, fuzzy, no-wrap
msgid "$ git show 6ff87c4664\n"
msgstr "$ git show 6ff87c4664\n"

#. type: delimited block -
#: ../../user-manual.txt:3011
#, fuzzy, no-wrap
msgid ""
" Note that the only valid version of the GPL as far as this project\n"
" is concerned is _this_ particular version of the license (ie v2, not\n"
" v2.2 or v3.x or whatever), unless explicitly otherwise stated.\n"
"...\n"
msgstr ""
" Note that the only valid version of the GPL as far as this project\n"
" is concerned is _this_ particular version of the license (ie v2, not\n"
" v2.2 or v3.x or whatever), unless explicitly otherwise stated.\n"
"...\n"

#. type: Plain text
#: ../../user-manual.txt:3015
#, fuzzy
msgid ""
"A \"blob\" object is nothing but a binary blob of data.  It doesn't refer to "
"anything else or have attributes of any kind."
msgstr ""
"\"blob\" オブジェクトはバイナリの blob データであるにすぎません。 参照や属性"
"といったものは持っていません。"

#. type: Plain text
#: ../../user-manual.txt:3021
#, fuzzy
msgid ""
"Since the blob is entirely defined by its data, if two files in a directory "
"tree (or in multiple different versions of the repository)  have the same "
"contents, they will share the same blob object. The object is totally "
"independent of its location in the directory tree, and renaming a file does "
"not change the object that file is associated with."
msgstr ""
"blob はそれ自身のデータによって完全に定義されるため、 ディレクトリツリー内(ま"
"たはリポジトリ内の異なるバージョン)に ２つのファイルがあり、それらが同じ内容"
"であるなら、同じ blob オブジェクトを 共有します。オブジェクトはディレクトリツ"
"リーの位置に完全に独立しており、 ファイル名を変更してもそれに対応するオブジェ"
"クトは変更されません。"

#. type: Plain text
#: ../../user-manual.txt:3026
#, fuzzy
msgid ""
"Note that any tree or blob object can be examined using linkgit:git-show[1] "
"with the <revision>:<path> syntax.  This can sometimes be useful for "
"browsing the contents of a tree that is not currently checked out."
msgstr ""
"注意：全ての tree と blob オブジェクトは linkgit:git-show[1] に <revision>:"
"<path> の引数を付けて実行することができます。 これにより、現在チェックアウト"
"していないツリーの中身を ブラウズすることができます。"

#. type: Title ~
#: ../../user-manual.txt:3029
#, fuzzy, no-wrap
msgid "Trust"
msgstr "Trust"

#. type: Plain text
#: ../../user-manual.txt:3036
#, fuzzy
msgid ""
"If you receive the SHA-1 name of a blob from one source, and its contents "
"from another (possibly untrusted) source, you can still trust that those "
"contents are correct as long as the SHA-1 name agrees.  This is because the "
"SHA-1 is designed so that it is infeasible to find different contents that "
"produce the same hash."
msgstr ""
"あるソースから blob の SHA-1値と(信頼できないかもしれない)ソースの中身 を受け"
"取ったとします。この場合でも SHA-1値が一致する限りはその内容が 正しいと信頼す"
"ることができます。何故なら SHA-1値は同じハッシュ値を生成 する異なるファイルを"
"見つけることが困難なように設計されているからです。"

#. type: Plain text
#: ../../user-manual.txt:3043
#, fuzzy
msgid ""
"Similarly, you need only trust the SHA-1 name of a top-level tree object to "
"trust the contents of the entire directory that it refers to, and if you "
"receive the SHA-1 name of a commit from a trusted source, then you can "
"easily verify the entire history of commits reachable through parents of "
"that commit, and all of those contents of the trees referred to by those "
"commits."
msgstr ""
"同様に、トップレベルのツリーオブジェクトの SHA-1値を信頼するだけで それが参照"
"する全ディレクトリの内容を信頼することができます。 また、信頼するソースからコ"
"ミットのSHA-1値を受け取ったなら、 そのコミットの親から到達可能なコミットの全"
"履歴とコミットが参照する ツリーの内容全てを容易に信頼することができます。"

#. type: Plain text
#: ../../user-manual.txt:3049
#, fuzzy
msgid ""
"So to introduce some real trust in the system, the only thing you need to do "
"is to digitally sign just 'one' special note, which includes the name of a "
"top-level commit.  Your digital signature shows others that you trust that "
"commit, and the immutability of the history of commits tells others that "
"they can trust the whole history."
msgstr ""
"従ってトップレベルのコミット名を含む '一つの' 特定のノートに デジタル署名する"
"だけで、システムに信頼性を持たせることができます。 デジタル署名はあなたがその"
"コミットを信頼していることを示し、 コミット履歴の不変性は全ての履歴が信頼でき"
"ることを示しています。"

#. type: Plain text
#: ../../user-manual.txt:3054
#, fuzzy
msgid ""
"In other words, you can easily validate a whole archive by just sending out "
"a single email that tells the people the name (SHA-1 hash)  of the top "
"commit, and digitally sign that email using something like GPG/PGP."
msgstr ""
"言い換えると、トップレベルのコミットのSHA-1値を伝えるメールを作成し、 GPG/PGP"
"でデジタル署名するだけで、容易に全ての履歴の妥当性を示す ことができるというこ"
"とです。"

#. type: Plain text
#: ../../user-manual.txt:3056
#, fuzzy
msgid "To assist in this, git also provides the tag object..."
msgstr "この仕組みを支援するため、gitはtagオブジェクトも用意しています。"

#. type: Title ~
#: ../../user-manual.txt:3059
#, fuzzy, no-wrap
msgid "Tag Object"
msgstr "タグオブジェクト"

#. type: Plain text
#: ../../user-manual.txt:3064
#, fuzzy
msgid ""
"A tag object contains an object, object type, tag name, the name of the "
"person (\"tagger\") who created the tag, and a message, which may contain a "
"signature, as can be seen using linkgit:git-cat-file[1]:"
msgstr ""
"tag オブジェクトはオブジェクトとオブジェクトタイプ、タグ名、 タグの作成者、"
"メッセージ(これには署名が付けられることがあります)を 含んでいます。このこと"
"は linkgit:git-cat-file[1] で確認できます:"

#. type: delimited block -
#: ../../user-manual.txt:3071
#, fuzzy, no-wrap
msgid ""
"$ git cat-file tag v1.5.0\n"
"object 437b1b20df4b356c9342dac8d38849f24ef44f27\n"
"type commit\n"
"tag v1.5.0\n"
"tagger Junio C Hamano <junkio@cox.net> 1171411200 +0000\n"
msgstr ""
"$ git cat-file tag v1.5.0\n"
"object 437b1b20df4b356c9342dac8d38849f24ef44f27\n"
"type commit\n"
"tag v1.5.0\n"
"tagger Junio C Hamano <junkio@cox.net> 1171411200 +0000\n"

#. type: delimited block -
#: ../../user-manual.txt:3075
#, fuzzy, no-wrap
msgid ""
"GIT 1.5.0\n"
"-----BEGIN PGP SIGNATURE-----\n"
"Version: GnuPG v1.4.6 (GNU/Linux)\n"
msgstr ""
"GIT 1.5.0\n"
"-----BEGIN PGP SIGNATURE-----\n"
"Version: GnuPG v1.4.6 (GNU/Linux)\n"

#. type: delimited block -
#: ../../user-manual.txt:3080
#, fuzzy, no-wrap
msgid ""
"iD8DBQBF0lGqwMbZpPMRm5oRAuRiAJ9ohBLd7s2kqjkKlq1qqC57SbnmzQCdG4ui\n"
"nLE/L9aUXdWeTFPron96DLA=\n"
"=2E+0\n"
"-----END PGP SIGNATURE-----\n"
msgstr ""
"iD8DBQBF0lGqwMbZpPMRm5oRAuRiAJ9ohBLd7s2kqjkKlq1qqC57SbnmzQCdG4ui\n"
"nLE/L9aUXdWeTFPron96DLA=\n"
"=2E+0\n"
"-----END PGP SIGNATURE-----\n"

#. type: Plain text
#: ../../user-manual.txt:3086
#, fuzzy
msgid ""
"See the linkgit:git-tag[1] command to learn how to create and verify tag "
"objects.  (Note that linkgit:git-tag[1] can also be used to create "
"\"lightweight tags\", which are not tag objects at all, but just simple "
"references whose names begin with \"refs/tags/\")."
msgstr ""
"タグの作成方法と検証方法は linkgit:git-tag[1] コマンドを参照してください。 "
"(注意: linkgit:git-tag[1] は'軽量'タグを作成することもできます。 これは、tag"
"オブジェクトとは全く異なるもので、'refs/tags/'で始まる 単なる参照です)"

#. type: Title ~
#: ../../user-manual.txt:3089
#, fuzzy, no-wrap
msgid "How git stores objects efficiently: pack files"
msgstr "gitがどのようにオブジェクトを効率的に保管するか： packファイル"

#. type: Plain text
#: ../../user-manual.txt:3093
#, fuzzy
msgid ""
"Newly created objects are initially created in a file named after the "
"object's SHA-1 hash (stored in .git/objects)."
msgstr ""
"新規作成されたオブジェクトは最初はオブジェクトの SHA-1ハッシュ値の 名前でファ"
"イルとして保存されます(.git/objects 内に保管されます)。"

#. type: Plain text
#: ../../user-manual.txt:3096
#, fuzzy
msgid ""
"Unfortunately this system becomes inefficient once a project has a lot of "
"objects.  Try this on an old project:"
msgstr ""
"残念なことに、プロジェクトに大量のオブジェクトが作成されると、 この仕組みでは"
"不十分になります。古いプロジェクトで以下を実行 してみてください:"

#. type: delimited block -
#: ../../user-manual.txt:3100
#, fuzzy, no-wrap
msgid ""
"$ git count-objects\n"
"6930 objects, 47620 kilobytes\n"
msgstr ""
"$ git count-objects\n"
"6930 objects, 47620 kilobytes\n"

#. type: Plain text
#: ../../user-manual.txt:3105
#, fuzzy
msgid ""
"The first number is the number of objects which are kept in individual "
"files.  The second is the amount of space taken up by those \"loose\" "
"objects."
msgstr ""
"最初の数字はファイルとして保管されているオブジェクト数です。 二つ目の数字はこ"
"れらの \"遊離した\" オブジェクトによって消費される 容量の合計値です。"

#. type: Plain text
#: ../../user-manual.txt:3110
#, fuzzy
msgid ""
"You can save space and make git faster by moving these loose objects in to a "
"\"pack file\", which stores a group of objects in an efficient compressed "
"format; the details of how pack files are formatted can be found in link:"
"technical/pack-format.txt[technical/pack-format.txt]."
msgstr ""
"これら遊離したオブジェクトを \"packファイル\" に移動することで ディスク容量を"
"節約し、またgitを高速化することができます。 pack ファイルはオブジェクトのグ"
"ループを十分に圧縮した形式で保管します: packファイル形式の詳細は link:"
"technical/pack-format.txt[technical/pack-format.txt] を参照してください。"

#. type: Plain text
#: ../../user-manual.txt:3112
#, fuzzy
msgid "To put the loose objects into a pack, just run git repack:"
msgstr ""
"遊離したオブジェクトを pack に移動するには、git repack を実行するだけです:"

#. type: delimited block -
#: ../../user-manual.txt:3123
#, fuzzy, no-wrap
msgid ""
"$ git repack\n"
"Generating pack...\n"
"Done counting 6020 objects.\n"
"Deltifying 6020 objects.\n"
" 100% (6020/6020) done\n"
"Writing 6020 objects.\n"
" 100% (6020/6020) done\n"
"Total 6020, written 6020 (delta 4070), reused 0 (delta 0)\n"
"Pack pack-3e54ad29d5b2e05838c75df582c65257b8d08e1c created.\n"
msgstr ""
"$ git repack\n"
"Generating pack...\n"
"Done counting 6020 objects.\n"
"Deltifying 6020 objects.\n"
" 100% (6020/6020) done\n"
"Writing 6020 objects.\n"
" 100% (6020/6020) done\n"
"Total 6020, written 6020 (delta 4070), reused 0 (delta 0)\n"
"Pack pack-3e54ad29d5b2e05838c75df582c65257b8d08e1c created.\n"

#. type: Plain text
#: ../../user-manual.txt:3126
#, fuzzy
msgid "You can then run"
msgstr "その後、"

#. type: delimited block -
#: ../../user-manual.txt:3129 ../../user-manual.txt:3220
#, fuzzy, no-wrap
msgid "$ git prune\n"
msgstr "$ git prune\n"

#. type: Plain text
#: ../../user-manual.txt:3135
#, fuzzy
msgid ""
"to remove any of the \"loose\" objects that are now contained in the pack.  "
"This will also remove any unreferenced objects (which may be created when, "
"for example, you use \"git reset\" to remove a commit).  You can verify that "
"the loose objects are gone by looking at the .git/objects directory or by "
"running"
msgstr ""
"を実行すると pack に含まれる全ての \"遊離した\" オブジェクトは削除されます。 "
"この操作は参照されていないオブジェクト(例えば、\"git reset\" によって コミッ"
"トを削除した場合などに作成される)も全て削除します。 遊離したオブジェクトが削"
"除されたことは .git/objects ディレクトリを 見るか、次のコマンドを実行すること"
"で確認できます。"

#. type: delimited block -
#: ../../user-manual.txt:3139
#, fuzzy, no-wrap
msgid ""
"$ git count-objects\n"
"0 objects, 0 kilobytes\n"
msgstr ""
"$ git count-objects\n"
"0 objects, 0 kilobytes\n"

#. type: Plain text
#: ../../user-manual.txt:3143
#, fuzzy
msgid ""
"Although the object files are gone, any commands that refer to those objects "
"will work exactly as they did before."
msgstr ""
"オブジェクトファイルが削除されても、そのオブジェクトを参照する 全てのコマンド"
"は以前と同じように動作します。"

#. type: Plain text
#: ../../user-manual.txt:3146
#, fuzzy
msgid ""
"The linkgit:git-gc[1] command performs packing, pruning, and more for you, "
"so is normally the only high-level command you need."
msgstr ""
"The linkgit:git-gc[1] コマンドは repack、prune などを実行してくれるので 通常"
"は高レベルであるこのコマンドのみ使用します。"

#. type: Title ~
#: ../../user-manual.txt:3149
#, fuzzy, no-wrap
msgid "Dangling objects"
msgstr "Dangling オブジェクト"

#. type: Plain text
#: ../../user-manual.txt:3153
#, fuzzy
msgid ""
"The linkgit:git-fsck[1] command will sometimes complain about dangling "
"objects.  They are not a problem."
msgstr ""
"linkgit:git-fsck[1] コマンドは dangling オブジェクトに関する メッセージを表示"
"することがありますが、これは問題ではありません。"

#. type: Plain text
#: ../../user-manual.txt:3159
#, fuzzy
msgid ""
"The most common cause of dangling objects is that you've rebased a branch, "
"or you have pulled from somebody else who rebased a branch--see <<cleaning-"
"up-history>>.  In that case, the old head of the original branch still "
"exists, as does everything it pointed to. The branch pointer itself just "
"doesn't, since you replaced it with another one."
msgstr ""
"dangling オブジェクトが作成される主な原因は ブランチをリベースした場合や、 他"
"のユーザがリベースしたブランチを pull した場合です。 -- <<cleaning-up-"
"history>> 参照。この場合、ブランチの古い head は まだ存在していて、head が参"
"照していたオブジェクトも全て残っています。 ブランチのポインタは、他の場所に移"
"しかえられているので、存在しませんが。"

#. type: Plain text
#: ../../user-manual.txt:3167
#, fuzzy
msgid ""
"There are also other situations that cause dangling objects. For example, a "
"\"dangling blob\" may arise because you did a \"git add\" of a file, but "
"then, before you actually committed it and made it part of the bigger "
"picture, you changed something else in that file and committed that "
"*updated* thing--the old state that you added originally ends up not being "
"pointed to by any commit or tree, so it's now a dangling blob object."
msgstr ""
"dangling オブジェクトが作成される他の例もあります。 例えば、ファイルを \"git "
"add\" したが、そのファイルに別の変更を加えて コミットしたような場合です。 -- "
"この場合、もともと add していた内容は、どのコミットとツリーにも 参照されず、"
"dangling blob オブジェクトとなります。"

#. type: Plain text
#: ../../user-manual.txt:3175
#, fuzzy
msgid ""
"Similarly, when the \"recursive\" merge strategy runs, and finds that there "
"are criss-cross merges and thus more than one merge base (which is fairly "
"unusual, but it does happen), it will generate one temporary midway tree (or "
"possibly even more, if you had lots of criss-crossing merges and more than "
"two merge bases) as a temporary internal merge base, and again, those are "
"real objects, but the end result will not end up pointing to them, so they "
"end up \"dangling\" in your repository."
msgstr ""
"同様に、\"再帰的に\" マージを実行した際に、マージ内容が複雑で 複数のマージ"
"ベースが存在するような場合(あまり発生することはありませんが)には、 中間状態の"
"ツリーが一時的に作成されます。これら中間状態の作成時に オブジェクトが作成され"
"ますが、それらは最終的なマージ結果では 参照されることがありません。従ってこれ"
"らも \"dangling\" となります。"

#. type: Plain text
#: ../../user-manual.txt:3181
#, fuzzy
msgid ""
"Generally, dangling objects aren't anything to worry about. They can even be "
"very useful: if you screw something up, the dangling objects can be how you "
"recover your old tree (say, you did a rebase, and realized that you really "
"didn't want to--you can look at what dangling objects you have, and decide "
"to reset your head to some old dangling state)."
msgstr ""
"一般に、dangling オブジェクトが存在しても心配する必要はありません。 どちらか"
"といえば、それらは役に立つものです：何か操作間違いをした時に、 dangling オブ"
"ジェクトを使用すると元の状態に戻すことができます。 (リベースした後に誤りに気"
"が付いた時、 ある古い dangling の状態に head をリセットすることができます)"

#. type: Plain text
#: ../../user-manual.txt:3183
#, fuzzy
msgid "For commits, you can just use:"
msgstr "commit の場合は、次のようにします："

#. type: delimited block -
#: ../../user-manual.txt:3186
#, fuzzy, no-wrap
msgid "$ gitk <dangling-commit-sha-goes-here> --not --all\n"
msgstr "$ gitk <dangling-commit-sha-goes-here> --not --all\n"

#. type: Plain text
#: ../../user-manual.txt:3191
#, fuzzy
msgid ""
"This asks for all the history reachable from the given commit but not from "
"any branch, tag, or other reference.  If you decide it's something you want, "
"you can always create a new reference to it, e.g.,"
msgstr ""
"これは、指定したコミットから到達可能だが他のブランチやタグ、その他の参照から"
"は 到達できない履歴すべてを表示します。そのうちのどれかが望むものであるな"
"ら、 新しい参照を作成します、例えば次のように。"

#. type: delimited block -
#: ../../user-manual.txt:3194
#, fuzzy, no-wrap
msgid "$ git branch recovered-branch <dangling-commit-sha-goes-here>\n"
msgstr "$ git branch recovered-branch <dangling-commit-sha-goes-here>\n"

#. type: Plain text
#: ../../user-manual.txt:3198
#, fuzzy
msgid ""
"For blobs and trees, you can't do the same, but you can still examine them.  "
"You can just do"
msgstr ""
"blob と tree の場合は、同じようにはできませんが、 次のようにして確認すること"
"ができます。"

#. type: delimited block -
#: ../../user-manual.txt:3201
#, fuzzy, no-wrap
msgid "$ git show <dangling-blob/tree-sha-goes-here>\n"
msgstr "$ git show <dangling-blob/tree-sha-goes-here>\n"

#. type: Plain text
#: ../../user-manual.txt:3206
#, fuzzy
msgid ""
"to show what the contents of the blob were (or, for a tree, basically what "
"the \"ls\" for that directory was), and that may give you some idea of what "
"the operation was that left that dangling object."
msgstr ""
"これは、blob の中身が何であるか(ツリーの場合、ディレクトリの \"ls\" の内容)  "
"を表示するので、その dangling オブジェクトを残すのにどのような操作が 必要とな"
"るかを教えてくれるでしょう。"

#. type: Plain text
#: ../../user-manual.txt:3214
#, fuzzy
msgid ""
"Usually, dangling blobs and trees aren't very interesting. They're almost "
"always the result of either being a half-way mergebase (the blob will often "
"even have the conflict markers from a merge in it, if you have had "
"conflicting merges that you fixed up by hand), or simply because you "
"interrupted a \"git fetch\" with ^C or something like that, leaving _some_ "
"of the new objects in the object database, but just dangling and useless."
msgstr ""
"通常、dangling blob と tree はあまり必要になることはありません。 大抵はコンフ"
"リクトマーカのついたマージの途中状態であるか、 \"git fetch\" を Ctrl+C や何か"
"で中断した際に作成されたもので、 宙ぶらりんで役に立ちません。"

#. type: Plain text
#: ../../user-manual.txt:3217
#, fuzzy
msgid ""
"Anyway, once you are sure that you're not interested in any dangling state, "
"you can just prune all unreachable objects:"
msgstr ""
"いずれにしろ、dangling 状態に興味がないことを確認したのなら、 到達できないオ"
"ブジェクト全てを破棄することができます："

#. type: Plain text
#: ../../user-manual.txt:3225
#, fuzzy
msgid ""
"and they'll be gone. But you should only run \"git prune\" on a quiescent "
"repository--it's kind of like doing a filesystem fsck recovery: you don't "
"want to do that while the filesystem is mounted."
msgstr ""
"\"git prune\" は必ず休止状態にあるリポジトリでだけ実行してください。 -- これ"
"はファイルシステムの fsck によるリカバリのようなものです： ファイルシステムが"
"マウントされている時には行なうべきではありません。"

#. type: Plain text
#: ../../user-manual.txt:3233
#, fuzzy
msgid ""
"(The same is true of \"git fsck\" itself, btw, but since `git fsck` never "
"actually *changes* the repository, it just reports on what it found, `git "
"fsck` itself is never 'dangerous' to run.  Running it while somebody is "
"actually changing the repository can cause confusing and scary messages, but "
"it won't actually do anything bad. In contrast, running \"git prune\" while "
"somebody is actively changing the repository is a *BAD* idea)."
msgstr ""
"(\"git fsck\" についてもこれと同じことが言えます。ところで、 `git fsck` は実"
"際に決してリポジトリを変更することはなく、 検出されたものを報告するだけで、実"
"行しても危険なものではありません。 誰かがリポジトリを変更している最中に実行し"
"た場合、 紛らわしく恐ろしいメッセージが表示されますが、悪いことは行なわれませ"
"ん。 それとは反対に \"git prune\" を他のユーザがリポジトリを変更している最中"
"に 実行するのは *悪い* アイデアです。)"

#. type: Title ~
#: ../../user-manual.txt:3236
#, fuzzy, no-wrap
msgid "Recovering from repository corruption"
msgstr "リポジトリの破損からの復旧"

#. type: Plain text
#: ../../user-manual.txt:3241
#, fuzzy
msgid ""
"By design, git treats data trusted to it with caution.  However, even in the "
"absence of bugs in git itself, it is still possible that hardware or "
"operating system errors could corrupt data."
msgstr ""
"git は意図的にデータを慎重に扱います。しかし、git 自身にバグがなかったとして"
"も ハードウェアやオペレーティングシステムのエラーによりデータが壊れることがあ"
"ります。"

#. type: Plain text
#: ../../user-manual.txt:3245
#, fuzzy
msgid ""
"The first defense against such problems is backups.  You can back up a git "
"directory using clone, or just using cp, tar, or any other backup mechanism."
msgstr ""
"そのような問題に対する第１の防御はバックアップです。 clone コマンドを使用する"
"か cp, tar または他のバックアップメカニズムを 使用して git ディレクトリをバッ"
"クアップすることができます。"

#. type: Plain text
#: ../../user-manual.txt:3249
#, fuzzy
msgid ""
"As a last resort, you can search for the corrupted objects and attempt to "
"replace them by hand.  Back up your repository before attempting this in "
"case you corrupt things even more in the process."
msgstr ""
"最後の手段は、破損したオブジェクトを探し出して手作業で置き換えることです。 破"
"損しかかっている最中であっても、作業をする前にリポジトリを バックアップしてく"
"ださい。"

#. type: Plain text
#: ../../user-manual.txt:3253
#, fuzzy
msgid ""
"We'll assume that the problem is a single missing or corrupted blob, which "
"is sometimes a solvable problem.  (Recovering missing trees and especially "
"commits is *much* harder)."
msgstr ""
"１つの blob が紛失または破損している場合を考えます。 そのような場合は時に解決"
"できることがあります。 (ツリー、そして特にコミットの紛失から復旧する場合はよ"
"り困難です)"

#. type: Plain text
#: ../../user-manual.txt:3256
#, fuzzy
msgid ""
"Before starting, verify that there is corruption, and figure out where it is "
"with linkgit:git-fsck[1]; this may be time-consuming."
msgstr ""
"開始する前に、破損している箇所を linkgit:git-fsck[1] を使用して 確認します；"
"これには多大な時間を必要とするかもしれません。"

#. type: Plain text
#: ../../user-manual.txt:3258
#, fuzzy
msgid "Assume the output looks like this:"
msgstr "次のように出力されたとします："

#. type: delimited block -
#: ../../user-manual.txt:3264
#, fuzzy, no-wrap
msgid ""
"$ git fsck --full\n"
"broken link from    tree 2d9263c6d23595e7cb2a21e5ebbb53655278dff8\n"
"              to    blob 4b9458b3786228369c63936db65827de3cc06200\n"
"missing blob 4b9458b3786228369c63936db65827de3cc06200\n"
msgstr ""
"$ git fsck --full\n"
"broken link from    tree 2d9263c6d23595e7cb2a21e5ebbb53655278dff8\n"
"              to    blob 4b9458b3786228369c63936db65827de3cc06200\n"
"missing blob 4b9458b3786228369c63936db65827de3cc06200\n"

#. type: Plain text
#: ../../user-manual.txt:3268
#, fuzzy
msgid ""
"(Typically there will be some \"dangling object\" messages too, but they "
"aren't interesting.)"
msgstr ""
"(通常、これらと一緒に \"dangling オブジェクト\" のメッセージも表示 されます"
"が、これらは興味深いものではありません)"

#. type: Plain text
#: ../../user-manual.txt:3272
#, fuzzy
msgid ""
"Now you know that blob 4b9458b3 is missing, and that the tree 2d9263c6 "
"points to it.  If you could find just one copy of that missing blob object, "
"possibly in some other repository, you could move it into"
msgstr ""
"4b9458b3 の blob が紛失しており、2d9263c6 のツリーが それを参照していることが"
"わかります。その紛失したblobのコピーを 他のリポジトリなどから見つけることがで"
"きるなら、それを"

#. type: Block title
#: ../../user-manual.txt:3272
#, fuzzy, no-wrap
msgid "git/objects/4b/9458b3... and be done.  Suppose you can't.  You can"
msgstr "git/objects/4b/9458b3... に移動すれば修復は完了です。もしそれが"

#. type: Plain text
#: ../../user-manual.txt:3275
#, fuzzy
msgid ""
"still examine the tree that pointed to it with linkgit:git-ls-tree[1], which "
"might output something like:"
msgstr ""
"できない場合でも、linkgit:git-ls-tree[1] を用いて、それが何を指し示して いる"
"かを確認することができます："

#. type: delimited block -
#: ../../user-manual.txt:3284
#, fuzzy, no-wrap
msgid ""
"$ git ls-tree 2d9263c6d23595e7cb2a21e5ebbb53655278dff8\n"
"100644 blob 8d14531846b95bfa3564b58ccfb7913a034323b8\t.gitignore\n"
"100644 blob ebf9bf84da0aab5ed944264a5db2a65fe3a3e883\t.mailmap\n"
"100644 blob ca442d313d86dc67e0a2e5d584b465bd382cbf5c\tCOPYING\n"
"...\n"
"100644 blob 4b9458b3786228369c63936db65827de3cc06200\tmyfile\n"
"...\n"
msgstr ""
"$ git ls-tree 2d9263c6d23595e7cb2a21e5ebbb53655278dff8\n"
"100644 blob 8d14531846b95bfa3564b58ccfb7913a034323b8\t.gitignore\n"
"100644 blob ebf9bf84da0aab5ed944264a5db2a65fe3a3e883\t.mailmap\n"
"100644 blob ca442d313d86dc67e0a2e5d584b465bd382cbf5c\tCOPYING\n"
"...\n"
"100644 blob 4b9458b3786228369c63936db65827de3cc06200\tmyfile\n"
"...\n"

#. type: Plain text
#: ../../user-manual.txt:3292
#, fuzzy
msgid ""
"So now you know that the missing blob was the data for a file named \"myfile"
"\".  And chances are you can also identify the directory--let's say it's in "
"\"somedirectory\".  If you're lucky the missing copy might be the same as "
"the copy you have checked out in your working tree at \"somedirectory/myfile"
"\"; you can test whether that's right with linkgit:git-hash-object[1]:"
msgstr ""
"これにより、紛失した blob が \"myfile\" という名前のファイルデータであること"
"が わかります。そして、それがあるディレクトリも特定できたとします-- "
"\"somedirectory\" とします。運よくチェックアウトした作業ツリー内の "
"\"somedirectory/myfile\" にそれと同じコピーがあるのなら、 linkgit:git-hash-"
"object[1] を用いてそれが正しいかどうかをテストできます。"

#. type: delimited block -
#: ../../user-manual.txt:3295
#, fuzzy, no-wrap
msgid "$ git hash-object -w somedirectory/myfile\n"
msgstr "$ git hash-object -w somedirectory/myfile\n"

#. type: Plain text
#: ../../user-manual.txt:3301
#, fuzzy
msgid ""
"which will create and store a blob object with the contents of somedirectory/"
"myfile, and output the SHA-1 of that object.  if you're extremely lucky it "
"might be 4b9458b3786228369c63936db65827de3cc06200, in which case you've "
"guessed right, and the corruption is fixed!"
msgstr ""
"これにより、somedirectory/myfile の内容をもった blob オブジェクトを 作成して"
"格納し、そのオブジェクトの SHA-1 を表示します。 その値が "
"4b9458b3786228369c63936db65827de3cc06200 であったなら あなたは非常に幸運で"
"す。この場合、あなたの推測は正しく、破損は 修復されました！"

#. type: Plain text
#: ../../user-manual.txt:3304
#, fuzzy
msgid ""
"Otherwise, you need more information.  How do you tell which version of the "
"file has been lost?"
msgstr ""
"一致しなかった場合、より詳しい情報が必要になります。 そのファイルのどのバー"
"ジョンを無くしたかを確認します。"

#. type: Plain text
#: ../../user-manual.txt:3306
#, fuzzy
msgid "The easiest way to do this is with:"
msgstr "最も簡単な方法は、次のとおりです："

#. type: delimited block -
#: ../../user-manual.txt:3309
#, fuzzy, no-wrap
msgid "$ git log --raw --all --full-history -- somedirectory/myfile\n"
msgstr "$ git log --raw --all --full-history -- somedirectory/myfile\n"

#. type: Plain text
#: ../../user-manual.txt:3312
#, fuzzy
msgid "Because you're asking for raw output, you'll now get something like"
msgstr "生データを出力しているため、次のような出力が得られます"

#. type: delimited block -
#: ../../user-manual.txt:3319
#, fuzzy, no-wrap
msgid ""
"commit abc\n"
"Author:\n"
"Date:\n"
"...\n"
":100644 100644 4b9458b... newsha... M somedirectory/myfile\n"
msgstr ""
"commit abc\n"
"Author:\n"
"Date:\n"
"...\n"
":100644 100644 4b9458b... newsha... M somedirectory/myfile\n"

#. type: delimited block -
#: ../../user-manual.txt:3324
#, fuzzy, no-wrap
msgid ""
"commit xyz\n"
"Author:\n"
"Date:\n"
msgstr ""
"commit xyz\n"
"Author:\n"
"Date:\n"

#. type: delimited block -
#: ../../user-manual.txt:3327
#, fuzzy, no-wrap
msgid ""
"...\n"
":100644 100644 oldsha... 4b9458b... M somedirectory/myfile\n"
msgstr ""
"...\n"
":100644 100644 oldsha... 4b9458b... M somedirectory/myfile\n"

#. type: Plain text
#: ../../user-manual.txt:3333
#, fuzzy
msgid ""
"This tells you that the immediately preceding version of the file was "
"\"newsha\", and that the immediately following version was \"oldsha\".  You "
"also know the commit messages that went with the change from oldsha to "
"4b9458b and with the change from 4b9458b to newsha."
msgstr ""
"これはすぐ前のファイルのバージョンが \"newsha\" であり、すぐ後のバージョンが "
"\"oldsha1\" であることを示しています。 また、oldsha から 4b9458b の変更点と "
"4b9458b から newsha での変更点 のコミットメッセージについても知ることができま"
"す。"

#. type: Plain text
#: ../../user-manual.txt:3336
#, fuzzy
msgid ""
"If you've been committing small enough changes, you may now have a good shot "
"at reconstructing the contents of the in-between state 4b9458b."
msgstr ""
"変更内容が十分小さい場合、4b9458b の状態の内容を再作成することが できるかもし"
"れません。"

#. type: Plain text
#: ../../user-manual.txt:3338
#, fuzzy
msgid "If you can do that, you can now recreate the missing object with"
msgstr ""
"もしそれができたのなら、紛失したオブジェクトを次のようにして 再作成することが"
"できます。"

#. type: delimited block -
#: ../../user-manual.txt:3341
#, fuzzy, no-wrap
msgid "$ git hash-object -w <recreated-file>\n"
msgstr "$ git hash-object -w <recreated-file>\n"

#. type: Plain text
#: ../../user-manual.txt:3344
#, fuzzy
msgid "and your repository is good again!"
msgstr "これにより、リポジトリは正常に戻ります！"

#. type: Plain text
#: ../../user-manual.txt:3346
#, fuzzy
msgid "(Btw, you could have ignored the fsck, and started with doing a"
msgstr "(ところで、fsck を無視することもできます。次のようにして、"

#. type: delimited block -
#: ../../user-manual.txt:3349
#, fuzzy, no-wrap
msgid "$ git log --raw --all\n"
msgstr "$ git log --raw --all\n"

#. type: Plain text
#: ../../user-manual.txt:3354
#, fuzzy
msgid ""
"and just looked for the sha of the missing object (4b9458b..) in that whole "
"thing. It's up to you - git does *have* a lot of information, it is just "
"missing one particular blob version."
msgstr ""
"紛失したオブジェクト(4b9458b..)の sha を探し出します。-git はたくさんの情報を"
"持っていますが、紛失したのは１つの特定の blob バージョンであるにすぎません)"

#. type: Title -
#: ../../user-manual.txt:3357
#, fuzzy, no-wrap
msgid "The index"
msgstr "索引(index)"

#. type: Plain text
#: ../../user-manual.txt:3362
#, fuzzy
msgid ""
"The index is a binary file (generally kept in .git/index) containing a "
"sorted list of path names, each with permissions and the SHA-1 of a blob "
"object; linkgit:git-ls-files[1] can show you the contents of the index:"
msgstr ""
"索引はバイナリファイル(通常 .git/index 内に保管)であり、 ソートされたパス名"
"と、パーミッション、blob の SHA-1値の一覧を含んでいます； linkgit:git-ls-"
"files[1] を使用すると索引の中身を参照できます："

#. type: delimited block -
#: ../../user-manual.txt:3374
#, fuzzy, no-wrap
msgid ""
"$ git ls-files --stage\n"
"100644 63c918c667fa005ff12ad89437f2fdc80926e21c 0\t.gitignore\n"
"100644 5529b198e8d14decbe4ad99db3f7fb632de0439d 0\t.mailmap\n"
"100644 6ff87c4664981e4397625791c8ea3bbb5f2279a3 0\tCOPYING\n"
"100644 a37b2152bd26be2c2289e1f57a292534a51a93c7 0\tDocumentation/.gitignore\n"
"100644 fbefe9a45b00a54b58d94d06eca48b03d40a50e0 0\tDocumentation/Makefile\n"
"...\n"
"100644 2511aef8d89ab52be5ec6a5e46236b4b6bcd07ea 0\txdiff/xtypes.h\n"
"100644 2ade97b2574a9f77e7ae4002a4e07a6a38e46d07 0\txdiff/xutils.c\n"
"100644 d5de8292e05e7c36c4b68857c1cf9855e3d2f70a 0\txdiff/xutils.h\n"
msgstr ""
"$ git ls-files --stage\n"
"100644 63c918c667fa005ff12ad89437f2fdc80926e21c 0\t.gitignore\n"
"100644 5529b198e8d14decbe4ad99db3f7fb632de0439d 0\t.mailmap\n"
"100644 6ff87c4664981e4397625791c8ea3bbb5f2279a3 0\tCOPYING\n"
"100644 a37b2152bd26be2c2289e1f57a292534a51a93c7 0\tDocumentation/.gitignore\n"
"100644 fbefe9a45b00a54b58d94d06eca48b03d40a50e0 0\tDocumentation/Makefile\n"
"...\n"
"100644 2511aef8d89ab52be5ec6a5e46236b4b6bcd07ea 0\txdiff/xtypes.h\n"
"100644 2ade97b2574a9f77e7ae4002a4e07a6a38e46d07 0\txdiff/xutils.c\n"
"100644 d5de8292e05e7c36c4b68857c1cf9855e3d2f70a 0\txdiff/xutils.h\n"

#. type: Plain text
#: ../../user-manual.txt:3379
#, fuzzy
msgid ""
"Note that in older documentation you may see the index called the \"current "
"directory cache\" or just the \"cache\".  It has three important properties:"
msgstr ""
"古いドキュメントでは、\"現在のディレクトリキャッシュ\" または単に \"キャッ"
"シュ\" と呼んでいることがあります。索引には３つの重要な 性質があります："

#. type: Plain text
#: ../../user-manual.txt:3382
#, fuzzy
msgid ""
"The index contains all the information necessary to generate a single "
"(uniquely determined) tree object."
msgstr ""
"索引は１つの(ユニークに決定される)ツリーオブジェクトを 生成するのに必要な情報"
"全てを含んでいます。"

#. type: Plain text
#: ../../user-manual.txt:3386
#, fuzzy
msgid ""
"For example, running linkgit:git-commit[1] generates this tree object from "
"the index, stores it in the object database, and uses it as the tree object "
"associated with the new commit."
msgstr ""
"例えば、linkgit:git-commit[1] を実行すると、索引から 新しいコミットが参照す"
"る tree オブジェクトを生成し、オブジェクトＤＢに 格納します。"

#. type: Plain text
#: ../../user-manual.txt:3389
#, fuzzy
msgid ""
"The index enables fast comparisons between the tree object it defines and "
"the working tree."
msgstr ""
"索引は索引が定義する tree オブジェクトと 作業ツリーとを高速に比較することがで"
"きます。"

#. type: Plain text
#: ../../user-manual.txt:3396
#, fuzzy
msgid ""
"It does this by storing some additional data for each entry (such as the "
"last modified time).  This data is not displayed above, and is not stored in "
"the created tree object, but it can be used to determine quickly which files "
"in the working directory differ from what was stored in the index, and thus "
"save git from having to read all of the data from such files to look for "
"changes."
msgstr ""
"これは、各エントリに対する追加情報(最終更新日のようなもの)を 格納することで行"
"なわれます。このデータは上記には表示されず、 tree オブジェクトを作成する時に"
"は格納されませんが、 変更されているファイルと索引に格納されているファイルを "
"高速に確認するために使用できます。この仕組みが git がデータの 全てを読み込み"
"変更を探す作業を手助けします。"

#. type: Plain text
#: ../../user-manual.txt:3401
#, fuzzy
msgid ""
"It can efficiently represent information about merge conflicts between "
"different tree objects, allowing each pathname to be associated with "
"sufficient information about the trees involved that you can create a three-"
"way merge between them."
msgstr ""
"異なるツリーオブジェクト間のコンフリクトの情報を表現することができ、 各パス名"
"は3-way マージを行なうときに作成されるツリーの情報を 持つことができます。"

#. type: Plain text
#: ../../user-manual.txt:3407
#, fuzzy
msgid ""
"We saw in <<conflict-resolution>> that during a merge the index can store "
"multiple versions of a single file (called \"stages\").  The third column in "
"the linkgit:git-ls-files[1] output above is the stage number, and will take "
"on values other than 0 for files with merge conflicts."
msgstr ""
"<<conflict-resolution>> で見たように、マージしている間、 1つのファイルの(\"ス"
"テージ\"と呼ばれる)複数のバージョンを格納する ことができます。linkgit:git-ls-"
"files[1] の出力の3つ目のカラムは ステージの番号で、コンフリクトしたファイルに"
"は０より大きい値が 付けられます。"

#. type: Plain text
#: ../../user-manual.txt:3410
#, fuzzy
msgid ""
"The index is thus a sort of temporary staging area, which is filled with a "
"tree which you are in the process of working on."
msgstr ""
"このように索引は一時的な作業エリアの役割をし、 作業中のツリーの内容が詰められ"
"ています。"

#. type: Plain text
#: ../../user-manual.txt:3413
#, fuzzy
msgid ""
"If you blow the index away entirely, you generally haven't lost any "
"information as long as you have the name of the tree that it described."
msgstr ""
"索引を完全に消し去ると、それを記述していたツリーの名前を 持っていない限りは、"
"全ての情報を失ってしまいます。"

#. type: Title =
#: ../../user-manual.txt:3416
#, fuzzy, no-wrap
msgid "Submodules"
msgstr "サブモジュール"

#. type: Plain text
#: ../../user-manual.txt:3424
#, fuzzy
msgid ""
"Large projects are often composed of smaller, self-contained modules.  For "
"example, an embedded Linux distribution's source tree would include every "
"piece of software in the distribution with some local modifications; a movie "
"player might need to build against a specific, known-working version of a "
"decompression library; several independent programs might all share the same "
"build scripts."
msgstr ""
"大きなプロジェクトは自己完結したより小さいプロジェクトを含む場合があります。 "
"例えば、組み込みLinuxディストリビュションのソースツリーは ディストリビュショ"
"ン内にローカルに変更を加えられたソフトウェアのピースが 含まれています；ムー"
"ビープレーヤーは解凍ライブラリの特定のバージョンで ビルドできるようにする必要"
"があるかもしれません；幾つかの独立したプログラムは 同じビルドスクリプトを共有"
"しているかもしれません。"

#. type: Plain text
#: ../../user-manual.txt:3430
#, fuzzy
msgid ""
"With centralized revision control systems this is often accomplished by "
"including every module in one single repository.  Developers can check out "
"all modules or only the modules they need to work with.  They can even "
"modify files across several modules in a single commit while moving things "
"around or updating APIs and translations."
msgstr ""
"集中型のリビジョン管理システムでは、１つのリポジトリ内に各モジュールを含む こ"
"とによってこれを実現します。開発者は全てのモジュールあるいは必要なモジュール "
"だけをチェックアウトすることができます。API や翻訳の移動や更新といった 幾つか"
"のモジュールにまたがったファイルを1回のコミットで変更することができます。"

#. type: Plain text
#: ../../user-manual.txt:3436
#, fuzzy
msgid ""
"Git does not allow partial checkouts, so duplicating this approach in Git "
"would force developers to keep a local copy of modules they are not "
"interested in touching.  Commits in an enormous checkout would be slower "
"than you'd expect as Git would have to scan every directory for changes.  If "
"modules have a lot of local history, clones would take forever."
msgstr ""
"Gitは部分的なチェックアウトを許可していない為、Git の複製アプローチでは 開発"
"者は興味のないモジュールのコピーまで取得しなくてはなりません。 Git は各ディレ"
"クトリの変更をスキャンしなくてはならず、 莫大なコミットをチェックアウトするこ"
"とで、想像以上に Git は遅くなります。"

#. type: Plain text
#: ../../user-manual.txt:3444
#, fuzzy
msgid ""
"On the plus side, distributed revision control systems can much better "
"integrate with external sources.  In a centralized model, a single arbitrary "
"snapshot of the external project is exported from its own revision control "
"and then imported into the local revision control on a vendor branch.  All "
"the history is hidden.  With distributed revision control you can clone the "
"entire external history and much more easily follow development and re-merge "
"local changes."
msgstr ""
"一方プラスの面として、分散型のリビジョン管理システムは外部ソースを より良い形"
"で統合します。集中型モデルでは、外部プロジェクトの１つの任意の スナップショッ"
"トをそれ自身のリビジョン管理ツールからエクスポートし、 ローカルのリビジョン管"
"理ツールにベンダーブランチとしてインポートします。 変更履歴は全て隠れてしまい"
"ます。分散型のリビジョン管理システムでは 外部の履歴全てを複製することができ、"
"よりいっそう容易に開発を進め、 ローカルの変更を再マージすることもできます。"

#. type: Plain text
#: ../../user-manual.txt:3452
#, fuzzy
msgid ""
"Git's submodule support allows a repository to contain, as a subdirectory, a "
"checkout of an external project.  Submodules maintain their own identity; "
"the submodule support just stores the submodule repository location and "
"commit ID, so other developers who clone the containing project "
"(\"superproject\") can easily clone all the submodules at the same "
"revision.  Partial checkouts of the superproject are possible: you can tell "
"Git to clone none, some or all of the submodules."
msgstr ""
"Git のサブモジュール機能は外部のプロジェクトを サブディレクトリとしてリポジト"
"リに含ませることができます。 サブモジュールはそれ自身で独自性をもってメンテナ"
"ンスされます； これは、サブモジュールは自身のリポジトリとコミットIDとを持つと"
"いうことであり、 そのサブモジュールを含むプロジェクト(\"親プロジェクト\")を複"
"製した場合、 同じリビジョンのサブモジュールを全て容易に複製できます。 親プロ"
"ジェクトの部分チェックアウトは可能です：サブモジュールを 複製する、しないをサ"
"ブモジュールごとにしていすることができます。"

#. type: Plain text
#: ../../user-manual.txt:3457
#, fuzzy
msgid ""
"The linkgit:git-submodule[1] command is available since Git 1.5.3.  Users "
"with Git 1.5.2 can look up the submodule commits in the repository and "
"manually check them out; earlier versions won't recognize the submodules at "
"all."
msgstr ""
"linkgit:git-submodule[1] コマンドは Git 1.5.3 から利用可能になりました。 Git "
"1.5.2 を使用しているユーザもリポジトリ内のサブモジュールのコミットを 参照し、"
"それらをマニュアルでチェックアウトすることはできます； 初期のバージョンでは全"
"てのサブモジュールを認識することはできないでしょう。"

#. type: Plain text
#: ../../user-manual.txt:3460
#, fuzzy
msgid ""
"To see how submodule support works, create (for example) four example "
"repositories that can be used later as a submodule:"
msgstr ""
"サブモジュールがどのように利用できるかを見るため、 例として４つのリポジトリを"
"作成します："

#. type: delimited block -
#: ../../user-manual.txt:3474
#, fuzzy, no-wrap
msgid ""
"$ mkdir ~/git\n"
"$ cd ~/git\n"
"$ for i in a b c d\n"
"do\n"
"\tmkdir $i\n"
"\tcd $i\n"
"\tgit init\n"
"\techo \"module $i\" > $i.txt\n"
"\tgit add $i.txt\n"
"\tgit commit -m \"Initial commit, submodule $i\"\n"
"\tcd ..\n"
"done\n"
msgstr ""
"$ mkdir ~/git\n"
"$ cd ~/git\n"
"$ for i in a b c d\n"
"do\n"
"\tmkdir $i\n"
"\tcd $i\n"
"\tgit init\n"
"\techo \"module $i\" > $i.txt\n"
"\tgit add $i.txt\n"
"\tgit commit -m \"Initial commit, submodule $i\"\n"
"\tcd ..\n"
"done\n"

#. type: Plain text
#: ../../user-manual.txt:3477
#, fuzzy
msgid "Now create the superproject and add all the submodules:"
msgstr "そして、親プロジェクトを作成し、全てのサブモジュールを追加します："

#. type: delimited block -
#: ../../user-manual.txt:3486
#, fuzzy, no-wrap
msgid ""
"$ mkdir super\n"
"$ cd super\n"
"$ git init\n"
"$ for i in a b c d\n"
"do\n"
"\tgit submodule add ~/git/$i $i\n"
"done\n"
msgstr ""
"$ mkdir super\n"
"$ cd super\n"
"$ git init\n"
"$ for i in a b c d\n"
"do\n"
"\tgit submodule add ~/git/$i $i\n"
"done\n"

#. type: Plain text
#: ../../user-manual.txt:3489
#, fuzzy
msgid "Do not use local URLs here if you plan to publish your superproject!"
msgstr ""
"注意：親プロジェクトを公開する予定がある場合は、ローカルのURLは使用しないでく"
"ださい！"

#. type: Plain text
#: ../../user-manual.txt:3491
#, fuzzy
msgid "See what files `git submodule` created:"
msgstr "`git submodule` がどのようなファイルを作成するか見ましょう："

#. type: delimited block -
#: ../../user-manual.txt:3495
#, fuzzy, no-wrap
msgid ""
"$ ls -a\n"
".  ..  .git  .gitmodules  a  b  c  d\n"
msgstr ""
"$ ls -a\n"
".  ..  .git  .gitmodules  a  b  c  d\n"

#. type: Plain text
#: ../../user-manual.txt:3498
#, fuzzy
msgid "The `git submodule add <repo> <path>` command does a couple of things:"
msgstr "`git submodule add <repo> <path>` コマンドは幾つかのことをしています："

#. type: Plain text
#: ../../user-manual.txt:3501
#, fuzzy
msgid ""
"It clones the submodule from <repo> to the given <path> under the current "
"directory and by default checks out the master branch."
msgstr ""
"カレントディレクトリ下の <path> に <repo> からサブモジュールの複製を作成し、 "
"デフォルトではマスターブランチをチェックアウトします。"

#. type: Plain text
#: ../../user-manual.txt:3503
#, fuzzy
msgid ""
"It adds the submodule's clone path to the linkgit:gitmodules[5] file and "
"adds this file to the index, ready to be committed."
msgstr ""
"サブモジュールの複製パスを linkgit:gitmodules[5] ファイルに追加し、 このファ"
"イルを索引に追加し、コミット可能な状態にします。"

#. type: Plain text
#: ../../user-manual.txt:3505
#, fuzzy
msgid ""
"It adds the submodule's current commit ID to the index, ready to be "
"committed."
msgstr ""
"サブモジュールの現在のコミットID を索引に追加し、 コミット可能な状態にしま"
"す。"

#. type: Plain text
#: ../../user-manual.txt:3507
#, fuzzy
msgid "Commit the superproject:"
msgstr "親プロジェクトをコミットします："

#. type: delimited block -
#: ../../user-manual.txt:3510
#, fuzzy, no-wrap
msgid "$ git commit -m \"Add submodules a, b, c and d.\"\n"
msgstr "$ git commit -m \"Add submodules a, b, c and d.\"\n"

#. type: Plain text
#: ../../user-manual.txt:3513
#, fuzzy
msgid "Now clone the superproject:"
msgstr "そして、親プロジェクトを複製してみます："

#. type: delimited block -
#: ../../user-manual.txt:3518
#, fuzzy, no-wrap
msgid ""
"$ cd ..\n"
"$ git clone super cloned\n"
"$ cd cloned\n"
msgstr ""
"$ cd ..\n"
"$ git clone super cloned\n"
"$ cd cloned\n"

#. type: Plain text
#: ../../user-manual.txt:3521
#, fuzzy
msgid "The submodule directories are there, but they're empty:"
msgstr "サブモジュールのディレクトリが作成されていますが、それらは空です："

#. type: delimited block -
#: ../../user-manual.txt:3530
#, fuzzy, no-wrap
msgid ""
"$ ls -a a\n"
".  ..\n"
"$ git submodule status\n"
"-d266b9873ad50488163457f025db7cdd9683d88b a\n"
"-e81d457da15309b4fef4249aba9b50187999670d b\n"
"-c1536a972b9affea0f16e0680ba87332dc059146 c\n"
"-d96249ff5d57de5de093e6baff9e0aafa5276a74 d\n"
msgstr ""
"$ ls -a a\n"
".  ..\n"
"$ git submodule status\n"
"-d266b9873ad50488163457f025db7cdd9683d88b a\n"
"-e81d457da15309b4fef4249aba9b50187999670d b\n"
"-c1536a972b9affea0f16e0680ba87332dc059146 c\n"
"-d96249ff5d57de5de093e6baff9e0aafa5276a74 d\n"

#. type: Plain text
#: ../../user-manual.txt:3535
#, fuzzy
msgid ""
"The commit object names shown above would be different for you, but they "
"should match the HEAD commit object names of your repositories.  You can "
"check it by running `git ls-remote ../a`."
msgstr ""
"注意：あなたの環境では、コミットオブジェクトの名前が上記のものとは 違っている"
"かもしれません。しかし、それらはあなたのリポジトリの HEAD コミットの オブジェ"
"クト名と一致しているはずです。このことは `git ls-remote ../a` で 確認できま"
"す。"

#. type: Plain text
#: ../../user-manual.txt:3538
#, fuzzy
msgid ""
"Pulling down the submodules is a two-step process. First run `git submodule "
"init` to add the submodule repository URLs to `.git/config`:"
msgstr ""
"サブモジュールの取得は２つの手順で行ないます。まず `git submodule init` を実"
"行しサブモジュールのリポジトリURLを `.git/config` に追加します："

#. type: delimited block -
#: ../../user-manual.txt:3541
#, fuzzy, no-wrap
msgid "$ git submodule init\n"
msgstr "$ git submodule init\n"

#. type: Plain text
#: ../../user-manual.txt:3545
#, fuzzy
msgid ""
"Now use `git submodule update` to clone the repositories and check out the "
"commits specified in the superproject:"
msgstr ""
"そして `git subumodule update` を実行すると、リポジトリの複製と 親プロジェク"
"トにて指定されているコミットをチェックアウトが行われます："

#. type: delimited block -
#: ../../user-manual.txt:3551
#, fuzzy, no-wrap
msgid ""
"$ git submodule update\n"
"$ cd a\n"
"$ ls -a\n"
".  ..  .git  a.txt\n"
msgstr ""
"$ git submodule update\n"
"$ cd a\n"
"$ ls -a\n"
".  ..  .git  a.txt\n"

#. type: Plain text
#: ../../user-manual.txt:3557
#, fuzzy
msgid ""
"One major difference between `git submodule update` and `git submodule add` "
"is that `git submodule update` checks out a specific commit, rather than the "
"tip of a branch. It's like checking out a tag: the head is detached, so "
"you're not working on a branch."
msgstr ""
"`git submodule update` と `git submodule add` の間の大きな違いは `git "
"submodule update` が特定のコミットをチェックアウトするのに対し `git "
"submodule add` はブランチの先端をチェックアウトするという点です。 それは、タ"
"グをチェックアウトするのに似ています： つまり head から引き離され、ブランチ上"
"に位置しません。"

#. type: delimited block -
#: ../../user-manual.txt:3562
#, fuzzy, no-wrap
msgid ""
"$ git branch\n"
"* (no branch)\n"
"  master\n"
msgstr ""
"$ git branch\n"
"* (no branch)\n"
"  master\n"

#. type: Plain text
#: ../../user-manual.txt:3568
#, fuzzy
msgid ""
"If you want to make a change within a submodule and you have a detached "
"head, then you should create or checkout a branch, make your changes, "
"publish the change within the submodule, and then update the superproject to "
"reference the new commit:"
msgstr ""
"head から引き離されているサブモジュール内で変更を加えたい場合は、 ブランチを"
"作成またはチェックアウトし、変更を加え、サブモジュール内の変更を 公開し、新し"
"いコミットを参照するように親プロジェクトを更新します："

#. type: delimited block -
#: ../../user-manual.txt:3571
#, fuzzy, no-wrap
msgid "$ git checkout master\n"
msgstr "$ git checkout master\n"

#. type: delimited block -
#: ../../user-manual.txt:3577
#, fuzzy, no-wrap
msgid "$ git checkout -b fix-up\n"
msgstr "$ git checkout -b fix-up\n"

#. type: Plain text
#: ../../user-manual.txt:3580
#, fuzzy
msgid "then"
msgstr "そして、"

#. type: delimited block -
#: ../../user-manual.txt:3597
#, fuzzy, no-wrap
msgid ""
"$ echo \"adding a line again\" >> a.txt\n"
"$ git commit -a -m \"Updated the submodule from within the superproject.\"\n"
"$ git push\n"
"$ cd ..\n"
"$ git diff\n"
"diff --git a/a b/a\n"
"index d266b98..261dfac 160000\n"
"--- a/a\n"
"+++ b/a\n"
"@@ -1 +1 @@\n"
"-Subproject commit d266b9873ad50488163457f025db7cdd9683d88b\n"
"+Subproject commit 261dfac35cb99d380eb966e102c1197139f7fa24\n"
"$ git add a\n"
"$ git commit -m \"Updated submodule a.\"\n"
"$ git push\n"
msgstr ""
"$ echo \"adding a line again\" >> a.txt\n"
"$ git commit -a -m \"Updated the submodule from within the superproject.\"\n"
"$ git push\n"
"$ cd ..\n"
"$ git diff\n"
"diff --git a/a b/a\n"
"index d266b98..261dfac 160000\n"
"--- a/a\n"
"+++ b/a\n"
"@@ -1 +1 @@\n"
"-Subproject commit d266b9873ad50488163457f025db7cdd9683d88b\n"
"+Subproject commit 261dfac35cb99d380eb966e102c1197139f7fa24\n"
"$ git add a\n"
"$ git commit -m \"Updated submodule a.\"\n"
"$ git push\n"

#. type: Plain text
#: ../../user-manual.txt:3601
#, fuzzy
msgid ""
"You have to run `git submodule update` after `git pull` if you want to "
"update submodules, too."
msgstr ""
"サブモジュールも更新したい場合は、 `git pull` をした後に `git submodule "
"update` を実行します。"

#. type: Title -
#: ../../user-manual.txt:3603
#, fuzzy, no-wrap
msgid "Pitfalls with submodules"
msgstr "サブモジュールの落し穴"

#. type: Plain text
#: ../../user-manual.txt:3608
#, fuzzy
msgid ""
"Always publish the submodule change before publishing the change to the "
"superproject that references it. If you forget to publish the submodule "
"change, others won't be able to clone the repository:"
msgstr ""
"サブモジュールを参照する親プロジェクトの変更を公開する前には 必ずサブモジュー"
"ルの変更を公開してください。もしサブモジュールの変更を 公開し忘れた場合、リポ"
"ジトリを複製できなくなるでしょう："

#. type: delimited block -
#: ../../user-manual.txt:3623
#, fuzzy, no-wrap
msgid ""
"$ cd ~/git/super/a\n"
"$ echo i added another line to this file >> a.txt\n"
"$ git commit -a -m \"doing it wrong this time\"\n"
"$ cd ..\n"
"$ git add a\n"
"$ git commit -m \"Updated submodule a again.\"\n"
"$ git push\n"
"$ cd ~/git/cloned\n"
"$ git pull\n"
"$ git submodule update\n"
"error: pathspec '261dfac35cb99d380eb966e102c1197139f7fa24' did not match any file(s) known to git.\n"
"Did you forget to 'git add'?\n"
"Unable to checkout '261dfac35cb99d380eb966e102c1197139f7fa24' in submodule path 'a'\n"
msgstr ""
"$ cd ~/git/super/a\n"
"$ echo i added another line to this file >> a.txt\n"
"$ git commit -a -m \"doing it wrong this time\"\n"
"$ cd ..\n"
"$ git add a\n"
"$ git commit -m \"Updated submodule a again.\"\n"
"$ git push\n"
"$ cd ~/git/cloned\n"
"$ git pull\n"
"$ git submodule update\n"
"error: pathspec '261dfac35cb99d380eb966e102c1197139f7fa24' did not match any file(s) known to git.\n"
"Did you forget to 'git add'?\n"
"Unable to checkout '261dfac35cb99d380eb966e102c1197139f7fa24' in submodule path 'a'\n"

#. type: Plain text
#: ../../user-manual.txt:3627
#, fuzzy
msgid ""
"You also should not rewind branches in a submodule beyond commits that were "
"ever recorded in any superproject."
msgstr ""
"親プロジェクトにより記録されたコミットよりも手前にサブモジュールのブランチを "
"巻き戻すべきではありません。"

#. type: Plain text
#: ../../user-manual.txt:3631
#, fuzzy
msgid ""
"It's not safe to run `git submodule update` if you've made and committed "
"changes within a submodule without checking out a branch first. They will be "
"silently overwritten:"
msgstr ""
"そうした場合、ブランチを最初にチェックアウトせずにサブモジュール内の変更を コ"
"ミットした時に `git submodule update` は安全に動作しません。 何も言わずに変更"
"を上書きしてしまいます。"

#. type: delimited block -
#: ../../user-manual.txt:3643
#, fuzzy, no-wrap
msgid ""
"$ cat a.txt\n"
"module a\n"
"$ echo line added from private2 >> a.txt\n"
"$ git commit -a -m \"line added inside private2\"\n"
"$ cd ..\n"
"$ git submodule update\n"
"Submodule path 'a': checked out 'd266b9873ad50488163457f025db7cdd9683d88b'\n"
"$ cd a\n"
"$ cat a.txt\n"
"module a\n"
msgstr ""
"$ cat a.txt\n"
"module a\n"
"$ echo line added from private2 >> a.txt\n"
"$ git commit -a -m \"line added inside private2\"\n"
"$ cd ..\n"
"$ git submodule update\n"
"Submodule path 'a': checked out 'd266b9873ad50488163457f025db7cdd9683d88b'\n"
"$ cd a\n"
"$ cat a.txt\n"
"module a\n"

#. type: Plain text
#: ../../user-manual.txt:3646
#, fuzzy
msgid "The changes are still visible in the submodule's reflog."
msgstr "注意：変更はサブモジュールの reflog にまだ残っています。"

#. type: Plain text
#: ../../user-manual.txt:3648
#, fuzzy
msgid "This is not the case if you did not commit your changes."
msgstr "ただし、変更をコミットしていない場合は残っていません。"

#. type: Title =
#: ../../user-manual.txt:3651
#, fuzzy, no-wrap
msgid "Low-level git operations"
msgstr "下位レベルの git 操作"

#. type: Plain text
#: ../../user-manual.txt:3657
#, fuzzy
msgid ""
"Many of the higher-level commands were originally implemented as shell "
"scripts using a smaller core of low-level git commands.  These can still be "
"useful when doing unusual things with git, or just as a way to understand "
"its inner workings."
msgstr ""
"多くの上位レベルコマンドは、より小さくコアとなっている下位レベルの git コマン"
"ド を使用したシェルスクリプトで元々は実装されています。 下位レベルのコマンド"
"は通常は行なわないようなことを git で行なう場合や 内部の仕組みを理解する手段"
"として役に立つ場合があります。"

#. type: Title -
#: ../../user-manual.txt:3660
#, fuzzy, no-wrap
msgid "Object access and manipulation"
msgstr "オブジェクトのアクセスと操作"

#. type: Plain text
#: ../../user-manual.txt:3664
#, fuzzy
msgid ""
"The linkgit:git-cat-file[1] command can show the contents of any object, "
"though the higher-level linkgit:git-show[1] is usually more useful."
msgstr ""
"linkgit:git-cat-file[1] コマンドは任意のオブジェクトの中身を表示する ことがで"
"きますが、上位の linkgit:git-show[1] の方が通常は便利です。"

#. type: Plain text
#: ../../user-manual.txt:3667
#, fuzzy
msgid ""
"The linkgit:git-commit-tree[1] command allows constructing commits with "
"arbitrary parents and trees."
msgstr ""
"linkgit:git-commit-tree[1] コマンドを用いると任意の親とツリーで コミットを構"
"成させることができます。"

#. type: Plain text
#: ../../user-manual.txt:3671
#, fuzzy
msgid ""
"A tree can be created with linkgit:git-write-tree[1] and its data can be "
"accessed by linkgit:git-ls-tree[1].  Two trees can be compared with linkgit:"
"git-diff-tree[1]."
msgstr ""
"linkgit:git-write-tree[1] を用いるとツリーを作成することができ、 その中身は "
"linkgit:git-ls-tree[1] でアクセスできます。２つのツリーは linkgit:git-diff-"
"tree[1] で比較することができます。"

#. type: Plain text
#: ../../user-manual.txt:3675
#, fuzzy
msgid ""
"A tag is created with linkgit:git-mktag[1], and the signature can be "
"verified by linkgit:git-verify-tag[1], though it is normally simpler to use "
"linkgit:git-tag[1] for both."
msgstr ""
"タグは linkgit:git-mktag[1] で作成でき、その署名は linkgit:git-verify-tag[1] "
"で検証することができます。しかし、これら２つは linkgit:git-tag[1] を 使用する"
"と同じようなことができます。"

#. type: Title -
#: ../../user-manual.txt:3678
#, fuzzy, no-wrap
msgid "The Workflow"
msgstr "ワークフロー"

#. type: Plain text
#: ../../user-manual.txt:3685
#, fuzzy
msgid ""
"High-level operations such as linkgit:git-commit[1], linkgit:git-checkout[1] "
"and linkgit:git-reset[1] work by moving data between the working tree, the "
"index, and the object database.  Git provides low-level operations which "
"perform each of these steps individually."
msgstr ""
"linkgit:git-commit[1]、linkgit:git-checkout[1]、linkgit:git-reset[1] のような"
"高レベルの操作は作業ツリー、索引、オブジェクトＤＢ間の データを移動することに"
"よって仕事をします。 Git はこれらの各ステップを独立に行なう下位レベルの操作を"
"提供しています。"

#. type: Plain text
#: ../../user-manual.txt:3691
#, fuzzy
msgid ""
"Generally, all \"git\" operations work on the index file. Some operations "
"work *purely* on the index file (showing the current state of the index), "
"but most operations move data between the index file and either the database "
"or the working directory. Thus there are four main combinations:"
msgstr ""
"一般に、全ての \"git\" 操作は索引ファイル上で作用します。 いくつかの操作は *"
"純粋に* 索引ファイル(現在の索引の状態を表示)  上で作用しますが、ほとんどの操"
"作は索引ファイルとデータベース又は 作業ディレクトリ間のデータを移動します。"
"従って、主に４つの組み合わせがあります："

#. type: Title ~
#: ../../user-manual.txt:3694
#, fuzzy, no-wrap
msgid "working directory -> index"
msgstr "作業ディレクトリ → 索引"

#. type: Plain text
#: ../../user-manual.txt:3700
#, fuzzy
msgid ""
"The linkgit:git-update-index[1] command updates the index with information "
"from the working directory.  You generally update the index information by "
"just specifying the filename you want to update, like so:"
msgstr ""
"linkgit:git-update-index[1] コマンドは作業ディレクトリの情報を 索引に更新しま"
"す。一般には更新したいファイルを特定して 索引の情報を更新します、次のように："

#. type: delimited block -
#: ../../user-manual.txt:3703
#, fuzzy, no-wrap
msgid "$ git update-index filename\n"
msgstr "$ git update-index filename\n"

#. type: Plain text
#: ../../user-manual.txt:3708
#, fuzzy
msgid ""
"but to avoid common mistakes with filename globbing etc, the command will "
"not normally add totally new entries or remove old entries, i.e. it will "
"normally just update existing cache entries."
msgstr ""
"しかし、ファイル名を補完した際などの間違いを防ぐため、 このコマンドは新しいエ"
"ントリや削除された古いエントリを 自動的に追加することはありません。即ち、存在"
"するキャッシュエントリを単に更新するだけです。"

#. type: Plain text
#: ../../user-manual.txt:3712
#, fuzzy
msgid ""
"To tell git that yes, you really do realize that certain files no longer "
"exist, or that new files should be added, you should use the `--remove` and "
"`--add` flags respectively."
msgstr ""
"あるファイルを削除する場合は `--remove` フラグを、 新しいファイルを追加する場"
"合は `--add` フラグを使用します。"

#. type: Plain text
#: ../../user-manual.txt:3719
#, fuzzy
msgid ""
"NOTE! A `--remove` flag does 'not' mean that subsequent filenames will "
"necessarily be removed: if the files still exist in your directory "
"structure, the index will be updated with their new status, not removed. The "
"only thing `--remove` means is that update-index will be considering a "
"removed file to be a valid thing, and if the file really does not exist any "
"more, it will update the index accordingly."
msgstr ""
"注意！ `--remove` フラグを使用しても必ずしもそのファイルが削除される わけでは"
"ありません：ファイルがディレクトリ内にまだ存在する場合、 索引は新しいステータ"
"スに更新されますが、ファイルは削除されません。 `--remove` はファイルが削除さ"
"れたのが正しいことであることが 索引の更新時に考慮されることを意味しているだけ"
"であり、 もしファイルが本当に存在しないのなら索引をそれに従い更新するだけで"
"す。"

#. type: Plain text
#: ../../user-manual.txt:3725
#, fuzzy
msgid ""
"As a special case, you can also do `git update-index --refresh`, which will "
"refresh the \"stat\" information of each index to match the current stat "
"information. It will 'not' update the object status itself, and it will only "
"update the fields that are used to quickly test whether an object still "
"matches its old backing store object."
msgstr ""
"`git update-index --refresh` という特別なオプションもあります。 これは現在の "
"\"stat\" 情報に一致する各索引の \"stat\" 情報を リフレッシュします。オブジェ"
"クトのステータス自身は更新せず、 オブジェクトが過去に格納されたオブジェクトと"
"まだ一致している かを素早くテストする為に使用されるフィールドだけを更新しま"
"す。"

#. type: Plain text
#: ../../user-manual.txt:3728
#, fuzzy
msgid ""
"The previously introduced linkgit:git-add[1] is just a wrapper for linkgit:"
"git-update-index[1]."
msgstr ""
"以前紹介した linkgit:git-add[1] は linkgit:git-update-index[1] の 単なるラッ"
"パースクリプトです。"

#. type: Title ~
#: ../../user-manual.txt:3731
#, fuzzy, no-wrap
msgid "index -> object database"
msgstr "索引 → オブジェクトＤＢ"

#. type: Plain text
#: ../../user-manual.txt:3734
#, fuzzy
msgid "You write your current index file to a \"tree\" object with the program"
msgstr "現在の索引ファイルを \"tree\" オブジェクトに書く為には、プログラム"

#. type: delimited block -
#: ../../user-manual.txt:3737
#, fuzzy, no-wrap
msgid "$ git write-tree\n"
msgstr "$ git write-tree\n"

#. type: Plain text
#: ../../user-manual.txt:3744
#, fuzzy
msgid ""
"that doesn't come with any options--it will just write out the current index "
"into the set of tree objects that describe that state, and it will return "
"the name of the resulting top-level tree. You can use that tree to re-"
"generate the index at any time by going in the other direction:"
msgstr ""
"を使用します。これにはオプションがありません。-- これは その状態を記述する現"
"在の索引をツリーオブジェクトの集合へと 書き出す役目をし、トップレベルのツリー"
"の名前を返却します。 このツリーはいつでも索引を再生成する為に利用できます。"

#. type: Title ~
#: ../../user-manual.txt:3747
#, fuzzy, no-wrap
msgid "object database -> index"
msgstr "オブジェクトＤＢ → 索引"

#. type: Plain text
#: ../../user-manual.txt:3753
#, fuzzy
msgid ""
"You read a \"tree\" file from the object database, and use that to populate "
"(and overwrite--don't do this if your index contains any unsaved state that "
"you might want to restore later!) your current index.  Normal operation is "
"just"
msgstr ""
"オブジェクトＤＢから \"tree\" ファイルを読み込み、現在の索引を そのツリーの状"
"態と同じにするには次のようにします。 (索引が後で元に戻す可能性がある未保存の"
"状態を含む場合にはこれをしないでください！)"

#. type: delimited block -
#: ../../user-manual.txt:3756
#, fuzzy, no-wrap
msgid "$ git read-tree <SHA-1 of tree>\n"
msgstr "$ git read-tree <SHA-1 of tree>\n"

#. type: Plain text
#: ../../user-manual.txt:3761
#, fuzzy
msgid ""
"and your index file will now be equivalent to the tree that you saved "
"earlier. However, that is only your 'index' file: your working directory "
"contents have not been modified."
msgstr ""
"これにより索引ファイルは過去に保存したツリーと同じ状態になります。 しかし、そ"
"れは 'index' ファイルに対してだけです：作業ディレクトリは 何も変更されていま"
"せん。"

#. type: Title ~
#: ../../user-manual.txt:3764
#, fuzzy, no-wrap
msgid "index -> working directory"
msgstr "索引 → 作業ディレクトリ"

#. type: Plain text
#: ../../user-manual.txt:3771
#, fuzzy
msgid ""
"You update your working directory from the index by \"checking out\" files. "
"This is not a very common operation, since normally you'd just keep your "
"files updated, and rather than write to your working directory, you'd tell "
"the index files about the changes in your working directory (i.e. `git "
"update-index`)."
msgstr ""
"You update your working directory from the index by \"checking out\" files. "
"This is not a very common operation, since normally you'd just keep your "
"files updated, and rather than write to your working directory, you'd tell "
"the index files about the changes in your working directory (i.e. `git "
"update-index`)."

#. type: Plain text
#: ../../user-manual.txt:3776
#, fuzzy
msgid ""
"However, if you decide to jump to a new version, or check out somebody "
"else's version, or just restore a previous tree, you'd populate your index "
"file with read-tree, and then you need to check out the result with"
msgstr ""
"However, if you decide to jump to a new version, or check out somebody "
"else's version, or just restore a previous tree, you'd populate your index "
"file with read-tree, and then you need to check out the result with"

#. type: delimited block -
#: ../../user-manual.txt:3779
#, fuzzy, no-wrap
msgid "$ git checkout-index filename\n"
msgstr "$ git checkout-index filename\n"

#. type: Plain text
#: ../../user-manual.txt:3782
#, fuzzy
msgid "or, if you want to check out all of the index, use `-a`."
msgstr "あるいは、全ての索引をチェックアウトしたい場合は `-a` を使用します。"

#. type: Plain text
#: ../../user-manual.txt:3787
#, fuzzy
msgid ""
"NOTE! `git checkout-index` normally refuses to overwrite old files, so if "
"you have an old version of the tree already checked out, you will need to "
"use the \"-f\" flag ('before' the \"-a\" flag or the filename) to 'force' "
"the checkout."
msgstr ""
"注意！ `git checkout-index` は通常、古いファイルを上書きすることを居します。 "
"従って、チェックアウト済みの古いバージョンのツリーを持っている場合、 (\"-a\" "
"フラグ又はファイル名の'前に') \"-f\" フラグを使用し、'強制的に' チェックアウ"
"トする必要があります。"

#. type: Plain text
#: ../../user-manual.txt:3791
#, fuzzy
msgid ""
"Finally, there are a few odds and ends which are not purely moving from one "
"representation to the other:"
msgstr "最後に、一方から他方への純粋な移動ではないものを説明します："

#. type: Title ~
#: ../../user-manual.txt:3794
#, fuzzy, no-wrap
msgid "Tying it all together"
msgstr "機能間の連携"

#. type: Plain text
#: ../../user-manual.txt:3800
#, fuzzy
msgid ""
"To commit a tree you have instantiated with \"git write-tree\", you'd create "
"a \"commit\" object that refers to that tree and the history behind it--most "
"notably the \"parent\" commits that preceded it in history."
msgstr ""
"\"git write-tree\" で作成したツリーをコミットするには、 そのツリーと背後にあ"
"る履歴(つまり、その履歴とつながる\"親の\"コミット)  を参照する \"commit\" オ"
"ブジェクトを作成します。"

#. type: Plain text
#: ../../user-manual.txt:3806
#, fuzzy
msgid ""
"Normally a \"commit\" has one parent: the previous state of the tree before "
"a certain change was made. However, sometimes it can have two or more parent "
"commits, in which case we call it a \"merge\", due to the fact that such a "
"commit brings together (\"merges\") two or more previous states represented "
"by other commits."
msgstr ""
"通常 \"commit\" は一つの親を持ちます：これはある変更を行った一つ前の ツリー状"
"態を指しています。しかしながら時には二つ以上の親を持つこと もあります。それ"
"は \"マージ\" と言われる場合であり、そのようなコミットは 二つ以上の状態を一つ"
"に纏めます。"

#. type: Plain text
#: ../../user-manual.txt:3810
#, fuzzy
msgid ""
"In other words, while a \"tree\" represents a particular directory state of "
"a working directory, a \"commit\" represents that state in \"time\", and "
"explains how we got there."
msgstr ""
"言い換えると、ツリーがある作業ディレクトリの特定の状態を表す一方、 コミットは"
"その状態の時刻とそこに至った経緯を表します。"

#. type: Plain text
#: ../../user-manual.txt:3813
#, fuzzy
msgid ""
"You create a commit object by giving it the tree that describes the state at "
"the time of the commit, and a list of parents:"
msgstr ""
"コミットを作成するには、コミット時点の状態を表すツリーと親のリストを 渡すこと"
"で作成することができます:"

#. type: delimited block -
#: ../../user-manual.txt:3816
#, fuzzy, no-wrap
msgid "$ git commit-tree <tree> -p <parent> [-p <parent2> ..]\n"
msgstr "$ git commit-tree <tree> -p <parent> [-p <parent2> ..]\n"

#. type: Plain text
#: ../../user-manual.txt:3820
#, fuzzy
msgid ""
"and then giving the reason for the commit on stdin (either through "
"redirection from a pipe or file, or by just typing it at the tty)."
msgstr ""
"コミット時のコメントは標準入力(あるいはパイプやファイルのリダイレクト)  で指"
"定します。"

#. type: Plain text
#: ../../user-manual.txt:3827
#, fuzzy
msgid ""
"`git commit-tree` will return the name of the object that represents that "
"commit, and you should save it away for later use. Normally, you'd commit a "
"new `HEAD` state, and while git doesn't care where you save the note about "
"that state, in practice we tend to just write the result to the file pointed "
"at by `.git/HEAD`, so that we can always see what the last committed state "
"was."
msgstr ""
"`git commit-tree` は作成したコミットのオブジェクト名を返却します。 通常、この"
"名前は `.git/HEAD` ファイルに保存され、その結果、 最後のコミットが何であるか"
"を確認できます。"

#. type: Plain text
#: ../../user-manual.txt:3830
#, fuzzy
msgid ""
"Here is an ASCII art by Jon Loeliger that illustrates how various pieces fit "
"together."
msgstr ""
"以下は Jon Loeliger が作成したテキストのイラストで、 項目間の関係を示していま"
"す。"

#. type: delimited block -
#: ../../user-manual.txt:3864
#, fuzzy, no-wrap
msgid ""
"                     commit-tree\n"
"                      commit obj\n"
"                       +----+\n"
"                       |    |\n"
"                       |    |\n"
"                       V    V\n"
"                    +-----------+\n"
"                    | Object DB |\n"
"                    |  Backing  |\n"
"                    |   Store   |\n"
"                    +-----------+\n"
"                       ^\n"
"           write-tree  |     |\n"
"             tree obj  |     |\n"
"                       |     |  read-tree\n"
"                       |     |  tree obj\n"
"                             V\n"
"                    +-----------+\n"
"                    |   Index   |\n"
"                    |  \"cache\"  |\n"
"                    +-----------+\n"
"         update-index  ^\n"
"             blob obj  |     |\n"
"                       |     |\n"
"    checkout-index -u  |     |  checkout-index\n"
"             stat      |     |  blob obj\n"
"                             V\n"
"                    +-----------+\n"
"                    |  Working  |\n"
"                    | Directory |\n"
"                    +-----------+\n"
msgstr ""
"                     commit-tree\n"
"                      commit obj\n"
"                       +----+\n"
"                       |    |\n"
"                       |    |\n"
"                       V    V\n"
"                    +-----------+\n"
"                    | Object DB |\n"
"                    |  Backing  |\n"
"                    |   Store   |\n"
"                    +-----------+\n"
"                       ^\n"
"           write-tree  |     |\n"
"             tree obj  |     |\n"
"                       |     |  read-tree\n"
"                       |     |  tree obj\n"
"                             V\n"
"                    +-----------+\n"
"                    |   Index   |\n"
"                    |  \"cache\"  |\n"
"                    +-----------+\n"
"         update-index  ^\n"
"             blob obj  |     |\n"
"                       |     |\n"
"    checkout-index -u  |     |  checkout-index\n"
"             stat      |     |  blob obj\n"
"                             V\n"
"                    +-----------+\n"
"                    |  Working  |\n"
"                    | Directory |\n"
"                    +-----------+\n"

#. type: Title -
#: ../../user-manual.txt:3870
#, fuzzy, no-wrap
msgid "Examining the data"
msgstr "データの中身を参照する"

#. type: Plain text
#: ../../user-manual.txt:3876
#, fuzzy
msgid ""
"You can examine the data represented in the object database and the index "
"with various helper tools. For every object, you can use linkgit:git-cat-file"
"[1] to examine details about the object:"
msgstr ""
"様々なヘルパーツールを用いることでオブジェクトDBと 索引の中身を確認することが"
"できます。 各オブジェクトの中身は linkgit:git-cat-file[1] で確認します:"

#. type: delimited block -
#: ../../user-manual.txt:3879
#, fuzzy, no-wrap
msgid "$ git cat-file -t <objectname>\n"
msgstr "$ git cat-file -t <objectname>\n"

#. type: Plain text
#: ../../user-manual.txt:3883
#, fuzzy
msgid ""
"shows the type of the object, and once you have the type (which is usually "
"implicit in where you find the object), you can use"
msgstr ""
"これはオブジェクトのタイプを表示し、タイプを確認した後は 次のようにして、中身"
"を確認することができます。"

#. type: delimited block -
#: ../../user-manual.txt:3886
#, fuzzy, no-wrap
msgid "$ git cat-file blob|tree|commit|tag <objectname>\n"
msgstr "$ git cat-file blob|tree|commit|tag <objectname>\n"

#. type: Plain text
#: ../../user-manual.txt:3892
#, fuzzy
msgid ""
"to show its contents. NOTE! Trees have binary content, and as a result there "
"is a special helper for showing that content, called `git ls-tree`, which "
"turns the binary content into a more easily readable form."
msgstr ""
"注意！ Tree はバイナリであり、その中身を見るには `git ls-tree` という 特別な"
"ツールを使用します。これは、バイナリの内容をより読みやすい形式に 変換してくれ"
"ます。"

#. type: Plain text
#: ../../user-manual.txt:3897
#, fuzzy
msgid ""
"It's especially instructive to look at \"commit\" objects, since those tend "
"to be small and fairly self-explanatory. In particular, if you follow the "
"convention of having the top commit name in `.git/HEAD`, you can do"
msgstr ""
"\"commit\" オブジェクトの中身を見ることはとても教育的です。 それらは小さく、"
"一目瞭然です。特に、 最新のコミット名が `.git/HEAD` にあるという規約を使用し"
"すると、"

#. type: delimited block -
#: ../../user-manual.txt:3900
#, fuzzy, no-wrap
msgid "$ git cat-file commit HEAD\n"
msgstr "$ git cat-file commit HEAD\n"

#. type: Plain text
#: ../../user-manual.txt:3903
#, fuzzy
msgid "to see what the top commit was."
msgstr "にて最新コミットの内容を確認できます。"

#. type: Title -
#: ../../user-manual.txt:3906
#, fuzzy, no-wrap
msgid "Merging multiple trees"
msgstr "複数のツリーをマージする"

#. type: Plain text
#: ../../user-manual.txt:3913
#, fuzzy
msgid ""
"Git helps you do a three-way merge, which you can expand to n-way by "
"repeating the merge procedure arbitrary times until you finally \"commit\" "
"the state.  The normal situation is that you'd only do one three-way merge "
"(two parents), and commit it, but if you like to, you can do multiple "
"parents in one go."
msgstr ""
"Git は 3方向マージを行なう手助けをします。これは 任意の回数繰り返すことによ"
"り n方向マージに拡張することができます。 通常は3方向マージ(2つの親によるマー"
"ジ)のみを行ないますが、 複数の親を1回でマージすることもできます。"

#. type: Plain text
#: ../../user-manual.txt:3918
#, fuzzy
msgid ""
"To do a three-way merge, you need the two sets of \"commit\" objects that "
"you want to merge, use those to find the closest common parent (a third "
"\"commit\" object), and then use those commit objects to find the state of "
"the directory (\"tree\" object) at these points."
msgstr ""
"3方向マージをするには、マージする2組の \"commit\" オブジェクトが 必要です。こ"
"れを使用し共通の親(3番目の\"commit\"オブジェクト)を見つけ、 それら commit オ"
"ブジェクトを使用してディレクトリ(\"tree\" オブジェクト)  の状態を探します。"

#. type: Plain text
#: ../../user-manual.txt:3921
#, fuzzy
msgid ""
"To get the \"base\" for the merge, you first look up the common parent of "
"two commits with"
msgstr ""
"マージの \"ベース\" を得るには、まず次のようにして ２つのコミットの共通の親を"
"見つけます。"

#. type: delimited block -
#: ../../user-manual.txt:3924
#, fuzzy, no-wrap
msgid "$ git merge-base <commit1> <commit2>\n"
msgstr "$ git merge-base <commit1> <commit2>\n"

#. type: Plain text
#: ../../user-manual.txt:3929
#, fuzzy
msgid ""
"which will return you the commit they are both based on.  You should now "
"look up the \"tree\" objects of those commits, which you can easily do with "
"(for example)"
msgstr ""
"これは、共通のベースコミットを返却します。 これらコミットの \"tree\" オブジェ"
"クトは次のようにして 容易に見つけることができます。(例えば)"

#. type: delimited block -
#: ../../user-manual.txt:3932
#, fuzzy, no-wrap
msgid "$ git cat-file commit <commitname> | head -1\n"
msgstr "$ git cat-file commit <commitname> | head -1\n"

#. type: Plain text
#: ../../user-manual.txt:3936
#, fuzzy
msgid ""
"since the tree object information is always the first line in a commit "
"object."
msgstr ""
"tree オブジェクトの情報は、コミットオブジェクトの１行目に 常に記述されていま"
"す。"

#. type: Plain text
#: ../../user-manual.txt:3944
#, fuzzy
msgid ""
"Once you know the three trees you are going to merge (the one \"original\" "
"tree, aka the common tree, and the two \"result\" trees, aka the branches "
"you want to merge), you do a \"merge\" read into the index. This will "
"complain if it has to throw away your old index contents, so you should make "
"sure that you've committed those--in fact you would normally always do a "
"merge against your last commit (which should thus match what you have in "
"your current index anyway)."
msgstr ""
"マージしようとする３つのツリー(１つは \"original\"の tree いわゆる 共通の "
"tree、 ２つの \"結果\" tree、いわゆるマージしたいブランチ)を知った後は、 索引"
"に読み込んでそれらを \"マージ\" します。 古い索引の中身を破棄しなくてはならな"
"い場合、エラーを表示します。 従ってそれらをコミットしたか確認してくださ"
"い。-- 実際、通常は常に 最後にコミットした内容をもとにマージします(そのコミッ"
"トは従って 現在の索引の内容と一致します)"

#. type: Plain text
#: ../../user-manual.txt:3946
#, fuzzy
msgid "To do the merge, do"
msgstr "マージをするには次のひょうにします。"

#. type: delimited block -
#: ../../user-manual.txt:3949
#, fuzzy, no-wrap
msgid "$ git read-tree -m -u <origtree> <yourtree> <targettree>\n"
msgstr "$ git read-tree -m -u <origtree> <yourtree> <targettree>\n"

#. type: Plain text
#: ../../user-manual.txt:3954
#, fuzzy
msgid ""
"which will do all trivial merge operations for you directly in the index "
"file, and you can just write the result out with `git write-tree`."
msgstr ""
"これにより、自明のマージ操作は直接索引ファイルに行なわれ、 `git write-tree` "
"を用いてその結果を書き込むことができます。"

#. type: Title -
#: ../../user-manual.txt:3958
#, fuzzy, no-wrap
msgid "Merging multiple trees, continued"
msgstr "複数のツリーをマージする、続き"

#. type: Plain text
#: ../../user-manual.txt:3966
#, fuzzy
msgid ""
"Sadly, many merges aren't trivial. If there are files that have been added, "
"moved or removed, or if both branches have modified the same file, you will "
"be left with an index tree that contains \"merge entries\" in it. Such an "
"index tree can 'NOT' be written out to a tree object, and you will have to "
"resolve any such merge clashes using other tools before you can write out "
"the result."
msgstr ""
"残念なことに、多くのマージは自明ではありませんん。 追加や移動、削除されたファ"
"イルがある場合や、あるいは両方のブランチ で同じファイルが変更されている場"
"合、\"マージエントリ\" を含んだ 索引ツリーが残されます。このような索引ツリー"
"は tree オブジェクトには書き込むことができません。その結果を書き込む前に 他の"
"ツールを使用してコンフリクトを解消する必要があります。"

#. type: Plain text
#: ../../user-manual.txt:3969
#, fuzzy
msgid ""
"You can examine such index state with `git ls-files --unmerged` command.  An "
"example:"
msgstr ""
"このような索引状態は `git ls-files --unmerged` を 用いると確認できます。例え"
"ば："

#. type: delimited block -
#: ../../user-manual.txt:3976
#, fuzzy, no-wrap
msgid ""
"$ git read-tree -m $orig HEAD $target\n"
"$ git ls-files --unmerged\n"
"100644 263414f423d0e4d70dae8fe53fa34614ff3e2860 1\thello.c\n"
"100644 06fa6a24256dc7e560efa5687fa84b51f0263c3a 2\thello.c\n"
"100644 cc44c73eb783565da5831b4d820c962954019b69 3\thello.c\n"
msgstr ""
"$ git read-tree -m $orig HEAD $target\n"
"$ git ls-files --unmerged\n"
"100644 263414f423d0e4d70dae8fe53fa34614ff3e2860 1\thello.c\n"
"100644 06fa6a24256dc7e560efa5687fa84b51f0263c3a 2\thello.c\n"
"100644 cc44c73eb783565da5831b4d820c962954019b69 3\thello.c\n"

#. type: Plain text
#: ../../user-manual.txt:3983
#, fuzzy
msgid ""
"Each line of the `git ls-files --unmerged` output begins with the blob mode "
"bits, blob SHA-1, 'stage number', and the filename.  The 'stage number' is "
"git's way to say which tree it came from: stage 1 corresponds to `$orig` "
"tree, stage 2 `HEAD` tree, and stage3 `$target` tree."
msgstr ""
"`git ls-files --unmerged` の出力の各行は blob のモードビット、 blob の "
"SHA-1、'stage番号'、そしてファイル番号で始まります。 'stage番号' はそれがど"
"の tree から来たかを表す git のやり方です： stage 1 は `$orig` ツリーに対応"
"し、stege 2 は `HEAD` の tree stage 3 `$target` tree です。"

#. type: Plain text
#: ../../user-manual.txt:3994
#, fuzzy
msgid ""
"Earlier we said that trivial merges are done inside `git read-tree -m`.  For "
"example, if the file did not change from `$orig` to `HEAD` nor `$target`, or "
"if the file changed from `$orig` to `HEAD` and `$orig` to `$target` the same "
"way, obviously the final outcome is what is in `HEAD`.  What the above "
"example shows is that file `hello.c` was changed from `$orig` to `HEAD` and `"
"$orig` to `$target` in a different way.  You could resolve this by running "
"your favorite 3-way merge program, e.g.  `diff3`, `merge`, or git's own "
"merge-file, on the blob objects from these three stages yourself, like this:"
msgstr ""
"既に自明のマージは `git read-tree -m` にて行なわれたことを 説明しました。例え"
"ば、ファイルが `HEAD と `$target` のどちらでも 変更されていない場合や、"
"`HEAD` と `$target` が同じ内容の場合は 明らかに最終的な結果は `HEAD` のものと"
"同じです。 上記の例では `hello.c` は `HEAD` で変更されていて `$target`でも 別"
"の変更が行なわれている場合です。 好きな3方向マージツールを実行してこれを解決"
"することができます。 例えば `diff3`、`merge` あるいは git 自身の merge-file "
"などを使用し これら３つのstage 上のファイルを次のようにしてマージします。"

#. type: delimited block -
#: ../../user-manual.txt:4000
#, fuzzy, no-wrap
msgid ""
"$ git cat-file blob 263414f... >hello.c~1\n"
"$ git cat-file blob 06fa6a2... >hello.c~2\n"
"$ git cat-file blob cc44c73... >hello.c~3\n"
"$ git merge-file hello.c~2 hello.c~1 hello.c~3\n"
msgstr ""
"$ git cat-file blob 263414f... >hello.c~1\n"
"$ git cat-file blob 06fa6a2... >hello.c~2\n"
"$ git cat-file blob cc44c73... >hello.c~3\n"
"$ git merge-file hello.c~2 hello.c~1 hello.c~3\n"

#. type: Plain text
#: ../../user-manual.txt:4006
#, fuzzy
msgid ""
"This would leave the merge result in `hello.c~2` file, along with conflict "
"markers if there are conflicts.  After verifying the merge result makes "
"sense, you can tell git what the final merge result for this file is by:"
msgstr ""
"これはマージ結果は `hello.c~2` ファイルに保存し、 コンフリクトがあるときは、"
"コンフリクトマーカが付けられます。 マージ結果を確認した後、このファイルの最終"
"的なマージ結果を git に次のようにして伝えます："

#. type: delimited block -
#: ../../user-manual.txt:4010
#, fuzzy, no-wrap
msgid ""
"$ mv -f hello.c~2 hello.c\n"
"$ git update-index hello.c\n"
msgstr ""
"$ mv -f hello.c~2 hello.c\n"
"$ git update-index hello.c\n"

#. type: Plain text
#: ../../user-manual.txt:4014
#, fuzzy
msgid ""
"When a path is in the \"unmerged\" state, running `git update-index` for "
"that path tells git to mark the path resolved."
msgstr ""
"ファイルにマージ済みになっていない時は、`git update-index` は ファイルに解決"
"済みのマークを付けます。"

#. type: Plain text
#: ../../user-manual.txt:4020
#, fuzzy
msgid ""
"The above is the description of a git merge at the lowest level, to help you "
"understand what conceptually happens under the hood.  In practice, nobody, "
"not even git itself, runs `git cat-file` three times for this.  There is a "
"`git merge-index` program that extracts the stages to temporary files and "
"calls a \"merge\" script on it:"
msgstr ""
"上記は下位レベルにおける git のマージ動作の解説で、 水面下でどのようなことが"
"起きているかの概念を理解する手助けになります。 実際、誰も、git 自身でさえ、"
"`git cat-file` を3回も実行しません。 `git merge-index` プログラムがあり、これ"
"が stage を一時ファイルとして 抽出し、\"merge\" スクリプトをコールします："

#. type: delimited block -
#: ../../user-manual.txt:4023
#, fuzzy, no-wrap
msgid "$ git merge-index git-merge-one-file hello.c\n"
msgstr "$ git merge-index git-merge-one-file hello.c\n"

#. type: Plain text
#: ../../user-manual.txt:4026
#, fuzzy
msgid ""
"and that is what higher level `git merge -s resolve` is implemented with."
msgstr "そして、上位レベルとして `git merge -s resolve` が実装されています。"

#. type: Title =
#: ../../user-manual.txt:4029
#, fuzzy, no-wrap
msgid "Hacking git"
msgstr "git をハックする"

#. type: Plain text
#: ../../user-manual.txt:4033
#, fuzzy
msgid ""
"This chapter covers internal details of the git implementation which "
"probably only git developers need to understand."
msgstr ""
"この章では git の実装内部の詳細について説明します。 これらの内容はおそらく "
"git の開発者のみが必要となる内容です。"

#. type: Title -
#: ../../user-manual.txt:4036
#, fuzzy, no-wrap
msgid "Object storage format"
msgstr "オブジェクトの保管形式"

#. type: Plain text
#: ../../user-manual.txt:4042
#, fuzzy
msgid ""
"All objects have a statically determined \"type\" which identifies the "
"format of the object (i.e. how it is used, and how it can refer to other "
"objects).  There are currently four different object types: \"blob\", \"tree"
"\", \"commit\", and \"tag\"."
msgstr ""
"すべてのオブジェクトは静的に決定された \"種別\" を持っており、 それによりオブ"
"ジェクトの形式が特定されます(例えば、どのように使用され どのように他のオブ"
"ジェクトを参照するかなど)。現在のところ、オブジェクト 種別は４つ存在します： "
"\"blob\", \"tree\", \"commit\", \"tag\" です。"

#. type: Plain text
#: ../../user-manual.txt:4052
#, fuzzy
msgid ""
"Regardless of object type, all objects share the following characteristics: "
"they are all deflated with zlib, and have a header that not only specifies "
"their type, but also provides size information about the data in the "
"object.  It's worth noting that the SHA-1 hash that is used to name the "
"object is the hash of the original data plus this header, so `sha1sum` "
"'file' does not match the object name for 'file'.  (Historical note: in the "
"dawn of the age of git the hash was the SHA-1 of the 'compressed' object.)"
msgstr ""
"オブジェクトの種別に関係なく、すべてのオブジェクトは次の特徴を持ちます： オブ"
"ジェクトは全て zlib で圧縮され、ヘッダにはオブジェクトの種別だけでなく、 オブ"
"ジェクトデータのサイズの情報が含まれています。 なお、オブジェクトの名前に使用"
"されている SHA-1 ハッシュ値は元データ＋このヘッダの ハッシュ値となっていま"
"す。従ってファイルの `sha1sum` の結果は そのオブジェクトの名前とは一致しませ"
"ん。"

#. type: Plain text
#: ../../user-manual.txt:4059
#, fuzzy
msgid ""
"As a result, the general consistency of an object can always be tested "
"independently of the contents or the type of the object: all objects can be "
"validated by verifying that (a) their hashes match the content of the file "
"and (b) the object successfully inflates to a stream of bytes that forms a "
"sequence of <ascii type without space> {plus} <space> {plus} <ascii decimal "
"size> {plus} <byte\\0> {plus} <binary object data>."
msgstr ""
"その結果、オブジェクトの一般的な一貫性はその中身やオブジェクト種別とは 常に独"
"立してテストすることができます：全ておオブジェクトは次のようにして 検証するこ"
"とができます。(a)それらのハッシュ値がファイルの中身と一致していること。そし"
"て、 (b)オブジェクトを解凍することができ、解凍したデータは <オブジェクトの種"
"別> + 空白 + <サイズ> ＋ <byte\\0> + <オブジェクトのバイナリデータ> の順番と"
"なっていること。"

#. type: Plain text
#: ../../user-manual.txt:4065
#, fuzzy
msgid ""
"The structured objects can further have their structure and connectivity to "
"other objects verified. This is generally done with the `git fsck` program, "
"which generates a full dependency graph of all objects, and verifies their "
"internal consistency (in addition to just verifying their superficial "
"consistency through the hash)."
msgstr ""
"構造化されたオブジェクトの場合は、さらにその構造と他のオブジェクトの 連結性に"
"よって懸賞することができます。これらは `git fsck` プログラムが 通常行っている"
"内容であり、全オブジェクトの完全な依存グラフを生成し、 それらの内部一貫性を検"
"証します(さらに、単にハッシュを使用した表面的な 一貫性の検証も行います)"

#. type: Title -
#: ../../user-manual.txt:4068
#, fuzzy, no-wrap
msgid "A birds-eye view of Git's source code"
msgstr "Git ソースコードの鳥瞰図"

#. type: Plain text
#: ../../user-manual.txt:4073
#, fuzzy
msgid ""
"It is not always easy for new developers to find their way through Git's "
"source code.  This section gives you a little guidance to show where to "
"start."
msgstr ""
"新しい開発者にとっては Git のソースコードの構成を理解するのは必ずしも 容易で"
"はないでしょう。このセクションでは、どこから開始したら良いかを 示す小さなガイ"
"ダンスです。"

#. type: Plain text
#: ../../user-manual.txt:4075
#, fuzzy
msgid "A good place to start is with the contents of the initial commit, with:"
msgstr ""
"手始めとして良い場所は、初期コミットの内容を見ることです。次のように取得しま"
"す："

#. type: delimited block -
#: ../../user-manual.txt:4078
#, fuzzy, no-wrap
msgid "$ git checkout e83c5163\n"
msgstr "$ git checkout e83c5163\n"

#. type: Plain text
#: ../../user-manual.txt:4082
#, fuzzy
msgid ""
"The initial revision lays the foundation for almost everything git has "
"today, but is small enough to read in one sitting."
msgstr ""
"初期コミットには現在の git のほとんど全ての基礎ができていますが、 ざっと読み"
"とおすのには十分な小ささです。"

#. type: Plain text
#: ../../user-manual.txt:4086
#, fuzzy
msgid ""
"Note that terminology has changed since that revision.  For example, the "
"README in that revision uses the word \"changeset\" to describe what we now "
"call a <<def_commit_object,commit>>."
msgstr ""
"現在ではこのリビジョンの頃から用語が変更されています。例えば、 このリビジョン"
"の README では現在 <<def_commit_object,コミット>> と呼んでいる ものを \"チェ"
"ンジセット\" と呼んでいます。"

#. type: Plain text
#: ../../user-manual.txt:4091
#, fuzzy
msgid ""
"Also, we do not call it \"cache\" any more, but rather \"index\"; however, "
"the file is still called `cache.h`.  Remark: Not much reason to change it "
"now, especially since there is no good single name for it anyway, because it "
"is basically _the_ header file which is included by _all_ of Git's C sources."
msgstr ""
"また、現在は \"キャッシュ\" という言い方はせず それどころか\"索引(index)\" と"
"呼んでいますが、 ファイルは今も `cache.h` です。(注釈：Not much reason to "
"change it now, especially since there is no good single name for it anyway, "
"because it is basically _the_ header file which is included by _all_ of "
"Git's C sources.)"

#. type: Plain text
#: ../../user-manual.txt:4094
#, fuzzy
msgid ""
"If you grasp the ideas in that initial commit, you should check out a more "
"recent version and skim `cache.h`, `object.h` and `commit.h`."
msgstr ""
"初期コミットを眺めて概要を把握できたら、より新しいバージョンを チェックアウト"
"し、`cache.h`, `object.h`, `commit.h` にざっと目を 通してください。"

#. type: Plain text
#: ../../user-manual.txt:4102
#, fuzzy
msgid ""
"In the early days, Git (in the tradition of UNIX) was a bunch of programs "
"which were extremely simple, and which you used in scripts, piping the "
"output of one into another. This turned out to be good for initial "
"development, since it was easier to test new things.  However, recently many "
"of these parts have become builtins, and some of the core has been \"libified"
"\", i.e. put into libgit.a for performance, portability reasons, and to "
"avoid code duplication."
msgstr ""
"初期の頃には、Git は UNIX の伝統にならい、非常にシンプルなプログラムの 集まり"
"となっていて、それらをパイプで組み合わせ、スクリプト化したりして 利用するよう"
"なツールでした。新しいことを試すのが容易であったため、 初期の開発でこれは良い"
"ことでした。しかし、現在では、これらの大部分は 内部に組み込まれ、いくつかのコ"
"ア部分は \"ライブラリ化\" されました。 つまり、パフォーマンスや移植性、コード"
"の重複の回避などの理由で libgit.a に入れられました。"

#. type: Plain text
#: ../../user-manual.txt:4109
#, fuzzy
msgid ""
"By now, you know what the index is (and find the corresponding data "
"structures in `cache.h`), and that there are just a couple of object types "
"(blobs, trees, commits and tags) which inherit their common structure from "
"`struct object`, which is their first member (and thus, you can cast e.g.  `"
"(struct object *)commit` to achieve the _same_ as `&commit->object`, i.e.  "
"get at the object name and flags)."
msgstr ""
"ここまでの確認で、索引が何かを理解し、そして、`cashe.h`内の索引のデータ 構造"
"を理解することができたはずです。また、４つのオブジェクトタイプ(blob, tree, "
"commit, tag)が `struct object` の共通構造を継承していていることや、 `struct "
"object` がそれらの最初のメンバであり 例えば `(struct object *)commit` のよう"
"にキャストすることで `&commit->object` と同じ結果が得られること、同じようにオ"
"ブジェクト名やフラグも 得られることを確認できたはずです。"

#. type: Plain text
#: ../../user-manual.txt:4111
#, fuzzy
msgid "Now is a good point to take a break to let this information sink in."
msgstr "ここまでで、オブジェクトデータに関する確認はひと段落です。"

#. type: Plain text
#: ../../user-manual.txt:4117
#, fuzzy
msgid ""
"Next step: get familiar with the object naming.  Read <<naming-commits>>.  "
"There are quite a few ways to name an object (and not only revisions!).  All "
"of these are handled in `sha1_name.c`. Just have a quick look at the "
"function `get_sha1()`. A lot of the special handling is done by functions "
"like `get_sha1_basic()` or the likes."
msgstr ""
"次のステップ：オブジェクトの指定方法を理解してください。 <<naming-commits,コ"
"ミットの指定方法>> に書かれているとおり、 オブジェクトの指定方法は数個です(そ"
"して、それらはコミットだけに限ったことではありません!)。 これらの指定部分の実"
"装は `sha1_name.c` で行われています。 その中の関数 `get_sha1() をざっとみてく"
"ださい。 特徴的な部分は `get_sha1_basic()` などの関数部分でハンドリングされて"
"います。"

#. type: Plain text
#: ../../user-manual.txt:4120
#, fuzzy
msgid ""
"This is just to get you into the groove for the most libified part of Git: "
"the revision walker."
msgstr ""
"この部分は、Git の最もライブラリ化された部分、すなわちリビジョンウォーカー に"
"対するよい導入になっています。"

#. type: Plain text
#: ../../user-manual.txt:4122
#, fuzzy
msgid "Basically, the initial version of `git log` was a shell script:"
msgstr ""
"基本的には、`git log` の初期バージョンは次のようなシェルスクリプトでした："

#. type: delimited block -
#: ../../user-manual.txt:4126
#, fuzzy, no-wrap
msgid ""
"$ git-rev-list --pretty $(git-rev-parse --default HEAD \"$@\") | \\\n"
"\tLESS=-S ${PAGER:-less}\n"
msgstr ""
"$ git-rev-list --pretty $(git-rev-parse --default HEAD \"$@\") | \\\n"
"\tLESS=-S ${PAGER:-less}\n"

#. type: Plain text
#: ../../user-manual.txt:4129
#, fuzzy
msgid "What does this mean?"
msgstr "これは何を意味するでしょうか？"

#. type: Plain text
#: ../../user-manual.txt:4134
#, fuzzy
msgid ""
"`git rev-list` is the original version of the revision walker, which "
"_always_ printed a list of revisions to stdout.  It is still functional, and "
"needs to, since most new Git programs start out as scripts using `git rev-"
"list`."
msgstr ""
"`git rev-list` はリビジョンウォーカーの元になったバージョンであり、 _常に_ リ"
"ビジョンの一覧を標準出力に出力するコマンドです。 このコマンドは現在でも役に"
"立っており、新しい Git プログラムを スクリプトとして作成するような場合によく"
"利用されます。"

#. type: Plain text
#: ../../user-manual.txt:4138
#, fuzzy
msgid ""
"`git rev-parse` is not as important any more; it was only used to filter out "
"options that were relevant for the different plumbing commands that were "
"called by the script."
msgstr ""
"`git rev-parse` はもはや重要ではありません；何故ならこれは、スクリプトにより "
"コールされる異なる配管コマンドに対して、関連のあるオプションをフィルタリング "
"する為だけに利用されているからです。"

#. type: Plain text
#: ../../user-manual.txt:4142
#, fuzzy
msgid ""
"Most of what `git rev-list` did is contained in `revision.c` and `revision."
"h`.  It wraps the options in a struct named `rev_info`, which controls how "
"and what revisions are walked, and more."
msgstr ""
"`git rev-list` が行っていることのほとんどは、`revision.c` と `revision.h` に"
"含まれています。`rev_info` という名前の構造内のオプションを包み込み、 どのよ"
"うにどのリビジョンにウォーク(アクセス)するかなどのコントロールをします。"

#. type: Plain text
#: ../../user-manual.txt:4150
#, fuzzy
msgid ""
"The original job of `git rev-parse` is now taken by the function "
"`setup_revisions()`, which parses the revisions and the common command line "
"options for the revision walker. This information is stored in the struct "
"`rev_info` for later consumption. You can do your own command line option "
"parsing after calling `setup_revisions()`. After that, you have to call "
"`prepare_revision_walk()` for initialization, and then you can get the "
"commits one by one with the function `get_revision()`."
msgstr ""
"`git rev-parse` の元の役割は、現在は `setup_revisions()` 関数に 取って代わら"
"れました。`setup_revisions()` はリビジョンウォーカーの為に リビジョンと共通の"
"コマンドラインの解析をします。解析結果は `rev_info` に 保管されて利用されま"
"す。`setup_revisions()` を呼び出した後に、自身の コマンドラインオプションを解"
"析することもできます。その後に `prepare_revision_walk()` をコールして初期化す"
"ると、`get_revision()` 関数にて ここのコミットを取得することができます。"

#. type: Plain text
#: ../../user-manual.txt:4155
#, fuzzy
msgid ""
"If you are interested in more details of the revision walking process, just "
"have a look at the first implementation of `cmd_log()`; call `git show v1.3.0"
"{tilde}155^2{tilde}4` and scroll down to that function (note that you no "
"longer need to call `setup_pager()` directly)."
msgstr ""
"リビジョンウォーカーの処理をより詳しく知りたい場合は、始めに `cmd_log()` の "
"実装を参照してください；`git show v1.3.0{tilde}155^2{tilde}4` を実行し、その"
"関数まで スクロールしてください(もはや `setup_pager()` を直接コールする必要が"
"ない 点に注意してください)。"

#. type: Plain text
#: ../../user-manual.txt:4158
#, fuzzy
msgid ""
"Nowadays, `git log` is a builtin, which means that it is _contained_ in the "
"command `git`.  The source side of a builtin is"
msgstr ""
"現在では `git log` はビルトイン化されています(つまり、`git` コマンド内に含ま"
"れています)。 ビルトイン化されているソース部分は"

#. type: Plain text
#: ../../user-manual.txt:4161
#, fuzzy
msgid ""
"a function called `cmd_<bla>`, typically defined in `builtin-<bla>.c`, and "
"declared in `builtin.h`,"
msgstr ""
"`cmd_<bla>` という名前の関数で、通常は `builtin-<bla>.c` 内で定義されてい"
"て、 宣言は `builtin.h` 内で行われています。"

#. type: Plain text
#: ../../user-manual.txt:4163
#, fuzzy
msgid "an entry in the `commands[]` array in `git.c`, and"
msgstr "`git.c` 内の `commands[]` 配列のエントリと、"

#. type: Plain text
#: ../../user-manual.txt:4165
#, fuzzy
msgid "an entry in `BUILTIN_OBJECTS` in the `Makefile`."
msgstr "`Makefile` 内の `BUILTIN_OBJECTS` 内のエントリとがあります。"

#. type: Plain text
#: ../../user-manual.txt:4171
#, fuzzy
msgid ""
"Sometimes, more than one builtin is contained in one source file.  For "
"example, `cmd_whatchanged()` and `cmd_log()` both reside in `builtin-log.c`, "
"since they share quite a bit of code.  In that case, the commands which are "
"_not_ named like the `.c` file in which they live have to be listed in "
"`BUILT_INS` in the `Makefile`."
msgstr ""
"時には１つのソースファイルに複数のビルトインが含まれていることがあります。 例"
"えば、`cmd_whatchanged()` と `cmd_log()` はコードのかなりを共有しているた"
"め、 両方とも `builtin-log.c` 内に存在します。このような場合、コマンドは `."
"c` ファイルの名前で呼ばれず、`Makefile` 内の `BUILT_INS` 内に リストされてい"
"る必要があります。"

#. type: Plain text
#: ../../user-manual.txt:4174
#, fuzzy
msgid ""
"`git log` looks more complicated in C than it does in the original script, "
"but that allows for a much greater flexibility and performance."
msgstr ""
"`git log` は 元のスクリプトがしていた内容よりも C の実装の方がより 複雑に見え"
"ますが、より高い柔軟性とパフォーマンス性を持っています。"

#. type: Plain text
#: ../../user-manual.txt:4176
#, fuzzy
msgid "Here again it is a good point to take a pause."
msgstr "ここまでで再び一息つくのにちょうど良い箇所です。"

#. type: Plain text
#: ../../user-manual.txt:4179
#, fuzzy
msgid ""
"Lesson three is: study the code.  Really, it is the best way to learn about "
"the organization of Git (after you know the basic concepts)."
msgstr ""
"レッスン３はコードの観察です。(基本的な概念を学んだ後に) Git の構成を学ぶに"
"は これが一番良い方法です"

#. type: Plain text
#: ../../user-manual.txt:4184
#, fuzzy
msgid ""
"So, think about something which you are interested in, say, \"how can I "
"access a blob just knowing the object name of it?\".  The first step is to "
"find a Git command with which you can do it.  In this example, it is either "
"`git show` or `git cat-file`."
msgstr ""
"興味のある内容を考えてください。たとえば \"blob のオブジェクト名からどのよう"
"に blob にアクセスするのだろう？\"とか。 まず最初に、それを行う Git コマンド"
"を見つけてください。この例では、 `git show` または `git cat-file` です。"

#. type: Plain text
#: ../../user-manual.txt:4186
#, fuzzy
msgid "For the sake of clarity, let's stay with `git cat-file`, because it"
msgstr "明瞭にするため、`git cat-file` にしましょう。何故なら"

#. type: Plain text
#: ../../user-manual.txt:4188
#, fuzzy
msgid "is plumbing, and"
msgstr "これが配管的なもの(plumbing)であり、"

#. type: Plain text
#: ../../user-manual.txt:4192
#, fuzzy
msgid ""
"was around even in the initial commit (it literally went only through some "
"20 revisions as `cat-file.c`, was renamed to `builtin-cat-file.c` when made "
"a builtin, and then saw less than 10 versions)."
msgstr ""
"初期コミットの頃から存在しているからです。(`cat-file.c` のリビジョンが 20 "
"個、 ビルトイン化されて `builtin-cat-file.c` に変更されてからのリビジョンは "
"10個以下です)。"

#. type: Plain text
#: ../../user-manual.txt:4195
#, fuzzy
msgid ""
"So, look into `builtin-cat-file.c`, search for `cmd_cat_file()` and look "
"what it does."
msgstr ""
"`builtin-cat-file.c` を開き、`cmd_cat_file()` を探し出して、 何が行われている"
"かを見てください。"

#. type: delimited block -
#: ../../user-manual.txt:4202
#, fuzzy, no-wrap
msgid ""
"        git_config(git_default_config);\n"
"        if (argc != 3)\n"
"\t\tusage(\"git cat-file [-t|-s|-e|-p|<type>] <sha1>\");\n"
"        if (get_sha1(argv[2], sha1))\n"
"                die(\"Not a valid object name %s\", argv[2]);\n"
msgstr ""
"        git_config(git_default_config);\n"
"        if (argc != 3)\n"
"\t\tusage(\"git cat-file [-t|-s|-e|-p|<type>] <sha1>\");\n"
"        if (get_sha1(argv[2], sha1))\n"
"                die(\"Not a valid object name %s\", argv[2]);\n"

#. type: Plain text
#: ../../user-manual.txt:4208
#, fuzzy
msgid ""
"Let's skip over the obvious details; the only really interesting part here "
"is the call to `get_sha1()`.  It tries to interpret `argv[2]` as an object "
"name, and if it refers to an object which is present in the current "
"repository, it writes the resulting SHA-1 into the variable `sha1`."
msgstr ""
"明らかに細かな部分はスキップしましょう；ここで興味深い箇所は `get_sha1()` を"
"読んでいる箇所です。ここではオブジェクト名である `argv[2]` を読み込み、もしそ"
"れが現在のリポジトリに存在するオブジェクトを参照している場合は その SHA-1 を"
"変数 `sha1` に代入します。"

#. type: Plain text
#: ../../user-manual.txt:4210
#, fuzzy
msgid "Two things are interesting here:"
msgstr "ここで興味深いのは次の２点です："

#. type: Plain text
#: ../../user-manual.txt:4214
#, fuzzy
msgid ""
"`get_sha1()` returns 0 on _success_.  This might surprise some new Git "
"hackers, but there is a long tradition in UNIX to return different negative "
"numbers in case of different errors--and 0 on success."
msgstr ""
"`get_cha1()` は _成功_ 時に 0 を返却します。これは Git のハックを 初めて行う"
"人にとっては驚くべきことですが、エラーの種別毎に異なる負数を返却し、 成功時に"
"は 0 を返却するのは UNIX の昔からの伝統です。"

#. type: Plain text
#: ../../user-manual.txt:4221
#, fuzzy
msgid ""
"the variable `sha1` in the function signature of `get_sha1()` is `unsigned "
"char \\*`, but is actually expected to be a pointer to `unsigned char[20]`.  "
"This variable will contain the 160-bit SHA-1 of the given commit.  Note that "
"whenever a SHA-1 is passed as `unsigned char \\*`, it is the binary "
"representation, as opposed to the ASCII representation in hex characters, "
"which is passed as `char *`."
msgstr ""
"`get_sha1()` 関数の戻り値である変数 `sha1` は `unsigned char \\*` ですが、 実"
"際は `unsigned char[20]` を指し示すことが想定されています。 この変数は指定さ"
"れたコミットの 160-bit の SHA-1 を含んでいます。 SHA-1 が `unsigned char "
"\\*` として渡される時はいつでも、 それがバイナリ表現であり、`char *` で渡され"
"る 16進の ASCII表現とは違う ことに注意してください。"

#. type: Plain text
#: ../../user-manual.txt:4223
#, fuzzy
msgid "You will see both of these things throughout the code."
msgstr "これらの両方をソースを通して確認できます。"

#. type: Plain text
#: ../../user-manual.txt:4225
#, fuzzy
msgid "Now, for the meat:"
msgstr "さて、ここが核心です："

#. type: delimited block -
#: ../../user-manual.txt:4229
#, fuzzy, no-wrap
msgid ""
"        case 0:\n"
"                buf = read_object_with_reference(sha1, argv[1], &size, NULL);\n"
msgstr ""
"        case 0:\n"
"                buf = read_object_with_reference(sha1, argv[1], &size, NULL);\n"

#. type: Plain text
#: ../../user-manual.txt:4236
#, fuzzy
msgid ""
"This is how you read a blob (actually, not only a blob, but any type of "
"object).  To know how the function `read_object_with_reference()` actually "
"works, find the source code for it (something like `git grep "
"read_object_with | grep \":[a-z]\"` in the git repository), and read the "
"source."
msgstr ""
"これが blob (実際のところ、blob だけでなくすべてのオブジェクト)を読む方法で"
"す。 この関数 `read_object_with_reference()` がどのように動くかを知る為には "
"その部分のソースコードを `git grep read_object_with | grep \":[a-z]\"` のよう"
"に して見つけ出し、ソースを読むことです。"

#. type: Plain text
#: ../../user-manual.txt:4238
#, fuzzy
msgid ""
"To find out how the result can be used, just read on in `cmd_cat_file()`:"
msgstr ""
"結果がどのように使用されるかを見つけるには、`cmd_cat_file()` 内を見ます："

#. type: delimited block -
#: ../../user-manual.txt:4241
#, fuzzy, no-wrap
msgid "        write_or_die(1, buf, size);\n"
msgstr "        write_or_die(1, buf, size);\n"

#. type: Plain text
#: ../../user-manual.txt:4246
#, fuzzy
msgid ""
"Sometimes, you do not know where to look for a feature.  In many such cases, "
"it helps to search through the output of `git log`, and then `git show` the "
"corresponding commit."
msgstr ""
"時には機能の実装箇所を探し出すことができない場合があるかもしれません。 そのよ"
"うな場合には、`git log` の出力を探しだし、関連するコミットを `git show` する"
"と手助けになるかもしれません。"

#. type: Plain text
#: ../../user-manual.txt:4250
#, fuzzy
msgid ""
"Example: If you know that there was some test case for `git bundle`, but do "
"not remember where it was (yes, you _could_ `git grep bundle t/`, but that "
"does not illustrate the point!):"
msgstr ""
"例： `git bundle` に対するテストケースがあることは知っているが、 それがどこに"
"あるかがわからない場合 (もちろん、`git grep bundle t/` することも できます"
"が、それではポイントを示すことになりません！)："

#. type: delimited block -
#: ../../user-manual.txt:4253
#, fuzzy, no-wrap
msgid "$ git log --no-merges t/\n"
msgstr "$ git log --no-merges t/\n"

#. type: Plain text
#: ../../user-manual.txt:4258
#, fuzzy
msgid ""
"In the pager (`less`), just search for \"bundle\", go a few lines back, and "
"see that it is in commit 18449ab0...  Now just copy this object name, and "
"paste it into the command line"
msgstr ""
"ページャ (`less`) 内で \"bundle\" を検索し、数行戻ると、 commit 18449ab0... "
"にあるのがわかります。このオブジェクト名をコピーし コマンドラインにペーストし"
"ます"

#. type: delimited block -
#: ../../user-manual.txt:4261
#, fuzzy, no-wrap
msgid "$ git show 18449ab0\n"
msgstr "$ git show 18449ab0\n"

#. type: Plain text
#: ../../user-manual.txt:4264
#, fuzzy
msgid "Voila."
msgstr "ビンゴ！"

#. type: Plain text
#: ../../user-manual.txt:4267
#, fuzzy
msgid ""
"Another example: Find out what to do in order to make some script a builtin:"
msgstr "次の例：スクリプトをビルトイン化するために必要な作業を調べるには："

#. type: delimited block -
#: ../../user-manual.txt:4270
#, fuzzy, no-wrap
msgid "$ git log --no-merges --diff-filter=A builtin-*.c\n"
msgstr "$ git log --no-merges --diff-filter=A builtin-*.c\n"

#. type: Plain text
#: ../../user-manual.txt:4274
#, fuzzy
msgid ""
"You see, Git is actually the best tool to find out about the source of Git "
"itself!"
msgstr ""
"ここまでに見てきたように、Git は Git 自身のソースを調べるときにも 最も役に立"
"つツールなのです！"

#. type: Title =
#: ../../user-manual.txt:4277
#, fuzzy, no-wrap
msgid "GIT Glossary"
msgstr "GIT 用語集"

#. type: Title =
#: ../../user-manual.txt:4283
#, fuzzy, no-wrap
msgid "Appendix A: Git Quick Reference"
msgstr "付録Ａ：Git Quick Reference"

#. type: Plain text
#: ../../user-manual.txt:4287
#, fuzzy
msgid ""
"This is a quick summary of the major commands; the previous chapters explain "
"how these work in more detail."
msgstr ""
"この章は主要コマンドのクイックサマリです； 詳細はこれまでの章の説明を参照して"
"ください。"

#. type: Plain text
#: ../../user-manual.txt:4293
#, fuzzy
msgid "From a tarball:"
msgstr "tar ボールから："

#. type: delimited block -
#: ../../user-manual.txt:4301
#, fuzzy, no-wrap
msgid ""
"$ tar xzf project.tar.gz\n"
"$ cd project\n"
"$ git init\n"
"Initialized empty Git repository in .git/\n"
"$ git add .\n"
"$ git commit\n"
msgstr ""
"$ tar xzf project.tar.gz\n"
"$ cd project\n"
"$ git init\n"
"Initialized empty Git repository in .git/\n"
"$ git add .\n"
"$ git commit\n"

#. type: Plain text
#: ../../user-manual.txt:4304
#, fuzzy
msgid "From a remote repository:"
msgstr "リモートのリポジトリから："

#. type: delimited block -
#: ../../user-manual.txt:4308
#, fuzzy, no-wrap
msgid ""
"$ git clone git://example.com/pub/project.git\n"
"$ cd project\n"
msgstr ""
"$ git clone git://example.com/pub/project.git\n"
"$ cd project\n"

#. type: delimited block -
#: ../../user-manual.txt:4319
#, fuzzy, no-wrap
msgid ""
"$ git branch\t     # list all local branches in this repo\n"
"$ git checkout test  # switch working directory to branch \"test\"\n"
"$ git branch new     # create branch \"new\" starting at current HEAD\n"
"$ git branch -d new  # delete branch \"new\"\n"
msgstr ""
"$ git branch\t     # リポジトリ内のすべてのローカルブランチを表示\n"
"$ git checkout test  # 作業ディレクトリをブランチ \"test\" に切り替え\n"
"$ git branch new     # 現在の HEAD から始まる \"new\" ブランチを作成\n"
"$ git branch -d new  # \"new\" ブランチの削除\n"

#. type: Plain text
#: ../../user-manual.txt:4322
#, fuzzy
msgid "Instead of basing a new branch on current HEAD (the default), use:"
msgstr ""
"現在の HEAD (デフォルト)以外の場所から始まるブランチを作成するには、次のよう"
"にします："

#. type: delimited block -
#: ../../user-manual.txt:4329
#, fuzzy, no-wrap
msgid ""
"$ git branch new test    # branch named \"test\"\n"
"$ git branch new v2.6.15 # tag named v2.6.15\n"
"$ git branch new HEAD^   # commit before the most recent\n"
"$ git branch new HEAD^^  # commit before that\n"
"$ git branch new test~10 # ten commits before tip of branch \"test\"\n"
msgstr ""
"$ git branch new test    # \"test\" ブランチのHEADから開始するブランチ \"new\" を作成\n"
"$ git branch new v2.6.15 # タグ v2.6.15 から開始するブランチ \"new\" を作成\n"
"$ git branch new HEAD^   # 最新のコミットの１つ前の位置から分岐するブランチを作成\n"
"$ git branch new HEAD^^  # 最新のコミットの２つ前の位置から分岐するブランチを作成\n"
"$ git branch new test~10 # ブランチ \"test\" の１０個前の位置から分岐するブランチを作成\n"

#. type: Plain text
#: ../../user-manual.txt:4332
#, fuzzy
msgid "Create and switch to a new branch at the same time:"
msgstr "新しいブランチの作成と切り替えを同時に行うには："

#. type: delimited block -
#: ../../user-manual.txt:4335
#, fuzzy, no-wrap
msgid "$ git checkout -b new v2.6.15\n"
msgstr "$ git checkout -b new v2.6.15\n"

#. type: Plain text
#: ../../user-manual.txt:4338
#, fuzzy
msgid "Update and examine branches from the repository you cloned from:"
msgstr "複製(clone)元のリポジトリのブランチを更新しテストするには："

#. type: delimited block -
#: ../../user-manual.txt:4346
#, fuzzy, no-wrap
msgid ""
"$ git fetch\t\t# update\n"
"$ git branch -r\t\t# list\n"
"  origin/master\n"
"  origin/next\n"
"  ...\n"
"$ git checkout -b masterwork origin/master\n"
msgstr ""
"$ git fetch\t\t# 更新\n"
"$ git branch -r\t\t# リモートブランチの一覧を表示\n"
"  origin/master\n"
"  origin/next\n"
"  ...\n"
"$ git checkout -b masterwork origin/master\n"

#. type: Plain text
#: ../../user-manual.txt:4350
#, fuzzy
msgid ""
"Fetch a branch from a different repository, and give it a new name in your "
"repository:"
msgstr ""
"他のリポジトリ上にあるブランチを取得(fetch)し、 そのブランチに対して名前を付"
"けるには："

#. type: delimited block -
#: ../../user-manual.txt:4354
#, fuzzy, no-wrap
msgid ""
"$ git fetch git://example.com/project.git theirbranch:mybranch\n"
"$ git fetch git://example.com/project.git v2.6.15:mybranch\n"
msgstr ""
"$ git fetch git://example.com/project.git theirbranch:mybranch\n"
"$ git fetch git://example.com/project.git v2.6.15:mybranch\n"

#. type: Plain text
#: ../../user-manual.txt:4357
#, fuzzy
msgid "Keep a list of repositories you work with regularly:"
msgstr "リポジトリの一覧を管理し、定期的にそこから変更を取得するには："

#. type: delimited block -
#: ../../user-manual.txt:4372
#, fuzzy, no-wrap
msgid ""
"$ git remote add example git://example.com/project.git\n"
"$ git remote\t\t\t# list remote repositories\n"
"example\n"
"origin\n"
"$ git remote show example\t# get details\n"
"* remote example\n"
"  URL: git://example.com/project.git\n"
"  Tracked remote branches\n"
"    master\n"
"    next\n"
"    ...\n"
"$ git fetch example\t\t# update branches from example\n"
"$ git branch -r\t\t\t# list all remote branches\n"
msgstr ""
"$ git remote add example git://example.com/project.git\n"
"$ git remote\t\t\t# リモートリポジトリの一覧を表示\n"
"example\n"
"origin\n"
"$ git remote show example\t# 詳細を表示\n"
"* remote example\n"
"  URL: git://example.com/project.git\n"
"  Tracked remote branches\n"
"    master\n"
"    next\n"
"    ...\n"
"$ git fetch example\t\t# example のブランチを更新\n"
"$ git branch -r\t\t\t# すべてのリモートブランチの一覧を表示\n"

#. type: delimited block -
#: ../../user-manual.txt:4396
#, fuzzy, no-wrap
msgid ""
"$ gitk\t\t\t    # visualize and browse history\n"
"$ git log\t\t    # list all commits\n"
"$ git log src/\t\t    # ...modifying src/\n"
"$ git log v2.6.15..v2.6.16  # ...in v2.6.16, not in v2.6.15\n"
"$ git log master..test\t    # ...in branch test, not in branch master\n"
"$ git log test..master\t    # ...in branch master, but not in test\n"
"$ git log test...master\t    # ...in one branch, not in both\n"
"$ git log -S'foo()'\t    # ...where difference contain \"foo()\"\n"
"$ git log --since=\"2 weeks ago\"\n"
"$ git log -p\t\t    # show patches as well\n"
"$ git show\t\t    # most recent commit\n"
"$ git diff v2.6.15..v2.6.16 # diff between two tagged versions\n"
"$ git diff v2.6.15..HEAD    # diff with current head\n"
"$ git grep \"foo()\"\t    # search working directory for \"foo()\"\n"
"$ git grep v2.6.15 \"foo()\"  # search old tree for \"foo()\"\n"
"$ git show v2.6.15:a.txt    # look at old version of a.txt\n"
msgstr ""
"$ gitk\t\t\t    # 履歴を視覚的にブラウズする\n"
"$ git log\t\t    # すべてのコミットを一覧表示する\n"
"$ git log src/\t\t    # src/ 配下のファイルを変更している・・・\n"
"$ git log v2.6.15..v2.6.16  # v2.6.16 には含まれているが、v2.6.15 には含まれていない・・・\n"
"$ git log master..test\t    # test ブランチに含まれているが、master ブランチには含まれていない・・・\n"
"$ git log test..master\t    # master ブランチに含まれているが、test ブランチには含まれていない・・・\n"
"$ git log test...master\t    # 片方のブランチには含まれているが、両方のブランチには含まれていない・・・\n"
"$ git log -S'foo()'\t    # 差分に \"foo()\" を含んでいる・・・\n"
"$ git log --since=\"2 weeks ago\"\n"
"$ git log -p\t\t    # パッチも表示する\n"
"$ git show\t\t    # 最新のコミットを表示\n"
"$ git diff v2.6.15..v2.6.16 # ２つのタグ付されたバージョン間の差分\n"
"$ git diff v2.6.15..HEAD    # 現在の head との差分\n"
"$ git grep \"foo()\"\t    # 作業ディレクトリ内で \"foo()\" を検索する\n"
"$ git grep v2.6.15 \"foo()\"  # 過去のツリー内で \"foo()\" を検索する\n"
"$ git show v2.6.15:a.txt    # a.txt の過去のバージョンを表示する\n"

#. type: Plain text
#: ../../user-manual.txt:4399
#, fuzzy
msgid "Search for regressions:"
msgstr "回帰点を探す："

#. type: delimited block -
#: ../../user-manual.txt:4409
#, fuzzy, no-wrap
msgid ""
"$ git bisect start\n"
"$ git bisect bad\t\t# current version is bad\n"
"$ git bisect good v2.6.13-rc2\t# last known good revision\n"
"Bisecting: 675 revisions left to test after this\n"
"\t\t\t\t# test here, then:\n"
"$ git bisect good\t\t# if this revision is good, or\n"
"$ git bisect bad\t\t# if this revision is bad.\n"
"\t\t\t\t# repeat until done.\n"
msgstr ""
"$ git bisect start\n"
"$ git bisect bad\t\t# 現在のバージョンは bad\n"
"$ git bisect good v2.6.13-rc2\t# 最新の good なリビジョンを知らせる\n"
"Bisecting: 675 revisions left to test after this\n"
"\t\t\t\t# ここからテストを行う\n"
"$ git bisect good\t\t# このリビジョンが good の場合\n"
"$ git bisect bad\t\t# このリビジョンが bad の場合\n"
"\t\t\t\t# 回帰点を見つけるまで続ける\n"

#. type: Plain text
#: ../../user-manual.txt:4416
#, fuzzy
msgid "Make sure git knows who to blame:"
msgstr "誰の変更であるかを git に知らせる："

#. type: delimited block -
#: ../../user-manual.txt:4423
#, fuzzy, no-wrap
msgid ""
"$ cat >>~/.gitconfig <<\\EOF\n"
"[user]\n"
"\tname = Your Name Comes Here\n"
"\temail = you@yourdomain.example.com\n"
"EOF\n"
msgstr ""
"$ cat >>~/.gitconfig <<\\EOF\n"
"[user]\n"
"\tname = Your Name Comes Here\n"
"\temail = you@yourdomain.example.com\n"
"EOF\n"

#. type: Plain text
#: ../../user-manual.txt:4427
#, fuzzy
msgid ""
"Select file contents to include in the next commit, then make the commit:"
msgstr "次のコミットに含めるファイルの内容を指定し、 コミットする："

#. type: delimited block -
#: ../../user-manual.txt:4433
#, fuzzy, no-wrap
msgid ""
"$ git add a.txt    # updated file\n"
"$ git add b.txt    # new file\n"
"$ git rm c.txt     # old file\n"
"$ git commit\n"
msgstr ""
"$ git add a.txt    # 更新したファイル\n"
"$ git add b.txt    # 新しいファイル\n"
"$ git rm c.txt     # 削除したファイル\n"
"$ git commit\n"

#. type: Plain text
#: ../../user-manual.txt:4436
#, fuzzy
msgid "Or, prepare and create the commit in one step:"
msgstr "コミットの準備と実行を一度に行う："

#. type: delimited block -
#: ../../user-manual.txt:4440
#, fuzzy, no-wrap
msgid ""
"$ git commit d.txt # use latest content only of d.txt\n"
"$ git commit -a\t   # use latest content of all tracked files\n"
msgstr ""
"$ git commit d.txt # d.txt の最後の内容のみをコミット\n"
"$ git commit -a\t   # 管理対象の全ファイルの最新の状態をコミット\n"

#. type: Title -
#: ../../user-manual.txt:4444
#, fuzzy, no-wrap
msgid "Merging"
msgstr "マージ"

#. type: delimited block -
#: ../../user-manual.txt:4451
#, fuzzy, no-wrap
msgid ""
"$ git merge test   # merge branch \"test\" into the current branch\n"
"$ git pull git://example.com/project.git master\n"
"\t\t   # fetch and merge in remote branch\n"
"$ git pull . test  # equivalent to git merge test\n"
msgstr ""
"$ git merge test   # \"test\" ブランチを現在のブランチにマージ\n"
"$ git pull git://example.com/project.git master\n"
"\t\t   # リモートブランチの変更を取得し、マージ\n"
"$ git pull . test  # git merge test と同じ\n"

#. type: Title -
#: ../../user-manual.txt:4455
#, fuzzy, no-wrap
msgid "Sharing your changes"
msgstr "変更の共有"

#. type: Plain text
#: ../../user-manual.txt:4458
#, fuzzy
msgid "Importing or exporting patches:"
msgstr "パッチをインポートし、エクスポートするには："

#. type: delimited block -
#: ../../user-manual.txt:4463
#, fuzzy, no-wrap
msgid ""
"$ git format-patch origin..HEAD # format a patch for each commit\n"
"\t\t\t\t# in HEAD but not in origin\n"
"$ git am mbox # import patches from the mailbox \"mbox\"\n"
msgstr ""
"$ git format-patch origin..HEAD # HEAD に存在するが origin には存在しない\n"
"\t\t\t\t# 各コミットのパッチを整形する\n"
"$ git am mbox # メールボックス \"mbox\" からパッチをインポートする\n"

#. type: Plain text
#: ../../user-manual.txt:4467
#, fuzzy
msgid ""
"Fetch a branch in a different git repository, then merge into the current "
"branch:"
msgstr ""
"他の git リポジトリ内のブランチから変更を取得し、 現在のブランチにマージす"
"る："

#. type: delimited block -
#: ../../user-manual.txt:4470
#, fuzzy, no-wrap
msgid "$ git pull git://example.com/project.git theirbranch\n"
msgstr "$ git pull git://example.com/project.git theirbranch\n"

#. type: Plain text
#: ../../user-manual.txt:4474
#, fuzzy
msgid ""
"Store the fetched branch into a local branch before merging into the current "
"branch:"
msgstr "現在のブランチにマージする前にローカルブランチに変更を格納する："

#. type: delimited block -
#: ../../user-manual.txt:4477
#, fuzzy, no-wrap
msgid "$ git pull git://example.com/project.git theirbranch:mybranch\n"
msgstr "$ git pull git://example.com/project.git theirbranch:mybranch\n"

#. type: Plain text
#: ../../user-manual.txt:4481
#, fuzzy
msgid ""
"After creating commits on a local branch, update the remote branch with your "
"commits:"
msgstr ""
"ローカルブランチ上でコミットした後に、リモートブランチに その内容を反映させ"
"る："

#. type: delimited block -
#: ../../user-manual.txt:4484
#, fuzzy, no-wrap
msgid "$ git push ssh://example.com/project.git mybranch:theirbranch\n"
msgstr "$ git push ssh://example.com/project.git mybranch:theirbranch\n"

#. type: Plain text
#: ../../user-manual.txt:4487
#, fuzzy
msgid "When remote and local branch are both named \"test\":"
msgstr ""
"リモートブランチとローカルブランチの名前が両方とも \"test\" である場合："

#. type: delimited block -
#: ../../user-manual.txt:4490
#, fuzzy, no-wrap
msgid "$ git push ssh://example.com/project.git test\n"
msgstr "$ git push ssh://example.com/project.git test\n"

#. type: Plain text
#: ../../user-manual.txt:4493
#, fuzzy
msgid "Shortcut version for a frequently used remote repository:"
msgstr "よく使用するリモートリポジトリに対して略称を付ける："

#. type: delimited block -
#: ../../user-manual.txt:4497
#, fuzzy, no-wrap
msgid ""
"$ git remote add example ssh://example.com/project.git\n"
"$ git push example test\n"
msgstr ""
"$ git remote add example ssh://example.com/project.git\n"
"$ git push example test\n"

#. type: Title -
#: ../../user-manual.txt:4501
#, fuzzy, no-wrap
msgid "Repository maintenance"
msgstr "リポジトリのメンテナンス"

#. type: Plain text
#: ../../user-manual.txt:4504
#, fuzzy
msgid "Check for corruption:"
msgstr "破損していないか検査する："

#. type: delimited block -
#: ../../user-manual.txt:4507
#, fuzzy, no-wrap
msgid "$ git fsck\n"
msgstr "$ git fsck\n"

#. type: Plain text
#: ../../user-manual.txt:4510
#, fuzzy
msgid "Recompress, remove unused cruft:"
msgstr "リポジトリを圧縮し、使用していないゴミを削除する："

#. type: Title =
#: ../../user-manual.txt:4518
#, fuzzy, no-wrap
msgid "Appendix B: Notes and todo list for this manual"
msgstr "付録 B: このマニュアルの覚え書きとTODOリスト"

#. type: Plain text
#: ../../user-manual.txt:4521
#, fuzzy
msgid "This is a work in progress."
msgstr "この仕事は作業中です。"

#. type: Plain text
#: ../../user-manual.txt:4523
#, fuzzy
msgid "The basic requirements:"
msgstr "基本要件："

#. type: Plain text
#: ../../user-manual.txt:4528
#, fuzzy
msgid ""
"It must be readable in order, from beginning to end, by someone intelligent "
"with a basic grasp of the UNIX command line, but without any special "
"knowledge of git.  If necessary, any other prerequisites should be "
"specifically mentioned as they arise."
msgstr ""
"UNIXコマンドラインの基礎知識があれば、git の前提知識がなくても 最初から最後ま"
"で順番に読み進められること。必要なときは、 その都度、他の前提知識が必要である"
"ことが述べられること。"

#. type: Plain text
#: ../../user-manual.txt:4532
#, fuzzy
msgid ""
"Whenever possible, section headings should clearly describe the task they "
"explain how to do, in language that requires no more knowledge than "
"necessary: for example, \"importing patches into a project\" rather than "
"\"the `git am` command\""
msgstr ""
"可能な時はいつでも、節の冒頭で方法を説明するタスクを明示的に説明するべきで、 "
"言語に関する知識は必要以上には要求しない：例えば、\"`git am` コマンド\" では"
"なく、\"パッチをプロジェクトにインポートする\" とする。"

#. type: Plain text
#: ../../user-manual.txt:4536
#, fuzzy
msgid ""
"Think about how to create a clear chapter dependency graph that will allow "
"people to get to important topics without necessarily reading everything in "
"between."
msgstr ""
"全内容を読まなくても重要なトピックスの理解ができるよう、 各章の依存関係を明確"
"にしたグラフの作成方法を考えるべきです。"

#. type: Plain text
#: ../../user-manual.txt:4538
#, fuzzy
msgid "Scan Documentation/ for other stuff left out; in particular:"
msgstr "Documentation/ ディレクトリをスキャンし、他の残項目を探す；特に："

#. type: Plain text
#: ../../user-manual.txt:4540
#, fuzzy
msgid "howto's"
msgstr "howto に関するもの"

#. type: Plain text
#: ../../user-manual.txt:4541
#, fuzzy
msgid "some of technical/?"
msgstr "technical/ の下のいくつか？"

#. type: Plain text
#: ../../user-manual.txt:4542
#, fuzzy
msgid "hooks"
msgstr "フック"

#. type: Plain text
#: ../../user-manual.txt:4543
#, fuzzy
msgid "list of commands in linkgit:git[1]"
msgstr "linkgit:git[1] 内のコマンドの一覧"

#. type: Plain text
#: ../../user-manual.txt:4545
#, fuzzy
msgid "Scan email archives for other stuff left out"
msgstr "E-mail のアーカイブをスキャンし、他の残項目を探す。"

#. type: Plain text
#: ../../user-manual.txt:4548
#, fuzzy
msgid ""
"Scan man pages to see if any assume more background than this manual "
"provides."
msgstr ""
"man ページをスキャンし、to see if any assume more background than this "
"manual provides."

#. type: Plain text
#: ../../user-manual.txt:4551
#, fuzzy
msgid ""
"Simplify beginning by suggesting disconnected head instead of temporary "
"branch creation?"
msgstr ""
"Simplify beginning by suggesting disconnected head instead of temporary "
"branch creation?"

#. type: Plain text
#: ../../user-manual.txt:4555
#, fuzzy
msgid ""
"Add more good examples.  Entire sections of just cookbook examples might be "
"a good idea; maybe make an \"advanced examples\" section a standard end-of-"
"chapter section?"
msgstr ""
"より良い例を追加する。全てのセクションに使用例を追加するのは 良いアイデアかも"
"しれない；\"高度な例\" を章末のセクションに追加する？"

#. type: Plain text
#: ../../user-manual.txt:4557
#, fuzzy
msgid "Include cross-references to the glossary, where appropriate."
msgstr "用語集への相互参照を適切な場所に盛り込む。"

#. type: Plain text
#: ../../user-manual.txt:4560
#, fuzzy
msgid ""
"Document shallow clones? See draft 1.5.0 release notes for some "
"documentation."
msgstr ""
"shallow clone のドキュメントは？ ドラフト版の 1.5.0 のリリースノート に幾らか"
"の説明があります。"

#. type: Plain text
#: ../../user-manual.txt:4563
#, fuzzy
msgid ""
"Add a section on working with other version control systems, including CVS, "
"Subversion, and just imports of series of release tarballs."
msgstr ""
"他のバージョン管理システムと作業する場合に関するセクションを追加する。 CVS, "
"Subversion も含めて。リリースする tarball にそれらをインポートする。"

#. type: Plain text
#: ../../user-manual.txt:4565
#, fuzzy
msgid "More details on gitweb?"
msgstr "gitweb に関するより詳しい説明？"

#. type: Plain text
#: ../../user-manual.txt:4567
#, fuzzy
msgid "Write a chapter on using plumbing and writing scripts."
msgstr "配管スクリプトの使用と、スクリプトの書き方に関する章を追加。"

#. type: Plain text
#: ../../user-manual.txt:4569
#, fuzzy
msgid "Alternates, clone -reference, etc."
msgstr "交互の、clone -reference, など"

#. type: Plain text
#: ../../user-manual.txt:4572
#, fuzzy, no-wrap
msgid ""
"More on recovery from repository corruption.  See:\n"
"\thttp://marc.theaimsgroup.com/?l=git&m=117263864820799&w=2\n"
"\thttp://marc.theaimsgroup.com/?l=git&m=117147855503798&w=2\n"
msgstr ""
"リポジトリの破損からの復旧についてより詳しく。参照：\n"
"\thttp://marc.theaimsgroup.com/?l=git&m=117263864820799&w=2\n"
"\thttp://marc.theaimsgroup.com/?l=git&m=117147855503798&w=2\n"
