# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Git Japanese translation team
# This file is distributed under the same license as the Git package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Git v1.8.4\n"
"POT-Creation-Date: 2013-12-07 00:31+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: ../../gittutorial.txt:31 ../../user-manual.txt:29
msgid "or:"
msgstr ""

#. type: Plain text
#: ../../gittutorial.txt:38 ../../user-manual.txt:36
msgid ""
"With the latter, you can use the manual viewer of your choice; see linkgit:"
"git-help[1] for more information."
msgstr ""

#. type: delimited block -
#: ../../gittutorial.txt:83 ../../gittutorial.txt:125
#: ../../user-manual.txt:1084
#, no-wrap
msgid "$ git commit\n"
msgstr ""

#. type: Title -
#: ../../gittutorial.txt:89 ../../user-manual.txt:4413
#, no-wrap
msgid "Making changes"
msgstr ""

#. type: delimited block -
#: ../../gittutorial.txt:102 ../../user-manual.txt:1065
#, no-wrap
msgid "$ git diff --cached\n"
msgstr ""

#. type: delimited block -
#: ../../gittutorial.txt:134 ../../gittutorial.txt:250
#: ../../user-manual.txt:1097
#, no-wrap
msgid "$ git commit -a\n"
msgstr ""

#. type: delimited block -
#: ../../gittutorial.txt:171 ../../user-manual.txt:671
#, no-wrap
msgid "$ git log -p\n"
msgstr ""

#. type: Title -
#: ../../gittutorial.txt:181 ../../user-manual.txt:4312
#, no-wrap
msgid "Managing branches"
msgstr ""

#. type: delimited block -
#: ../../gittutorial.txt:243 ../../user-manual.txt:1072
#, no-wrap
msgid "$ git diff\n"
msgstr ""

#. type: Title -
#: ../../gittutorial.txt:461 ../../user-manual.txt:4377
#, no-wrap
msgid "Exploring history"
msgstr ""

#. type: delimited block -
#: ../../gittutorial-2.txt:141 ../../user-manual.txt:304
#, no-wrap
msgid ""
"$ cat .git/HEAD\n"
"ref: refs/heads/master\n"
msgstr ""

#. type: Title -
#: ../../everyday.txt:51 ../../everyday.txt:127 ../../everyday.txt:230
#: ../../everyday.txt:312 ../../user-manual.txt:728 ../../user-manual.txt:2061
#, no-wrap
msgid "Examples"
msgstr ""

#. type: delimited block -
#: ../../git-bisect.txt:89 ../../user-manual.txt:515
#, no-wrap
msgid "$ git bisect reset\n"
msgstr ""

#. type: delimited block -
#: ../../git-bisect.txt:114 ../../user-manual.txt:527
#, no-wrap
msgid "$ git bisect visualize\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2
msgid "Git User's Manual (for version 1.5.3 or newer)"
msgstr ""

#. type: delimited block _
#: ../../user-manual.txt:6
msgid "Git is a fast distributed revision control system."
msgstr ""

#. type: delimited block _
#: ../../user-manual.txt:9
msgid ""
"This manual is designed to be readable by someone with basic UNIX command-"
"line skills, but no previous knowledge of git."
msgstr ""

#. type: delimited block _
#: ../../user-manual.txt:14
msgid ""
"<<repositories-and-branches>> and <<exploring-git-history>> explain how to "
"fetch and study a project using git--read these chapters to learn how to "
"build and test a particular version of a software project, search for "
"regressions, and so on."
msgstr ""

#. type: delimited block _
#: ../../user-manual.txt:17
msgid ""
"People needing to do actual development will also want to read <<Developing-"
"With-git>> and <<sharing-development>>."
msgstr ""

#. type: delimited block _
#: ../../user-manual.txt:19
msgid "Further chapters cover more specialized topics."
msgstr ""

#. type: delimited block _
#: ../../user-manual.txt:23
msgid ""
"Comprehensive reference documentation is available through the man pages, or "
"linkgit:git-help[1] command.  For example, for the command \"git clone <repo>"
"\", you can either use:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:26
#, no-wrap
msgid "$ man git-clone\n"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:32
#, no-wrap
msgid "$ git help clone\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:39
msgid ""
"See also <<git-quick-start>> for a brief overview of git commands, without "
"any explanation."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:42
msgid ""
"Finally, see <<todo>> for ways that you can help make this manual more "
"complete."
msgstr ""

#. type: Title =
#: ../../user-manual.txt:46
#, no-wrap
msgid "Repositories and Branches"
msgstr ""

#. type: Title -
#: ../../user-manual.txt:50
#, no-wrap
msgid "How to get a git repository"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:54
msgid ""
"It will be useful to have a git repository to experiment with as you read "
"this manual."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:58
msgid ""
"The best way to get one is by using the linkgit:git-clone[1] command to "
"download a copy of an existing repository.  If you don't already have a "
"project in mind, here are some interesting examples:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:64
#, no-wrap
msgid ""
"\t# git itself (approx. 10MB download):\n"
"$ git clone git://git.kernel.org/pub/scm/git/git.git\n"
"\t# the Linux kernel (approx. 150MB download):\n"
"$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:68
msgid ""
"The initial clone may be time-consuming for a large project, but you will "
"only need to clone once."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:75
msgid ""
"The clone command creates a new directory named after the project (\"git\" "
"or \"linux-2.6\" in the examples above).  After you cd into this directory, "
"you will see that it contains a copy of the project files, called the "
"<<def_working_tree,working tree>>, together with a special top-level "
"directory named \".git\", which contains all the information about the "
"history of the project."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:78
#, no-wrap
msgid "How to check out a different version of a project"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:84
msgid ""
"Git is best thought of as a tool for storing the history of a collection of "
"files.  It stores the history as a compressed collection of interrelated "
"snapshots of the project's contents.  In git each such version is called a "
"<<def_commit,commit>>."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:89
msgid ""
"Those snapshots aren't necessarily all arranged in a single line from oldest "
"to newest; instead, work may simultaneously proceed along parallel lines of "
"development, called <<def_branch,branches>>, which may merge and diverge."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:94
msgid ""
"A single git repository can track development on multiple branches.  It does "
"this by keeping a list of <<def_head,heads>> which reference the latest "
"commit on each branch; the linkgit:git-branch[1] command shows you the list "
"of branch heads:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:98
#, no-wrap
msgid ""
"$ git branch\n"
"* master\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:103
msgid ""
"A freshly cloned repository contains a single branch head, by default named "
"\"master\", with the working directory initialized to the state of the "
"project referred to by that branch head."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:107
msgid ""
"Most projects also use <<def_tag,tags>>.  Tags, like heads, are references "
"into the project's history, and can be listed using the linkgit:git-tag[1] "
"command:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:120
#, no-wrap
msgid ""
"$ git tag -l\n"
"v2.6.11\n"
"v2.6.11-tree\n"
"v2.6.12\n"
"v2.6.12-rc2\n"
"v2.6.12-rc3\n"
"v2.6.12-rc4\n"
"v2.6.12-rc5\n"
"v2.6.12-rc6\n"
"v2.6.13\n"
"...\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:124
msgid ""
"Tags are expected to always point at the same version of a project, while "
"heads are expected to advance as development progresses."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:127
msgid ""
"Create a new branch head pointing to one of these versions and check it out "
"using linkgit:git-checkout[1]:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:130
#, no-wrap
msgid "$ git checkout -b new v2.6.13\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:135
msgid ""
"The working directory then reflects the contents that the project had when "
"it was tagged v2.6.13, and linkgit:git-branch[1] shows two branches, with an "
"asterisk marking the currently checked-out branch:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:140
#, no-wrap
msgid ""
"$ git branch\n"
"  master\n"
"* new\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:144
msgid ""
"If you decide that you'd rather see version 2.6.17, you can modify the "
"current branch to point at v2.6.17 instead, with"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:147
#, no-wrap
msgid "$ git reset --hard v2.6.17\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:153
msgid ""
"Note that if the current branch head was your only reference to a particular "
"point in history, then resetting that branch may leave you with no way to "
"find the history it used to point to; so use this command carefully."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:156
#, no-wrap
msgid "Understanding History: Commits"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:161
msgid ""
"Every change in the history of a project is represented by a commit.  The "
"linkgit:git-show[1] command shows the most recent commit on the current "
"branch:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:167
#, no-wrap
msgid ""
"$ git show\n"
"commit 17cf781661e6d38f737f15f53ab552f1e95960d7\n"
"Author: Linus Torvalds <torvalds@ppc970.osdl.org.(none)>\n"
"Date:   Tue Apr 19 14:11:06 2005 -0700\n"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:169
#, no-wrap
msgid "    Remove duplicate getenv(DB_ENVIRONMENT) call\n"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:171
#, no-wrap
msgid "    Noted by Tony Luck.\n"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:177
#, no-wrap
msgid ""
"diff --git a/init-db.c b/init-db.c\n"
"index 65898fa..b002dc6 100644\n"
"--- a/init-db.c\n"
"+++ b/init-db.c\n"
"@@ -7,7 +7,7 @@\n"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:183
#, no-wrap
msgid ""
" int main(int argc, char **argv)\n"
" {\n"
"-\tchar *sha1_dir = getenv(DB_ENVIRONMENT), *path;\n"
"+\tchar *sha1_dir, *path;\n"
" \tint len, i;\n"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:185
#, no-wrap
msgid " \tif (mkdir(\".git\", 0755) < 0) {\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:189
msgid ""
"As you can see, a commit shows who made the latest change, what they did, "
"and why."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:200
msgid ""
"Every commit has a 40-hexdigit id, sometimes called the \"object name\" or "
"the \"SHA-1 id\", shown on the first line of the \"git show\" output.  You "
"can usually refer to a commit by a shorter name, such as a tag or a branch "
"name, but this longer name can also be useful.  Most importantly, it is a "
"globally unique name for this commit: so if you tell somebody else the "
"object name (for example in email), then you are guaranteed that name will "
"refer to the same commit in their repository that it does in yours (assuming "
"their repository has that commit at all).  Since the object name is computed "
"as a hash over the contents of the commit, you are guaranteed that the "
"commit can never change without its name also changing."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:204
msgid ""
"In fact, in <<git-concepts>> we shall see that everything stored in git "
"history, including file data and directory contents, is stored in an object "
"with a name that is a hash of its contents."
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:207
#, no-wrap
msgid "Understanding history: commits, parents, and reachability"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:213
msgid ""
"Every commit (except the very first commit in a project) also has a parent "
"commit which shows what happened before this commit.  Following the chain of "
"parents will eventually take you back to the beginning of the project."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:220
msgid ""
"However, the commits do not form a simple list; git allows lines of "
"development to diverge and then reconverge, and the point where two lines of "
"development reconverge is called a \"merge\".  The commit representing a "
"merge can therefore have more than one parent, with each parent representing "
"the most recent commit on one of the lines of development leading to that "
"point."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:224
msgid ""
"The best way to see how this works is using the linkgit:gitk[1] command; "
"running gitk now on a git repository and looking for merge commits will help "
"understand how the git organizes history."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:229
msgid ""
"In the following, we say that commit X is \"reachable\" from commit Y if "
"commit X is an ancestor of commit Y.  Equivalently, you could say that Y is "
"a descendant of X, or that there is a chain of parents leading from commit Y "
"to commit X."
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:232
#, no-wrap
msgid "Understanding history: History diagrams"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:237
msgid ""
"We will sometimes represent git history using diagrams like the one below.  "
"Commits are shown as \"o\", and the links between them with lines drawn with "
"- / and \\.  Time goes left to right:"
msgstr ""

#. type: delimited block .
#: ../../user-manual.txt:245
#, no-wrap
msgid ""
"         o--o--o <-- Branch A\n"
"        /\n"
" o--o--o <-- master\n"
"        \\\n"
"         o--o--o <-- Branch B\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:249
msgid ""
"If we need to talk about a particular commit, the character \"o\" may be "
"replaced with another letter or number."
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:252
#, no-wrap
msgid "Understanding history: What is a branch?"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:260
msgid ""
"When we need to be precise, we will use the word \"branch\" to mean a line "
"of development, and \"branch head\" (or just \"head\") to mean a reference "
"to the most recent commit on a branch.  In the example above, the branch "
"head named \"A\" is a pointer to one particular commit, but we refer to the "
"line of three commits leading up to that point as all being part of \"branch "
"A\"."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:263
msgid ""
"However, when no confusion will result, we often just use the term \"branch"
"\" both for branches and for branch heads."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:266
#, no-wrap
msgid "Manipulating branches"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:270
msgid ""
"Creating, deleting, and modifying branches is quick and easy; here's a "
"summary of the commands:"
msgstr ""

#. type: Labeled list
#: ../../user-manual.txt:271
#, no-wrap
msgid "git branch"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:273
msgid "list all branches"
msgstr ""

#. type: Labeled list
#: ../../user-manual.txt:273
#, no-wrap
msgid "git branch <branch>"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:276
msgid ""
"create a new branch named <branch>, referencing the same point in history as "
"the current branch"
msgstr ""

#. type: Labeled list
#: ../../user-manual.txt:276
#, no-wrap
msgid "git branch <branch> <start-point>"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:280
msgid ""
"create a new branch named <branch>, referencing <start-point>, which may be "
"specified any way you like, including using a branch name or a tag name"
msgstr ""

#. type: Labeled list
#: ../../user-manual.txt:280
#, no-wrap
msgid "git branch -d <branch>"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:284
msgid ""
"delete the branch <branch>; if the branch you are deleting points to a "
"commit which is not reachable from the current branch, this command will "
"fail with a warning."
msgstr ""

#. type: Labeled list
#: ../../user-manual.txt:284
#, no-wrap
msgid "git branch -D <branch>"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:290
msgid ""
"even if the branch points to a commit not reachable from the current branch, "
"you may know that that commit is still reachable from some other branch or "
"tag.  In that case it is safe to use this command to force git to delete the "
"branch."
msgstr ""

#. type: Labeled list
#: ../../user-manual.txt:290
#, no-wrap
msgid "git checkout <branch>"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:293
msgid ""
"make the current branch <branch>, updating the working directory to reflect "
"the version referenced by <branch>"
msgstr ""

#. type: Labeled list
#: ../../user-manual.txt:293
#, no-wrap
msgid "git checkout -b <new> <start-point>"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:296
msgid "create a new branch <new> referencing <start-point>, and check it out."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:300
msgid ""
"The special symbol \"HEAD\" can always be used to refer to the current "
"branch.  In fact, git uses a file named \"HEAD\" in the .git directory to "
"remember which branch is current:"
msgstr ""

#. type: Title -
#: ../../user-manual.txt:308
#, no-wrap
msgid "Examining an old version without creating a new branch"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:313
msgid ""
"The `git checkout` command normally expects a branch head, but will also "
"accept an arbitrary commit; for example, you can check out the commit "
"referenced by a tag:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:321
#, no-wrap
msgid ""
"$ git checkout v2.6.17\n"
"Note: moving to \"v2.6.17\" which isn't a local branch\n"
"If you want to create a new branch from this checkout, you may do so\n"
"(now or later) by using -b with the checkout command again. Example:\n"
"  git checkout -b <new_branch_name>\n"
"HEAD is now at 427abfa... Linux v2.6.17\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:325
msgid ""
"The HEAD then refers to the SHA-1 of the commit instead of to a branch, and "
"git branch shows that you are no longer on a branch:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:332
#, no-wrap
msgid ""
"$ cat .git/HEAD\n"
"427abfa28afedffadfca9dd8b067eb6d36bac53f\n"
"$ git branch\n"
"* (no branch)\n"
"  master\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:335
msgid "In this case we say that the HEAD is \"detached\"."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:339
#, no-wrap
msgid ""
"This is an easy way to check out a particular version without having to\n"
"make up a name for the new branch.   You can still create a new branch\n"
"(or tag) for this version later if you decide to.\n"
msgstr ""

#. type: Title -
#: ../../user-manual.txt:342
#, no-wrap
msgid "Examining branches from a remote repository"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:349
msgid ""
"The \"master\" branch that was created at the time you cloned is a copy of "
"the HEAD in the repository that you cloned from.  That repository may also "
"have had other branches, though, and your local repository keeps branches "
"which track each of those remote branches, which you can view using the \"-r"
"\" option to linkgit:git-branch[1]:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:360
#, no-wrap
msgid ""
"$ git branch -r\n"
"  origin/HEAD\n"
"  origin/html\n"
"  origin/maint\n"
"  origin/man\n"
"  origin/master\n"
"  origin/next\n"
"  origin/pu\n"
"  origin/todo\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:364
msgid ""
"You cannot check out these remote-tracking branches, but you can examine "
"them on a branch of your own, just as you would a tag:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:367
#, no-wrap
msgid "$ git checkout -b my-todo-copy origin/todo\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:371
msgid ""
"Note that the name \"origin\" is just the name that git uses by default to "
"refer to the repository that you cloned from."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:374
#, no-wrap
msgid "Naming branches, tags, and other references"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:380
msgid ""
"Branches, remote-tracking branches, and tags are all references to commits.  "
"All references are named with a slash-separated path name starting with "
"\"refs\"; the names we've been using so far are actually shorthand:"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:382
msgid "The branch \"test\" is short for \"refs/heads/test\"."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:383
msgid "The tag \"v2.6.18\" is short for \"refs/tags/v2.6.18\"."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:384
msgid "\"origin/master\" is short for \"refs/remotes/origin/master\"."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:387
msgid ""
"The full name is occasionally useful if, for example, there ever exists a "
"tag and a branch with the same name."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:392
msgid ""
"(Newly created refs are actually stored in the .git/refs directory, under "
"the path given by their name.  However, for efficiency reasons they may also "
"be packed together in a single file; see linkgit:git-pack-refs[1])."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:396
msgid ""
"As another useful shortcut, the \"HEAD\" of a repository can be referred to "
"just using the name of that repository.  So, for example, \"origin\" is "
"usually a shortcut for the HEAD branch in the repository \"origin\"."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:401
msgid ""
"For the complete list of paths which git checks for references, and the "
"order it uses to decide which to choose when there are multiple references "
"with the same shorthand name, see the \"SPECIFYING REVISIONS\" section of "
"linkgit:git-rev-parse[1]."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:404
#, no-wrap
msgid "Updating a repository with git fetch"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:409
msgid ""
"Eventually the developer cloned from will do additional work in her "
"repository, creating new commits and advancing the branches to point at the "
"new commits."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:414
msgid ""
"The command \"git fetch\", with no arguments, will update all of the remote-"
"tracking branches to the latest version found in her repository.  It will "
"not touch any of your own branches--not even the \"master\" branch that was "
"created for you on clone."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:417
#, no-wrap
msgid "Fetching branches from other repositories"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:421
msgid ""
"You can also track branches from repositories other than the one you cloned "
"from, using linkgit:git-remote[1]:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:427
#, no-wrap
msgid ""
"$ git remote add linux-nfs git://linux-nfs.org/pub/nfs-2.6.git\n"
"$ git fetch linux-nfs\n"
"* refs/remotes/linux-nfs/master: storing branch 'master' ...\n"
"  commit: bf81b46\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:431
msgid ""
"New remote-tracking branches will be stored under the shorthand name that "
"you gave \"git remote add\", in this case linux-nfs:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:436
#, no-wrap
msgid ""
"$ git branch -r\n"
"linux-nfs/master\n"
"origin/master\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:440
msgid ""
"If you run \"git fetch <remote>\" later, the tracking branches for the named "
"<remote> will be updated."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:443
msgid ""
"If you examine the file .git/config, you will see that git has added a new "
"stanza:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:451
#, no-wrap
msgid ""
"$ cat .git/config\n"
"...\n"
"[remote \"linux-nfs\"]\n"
"\turl = git://linux-nfs.org/pub/nfs-2.6.git\n"
"\tfetch = +refs/heads/*:refs/remotes/linux-nfs/*\n"
"...\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:457
msgid ""
"This is what causes git to track the remote's branches; you may modify or "
"delete these configuration options by editing .git/config with a text "
"editor.  (See the \"CONFIGURATION FILE\" section of linkgit:git-config[1] "
"for details.)"
msgstr ""

#. type: Title =
#: ../../user-manual.txt:460
#, no-wrap
msgid "Exploring git history"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:466
msgid ""
"Git is best thought of as a tool for storing the history of a collection of "
"files.  It does this by storing compressed snapshots of the contents of a "
"file hierarchy, together with \"commits\" which show the relationships "
"between these snapshots."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:469
msgid ""
"Git provides extremely flexible and fast tools for exploring the history of "
"a project."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:472
msgid ""
"We start with one specialized tool that is useful for finding the commit "
"that introduced a bug into a project."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:475
#, no-wrap
msgid "How to use bisect to find a regression"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:482
msgid ""
"Suppose version 2.6.18 of your project worked, but the version at \"master\" "
"crashes.  Sometimes the best way to find the cause of such a regression is "
"to perform a brute-force search through the project's history to find the "
"particular commit that caused the problem.  The linkgit:git-bisect[1] "
"command can help you do this:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:489
#, no-wrap
msgid ""
"$ git bisect start\n"
"$ git bisect good v2.6.18\n"
"$ git bisect bad master\n"
"Bisecting: 3537 revisions left to test after this\n"
"[65934a9a028b88e83e2b0f8b36618fe503349f8e] BLOCK: Make USB storage depend on SCSI rather than selecting it [try #6]\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:496
msgid ""
"If you run \"git branch\" at this point, you'll see that git has temporarily "
"moved you in \"(no branch)\". HEAD is now detached from any branch and "
"points directly to a commit (with commit id 65934...) that is reachable from "
"\"master\" but not from v2.6.18. Compile and test it, and see whether it "
"crashes. Assume it does crash. Then:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:501
#, no-wrap
msgid ""
"$ git bisect bad\n"
"Bisecting: 1769 revisions left to test after this\n"
"[7eff82c8b1511017ae605f0c99ac275a7e21b867] i2c-core: Drop useless bitmaskings\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:507
msgid ""
"checks out an older version.  Continue like this, telling git at each stage "
"whether the version it gives you is good or bad, and notice that the number "
"of revisions left to test is cut approximately in half each time."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:512
msgid ""
"After about 13 tests (in this case), it will output the commit id of the "
"guilty commit.  You can then examine the commit with linkgit:git-show[1], "
"find out who wrote it, and mail them your bug report with the commit id.  "
"Finally, run"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:518
msgid "to return you to the branch you were on before."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:524
msgid ""
"Note that the version which `git bisect` checks out for you at each point is "
"just a suggestion, and you're free to try a different version if you think "
"it would be a good idea.  For example, occasionally you may land on a commit "
"that broke something unrelated; run"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:532
msgid ""
"which will run gitk and label the commit it chose with a marker that says "
"\"bisect\".  Choose a safe-looking commit nearby, note its commit id, and "
"check it out with:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:535
#, no-wrap
msgid "$ git reset --hard fb47ddb2db...\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:539
msgid ""
"then test, run \"bisect good\" or \"bisect bad\" as appropriate, and "
"continue."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:543
msgid ""
"Instead of \"git bisect visualize\" and then \"git reset --hard fb47ddb2db..."
"\", you might just want to tell git that you want to skip the current commit:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:546
#, no-wrap
msgid "$ git bisect skip\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:550
msgid ""
"In this case, though, git may not eventually be able to tell the first bad "
"one between some first skipped commits and a later bad commit."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:555
msgid ""
"There are also ways to automate the bisecting process if you have a test "
"script that can tell a good from a bad commit. See linkgit:git-bisect[1] for "
"more information about this and other \"git bisect\" features."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:558
#, no-wrap
msgid "Naming commits"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:561
msgid "We have seen several ways of naming commits already:"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:563
msgid "40-hexdigit object name"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:565
msgid "branch name: refers to the commit at the head of the given branch"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:568
msgid ""
"tag name: refers to the commit pointed to by the given tag (we've seen "
"branches and tags are special cases of <<how-git-stores-references,"
"references>>)."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:569
msgid "HEAD: refers to the head of the current branch"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:573
msgid ""
"There are many more; see the \"SPECIFYING REVISIONS\" section of the linkgit:"
"git-rev-parse[1] man page for the complete list of ways to name revisions.  "
"Some examples:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:580
#, no-wrap
msgid ""
"$ git show fb47ddb2 # the first few characters of the object name\n"
"\t\t    # are usually enough to specify it uniquely\n"
"$ git show HEAD^    # the parent of the HEAD commit\n"
"$ git show HEAD^^   # the grandparent\n"
"$ git show HEAD~4   # the great-great-grandparent\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:585
msgid ""
"Recall that merge commits may have more than one parent; by default, ^ and ~ "
"follow the first parent listed in the commit, but you can also choose:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:589
#, no-wrap
msgid ""
"$ git show HEAD^1   # show the first parent of HEAD\n"
"$ git show HEAD^2   # show the second parent of HEAD\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:593
msgid "In addition to HEAD, there are several other special names for commits:"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:597
msgid ""
"Merges (to be discussed later), as well as operations such as `git reset`, "
"which change the currently checked-out commit, generally set ORIG_HEAD to "
"the value HEAD had before the current operation."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:601
msgid ""
"The `git fetch` operation always stores the head of the last fetched branch "
"in FETCH_HEAD.  For example, if you run `git fetch` without specifying a "
"local branch as the target of the operation"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:604
#, no-wrap
msgid "$ git fetch git://example.com/proj.git theirbranch\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:607
msgid "the fetched commits will still be available from FETCH_HEAD."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:611
msgid ""
"When we discuss merges we'll also see the special name MERGE_HEAD, which "
"refers to the other branch that we're merging in to the current branch."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:615
msgid ""
"The linkgit:git-rev-parse[1] command is a low-level command that is "
"occasionally useful for translating some name for a commit to the object "
"name for that commit:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:619
#, no-wrap
msgid ""
"$ git rev-parse origin\n"
"e05db0fd4f31dde7005f075a84f96b360d05984b\n"
msgstr ""

#. type: Title -
#: ../../user-manual.txt:623
#, no-wrap
msgid "Creating tags"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:627
msgid "We can also create a tag to refer to a particular commit; after running"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:630
#, no-wrap
msgid "$ git tag stable-1 1b2e1d63ff\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:633
msgid "You can use stable-1 to refer to the commit 1b2e1d63ff."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:638
msgid ""
"This creates a \"lightweight\" tag.  If you would also like to include a "
"comment with the tag, and possibly sign it cryptographically, then you "
"should create a tag object instead; see the linkgit:git-tag[1] man page for "
"details."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:641
#, no-wrap
msgid "Browsing revisions"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:646
msgid ""
"The linkgit:git-log[1] command can show lists of commits.  On its own, it "
"shows all commits reachable from the parent commit; but you can also make "
"more specific requests:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:658
#, no-wrap
msgid ""
"$ git log v2.5..\t# commits since (not reachable from) v2.5\n"
"$ git log test..master\t# commits reachable from master but not test\n"
"$ git log master..test\t# ...reachable from test but not master\n"
"$ git log master...test\t# ...reachable from either test or master,\n"
"\t\t\t#    but not both\n"
"$ git log --since=\"2 weeks ago\" # commits from the last 2 weeks\n"
"$ git log Makefile      # commits which modify Makefile\n"
"$ git log fs/\t\t# ... which modify any file under fs/\n"
"$ git log -S'foo()'\t# commits which add or remove any file data\n"
"\t\t\t# matching the string 'foo()'\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:662
msgid ""
"And of course you can combine all of these; the following finds commits "
"since v2.5 which touch the Makefile or any file under fs:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:665
#, no-wrap
msgid "$ git log v2.5.. Makefile fs/\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:668
msgid "You can also ask git log to show patches:"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:675
msgid ""
"See the \"--pretty\" option in the linkgit:git-log[1] man page for more "
"display options."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:680
msgid ""
"Note that git log starts with the most recent commit and works backwards "
"through the parents; however, since git history can contain multiple "
"independent lines of development, the particular order that commits are "
"listed in may be somewhat arbitrary."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:683
#, no-wrap
msgid "Generating diffs"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:687
msgid ""
"You can generate diffs between any two versions using linkgit:git-diff[1]:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:690
#, no-wrap
msgid "$ git diff master..test\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:695
msgid ""
"That will produce the diff between the tips of the two branches.  If you'd "
"prefer to find the diff from their common ancestor to test, you can use "
"three dots instead of two:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:698
#, no-wrap
msgid "$ git diff master...test\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:702
msgid ""
"Sometimes what you want instead is a set of patches; for this you can use "
"linkgit:git-format-patch[1]:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:705
#, no-wrap
msgid "$ git format-patch master..test\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:709
msgid ""
"will generate a file with a patch for each commit reachable from test but "
"not from master."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:712
#, no-wrap
msgid "Viewing old file versions"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:718
msgid ""
"You can always view an old version of a file by just checking out the "
"correct revision first.  But sometimes it is more convenient to be able to "
"view an old version of a single file without checking anything out; this "
"command does that:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:721
#, no-wrap
msgid "$ git show v2.5:fs/locks.c\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:725
msgid ""
"Before the colon may be anything that names a commit, and after it may be "
"any path to a file tracked by git."
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:732
#, no-wrap
msgid "Counting the number of commits on a branch"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:736
msgid ""
"Suppose you want to know how many commits you've made on \"mybranch\" since "
"it diverged from \"origin\":"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:739
#, no-wrap
msgid "$ git log --pretty=oneline origin..mybranch | wc -l\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:744
msgid ""
"Alternatively, you may often see this sort of thing done with the lower-"
"level command linkgit:git-rev-list[1], which just lists the SHA-1's of all "
"the given commits:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:747
#, no-wrap
msgid "$ git rev-list origin..mybranch | wc -l\n"
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:751
#, no-wrap
msgid "Check whether two branches point at the same history"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:755
msgid ""
"Suppose you want to check whether two branches point at the same point in "
"history."
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:758
#, no-wrap
msgid "$ git diff origin..master\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:764
msgid ""
"will tell you whether the contents of the project are the same at the two "
"branches; in theory, however, it's possible that the same project contents "
"could have been arrived at by two different historical routes.  You could "
"compare the object names:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:770
#, no-wrap
msgid ""
"$ git rev-list origin\n"
"e05db0fd4f31dde7005f075a84f96b360d05984b\n"
"$ git rev-list master\n"
"e05db0fd4f31dde7005f075a84f96b360d05984b\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:775
msgid ""
"Or you could recall that the ... operator selects all commits contained "
"reachable from either one reference or the other but not both: so"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:778
#, no-wrap
msgid "$ git log origin...master\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:781
msgid "will return no commits when the two branches are equal."
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:784
#, no-wrap
msgid "Find first tagged version including a given fix"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:789
msgid ""
"Suppose you know that the commit e05db0fd fixed a certain problem.  You'd "
"like to find the earliest tagged release that contains that fix."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:793
msgid ""
"Of course, there may be more than one answer--if the history branched after "
"commit e05db0fd, then there could be multiple \"earliest\" tagged releases."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:795
msgid "You could just visually inspect the commits since e05db0fd:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:798
#, no-wrap
msgid "$ gitk e05db0fd..\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:803
msgid ""
"Or you can use linkgit:git-name-rev[1], which will give the commit a name "
"based on any tag it finds pointing to one of the commit's descendants:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:807
#, no-wrap
msgid ""
"$ git name-rev --tags e05db0fd\n"
"e05db0fd tags/v1.5.0-rc1^0~23\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:811
msgid ""
"The linkgit:git-describe[1] command does the opposite, naming the revision "
"using a tag on which the given commit is based:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:815
#, no-wrap
msgid ""
"$ git describe e05db0fd\n"
"v1.5.0-rc0-260-ge05db0f\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:819
msgid ""
"but that may sometimes help you guess which tags might come after the given "
"commit."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:822
msgid ""
"If you just want to verify whether a given tagged version contains a given "
"commit, you could use linkgit:git-merge-base[1]:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:826
#, no-wrap
msgid ""
"$ git merge-base e05db0fd v1.5.0-rc1\n"
"e05db0fd4f31dde7005f075a84f96b360d05984b\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:832
msgid ""
"The merge-base command finds a common ancestor of the given commits, and "
"always returns one or the other in the case where one is a descendant of the "
"other; so the above output shows that e05db0fd actually is an ancestor of "
"v1.5.0-rc1."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:834
msgid "Alternatively, note that"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:837
#, no-wrap
msgid "$ git log v1.5.0-rc1..e05db0fd\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:841
msgid ""
"will produce empty output if and only if v1.5.0-rc1 includes e05db0fd, "
"because it outputs only commits that are not reachable from v1.5.0-rc1."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:846
msgid ""
"As yet another alternative, the linkgit:git-show-branch[1] command lists the "
"commits reachable from its arguments with a display on the left-hand side "
"that indicates which arguments that commit is reachable from.  So, you can "
"run something like"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:855
#, no-wrap
msgid ""
"$ git show-branch e05db0fd v1.5.0-rc0 v1.5.0-rc1 v1.5.0-rc2\n"
"! [e05db0fd] Fix warnings in sha1_file.c - use C99 printf format if\n"
"available\n"
" ! [v1.5.0-rc0] GIT v1.5.0 preview\n"
"  ! [v1.5.0-rc1] GIT v1.5.0-rc1\n"
"   ! [v1.5.0-rc2] GIT v1.5.0-rc2\n"
"...\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:858
msgid "then search for a line that looks like"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:862
#, no-wrap
msgid ""
"+ ++ [e05db0fd] Fix warnings in sha1_file.c - use C99 printf format if\n"
"available\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:866
msgid ""
"Which shows that e05db0fd is reachable from itself, from v1.5.0-rc1, and "
"from v1.5.0-rc2, but not from v1.5.0-rc0."
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:869
#, no-wrap
msgid "Showing commits unique to a given branch"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:873
msgid ""
"Suppose you would like to see all the commits reachable from the branch head "
"named \"master\" but not from any other head in your repository."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:876
msgid ""
"We can list all the heads in this repository with linkgit:git-show-ref[1]:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:884
#, no-wrap
msgid ""
"$ git show-ref --heads\n"
"bf62196b5e363d73353a9dcf094c59595f3153b7 refs/heads/core-tutorial\n"
"db768d5504c1bb46f63ee9d6e1772bd047e05bf9 refs/heads/maint\n"
"a07157ac624b2524a059a3414e99f6f44bebc1e7 refs/heads/master\n"
"24dbc180ea14dc1aebe09f14c8ecf32010690627 refs/heads/tutorial-2\n"
"1e87486ae06626c2f31eaa63d26fc0fd646c8af2 refs/heads/tutorial-fixes\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:888
msgid ""
"We can get just the branch-head names, and remove \"master\", with the help "
"of the standard utilities cut and grep:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:895
#, no-wrap
msgid ""
"$ git show-ref --heads | cut -d' ' -f2 | grep -v '^refs/heads/master'\n"
"refs/heads/core-tutorial\n"
"refs/heads/maint\n"
"refs/heads/tutorial-2\n"
"refs/heads/tutorial-fixes\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:899
msgid ""
"And then we can ask to see all the commits reachable from master but not "
"from these other heads:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:903
#, no-wrap
msgid ""
"$ gitk master --not $( git show-ref --heads | cut -d' ' -f2 |\n"
"\t\t\t\tgrep -v '^refs/heads/master' )\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:907
msgid ""
"Obviously, endless variations are possible; for example, to see all commits "
"reachable from some head but not from any tag in the repository:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:910
#, no-wrap
msgid "$ gitk $( git show-ref --heads ) --not  $( git show-ref --tags )\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:914
msgid ""
"(See linkgit:git-rev-parse[1] for explanations of commit-selecting syntax "
"such as `--not`.)"
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:917
#, no-wrap
msgid "Creating a changelog and tarball for a software release"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:921
msgid ""
"The linkgit:git-archive[1] command can create a tar or zip archive from any "
"version of a project; for example:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:924
#, no-wrap
msgid "$ git archive --format=tar --prefix=project/ HEAD | gzip >latest.tar.gz\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:928
msgid ""
"will use HEAD to produce a tar archive in which each filename is preceded by "
"\"project/\"."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:932
msgid ""
"If you're releasing a new version of a software project, you may want to "
"simultaneously make a changelog to include in the release announcement."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:935
msgid ""
"Linus Torvalds, for example, makes new kernel releases by tagging them, then "
"running:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:938
#, no-wrap
msgid "$ release-script 2.6.12 2.6.13-rc6 2.6.13-rc7\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:941
msgid "where release-script is a shell script that looks like:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:953
#, no-wrap
msgid ""
"#!/bin/sh\n"
"stable=\"$1\"\n"
"last=\"$2\"\n"
"new=\"$3\"\n"
"echo \"# git tag v$new\"\n"
"echo \"git archive --prefix=linux-$new/ v$new | gzip -9 > ../linux-$new.tar.gz\"\n"
"echo \"git diff v$stable v$new | gzip -9 > ../patch-$new.gz\"\n"
"echo \"git log --no-merges v$new ^v$last > ../ChangeLog-$new\"\n"
"echo \"git shortlog --no-merges v$new ^v$last > ../ShortLog\"\n"
"echo \"git diff --stat --summary -M v$last v$new > ../diffstat-$new\"\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:957
msgid ""
"and then he just cut-and-pastes the output commands after verifying that "
"they look OK."
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:960
#, no-wrap
msgid "Finding commits referencing a file with given content"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:965
msgid ""
"Somebody hands you a copy of a file, and asks which commits modified a file "
"such that it contained the given content either before or after the commit.  "
"You can find out with this:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:969
#, no-wrap
msgid ""
"$  git log --raw --abbrev=40 --pretty=oneline |\n"
"\tgrep -B 1 `git hash-object filename`\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:974
msgid ""
"Figuring out why this works is left as an exercise to the (advanced)  "
"student.  The linkgit:git-log[1], linkgit:git-diff-tree[1], and linkgit:git-"
"hash-object[1] man pages may prove helpful."
msgstr ""

#. type: Title =
#: ../../user-manual.txt:977
#, no-wrap
msgid "Developing with git"
msgstr ""

#. type: Title -
#: ../../user-manual.txt:981
#, no-wrap
msgid "Telling git your name"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:986
msgid ""
"Before creating any commits, you should introduce yourself to git.  The "
"easiest way to do so is to make sure the following lines appear in a file "
"named .gitconfig in your home directory:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:991
#, no-wrap
msgid ""
"[user]\n"
"\tname = Your Name Comes Here\n"
"\temail = you@yourdomain.example.com\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:995
msgid ""
"(See the \"CONFIGURATION FILE\" section of linkgit:git-config[1] for details "
"on the configuration file.)"
msgstr ""

#. type: Title -
#: ../../user-manual.txt:999 ../../user-manual.txt:4290
#, no-wrap
msgid "Creating a new repository"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1002
msgid "Creating a new repository from scratch is very easy:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1007
#, no-wrap
msgid ""
"$ mkdir project\n"
"$ cd project\n"
"$ git init\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1010
msgid "If you have some initial content (say, a tarball):"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1017
#, no-wrap
msgid ""
"$ tar xzvf project.tar.gz\n"
"$ cd project\n"
"$ git init\n"
"$ git add . # include everything below ./ in the first commit:\n"
"$ git commit\n"
msgstr ""

#. type: Title -
#: ../../user-manual.txt:1021
#, no-wrap
msgid "How to make a commit"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1024
msgid "Creating a new commit takes three steps:"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1027
msgid ""
"Making some changes to the working directory using your favorite editor."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1028
msgid "Telling git about your changes."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1030
msgid "Creating the commit using the content you told git about in step 2."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1035
msgid ""
"In practice, you can interleave and repeat steps 1 and 2 as many times as "
"you want: in order to keep track of what you want committed at step 3, git "
"maintains a snapshot of the tree's contents in a special staging area called "
"\"the index.\""
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1040
msgid ""
"At the beginning, the content of the index will be identical to that of the "
"HEAD.  The command \"git diff --cached\", which shows the difference between "
"the HEAD and the index, should therefore produce no output at that point."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1042
msgid "Modifying the index is easy:"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1044
msgid "To update the index with the new contents of a modified file, use"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1047 ../../user-manual.txt:1053
#, no-wrap
msgid "$ git add path/to/file\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1050
msgid "To add the contents of a new file to the index, use"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1056
msgid "To remove a file from the index and from the working tree,"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1059
#, no-wrap
msgid "$ git rm path/to/file\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1062
msgid "After each step you can verify that"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1069
msgid ""
"always shows the difference between the HEAD and the index file--this is "
"what you'd commit if you created the commit now--and that"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1075
msgid "shows the difference between the working tree and the index file."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1079
msgid ""
"Note that \"git add\" always adds just the current contents of a file to the "
"index; further changes to the same file will be ignored unless you run `git "
"add` on the file again."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1081
msgid "When you're ready, just run"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1088
msgid ""
"and git will prompt you for a commit message and then create the new "
"commit.  Check to make sure it looks like what you expected with"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1091
#, no-wrap
msgid "$ git show\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1094
msgid "As a special shortcut,"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1101
msgid ""
"will update the index with any files that you've modified or removed and "
"create a commit, all in one step."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1104
msgid ""
"A number of commands are useful for keeping track of what you're about to "
"commit:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1114
#, no-wrap
msgid ""
"$ git diff --cached # difference between HEAD and the index; what\n"
"\t\t    # would be committed if you ran \"commit\" now.\n"
"$ git diff\t    # difference between the index file and your\n"
"\t\t    # working directory; changes that would not\n"
"\t\t    # be included if you ran \"commit\" now.\n"
"$ git diff HEAD\t    # difference between HEAD and working tree; what\n"
"\t\t    # would be committed if you ran \"commit -a\" now.\n"
"$ git status\t    # a brief per-file summary of the above.\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1120
msgid ""
"You can also use linkgit:git-gui[1] to create commits, view changes in the "
"index and the working tree files, and individually select diff hunks for "
"inclusion in the index (by right-clicking on the diff hunk and choosing "
"\"Stage Hunk For Commit\")."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:1123
#, no-wrap
msgid "Creating good commit messages"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1131
msgid ""
"Though not required, it's a good idea to begin the commit message with a "
"single short (less than 50 character) line summarizing the change, followed "
"by a blank line and then a more thorough description.  Tools that turn "
"commits into email, for example, use the first line on the Subject line and "
"the rest of the commit in the body."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:1134
#, no-wrap
msgid "Ignoring files"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1143
msgid ""
"A project will often generate files that you do 'not' want to track with "
"git.  This typically includes files generated by a build process or "
"temporary backup files made by your editor. Of course, 'not' tracking files "
"with git is just a matter of 'not' calling `git add` on them. But it quickly "
"becomes annoying to have these untracked files lying around; e.g. they make "
"`git add .` practically useless, and they keep showing up in the output of "
"`git status`."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1146
msgid ""
"You can tell git to ignore certain files by creating a file called ."
"gitignore in the top level of your working directory, with contents such as:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1157
#, no-wrap
msgid ""
"# Lines starting with '#' are considered comments.\n"
"# Ignore any file named foo.txt.\n"
"foo.txt\n"
"# Ignore (generated) html files,\n"
"*.html\n"
"# except foo.html which is maintained by hand.\n"
"!foo.html\n"
"# Ignore objects and archives.\n"
"*.[oa]\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1165
msgid ""
"See linkgit:gitignore[5] for a detailed explanation of the syntax.  You can "
"also place .gitignore files in other directories in your working tree, and "
"they will apply to those directories and their subdirectories.  The `."
"gitignore` files can be added to your repository like any other files (just "
"run `git add .gitignore` and `git commit`, as usual), which is convenient "
"when the exclude patterns (such as patterns matching build output files) "
"would also make sense for other users who clone your repository."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1172
msgid ""
"If you wish the exclude patterns to affect only certain repositories "
"(instead of every repository for a given project), you may instead put them "
"in a file in your repository named .git/info/exclude, or in any file "
"specified by the `core.excludesfile` configuration variable.  Some git "
"commands can also take exclude patterns directly on the command line.  See "
"linkgit:gitignore[5] for the details."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:1175
#, no-wrap
msgid "How to merge"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1179
msgid ""
"You can rejoin two diverging branches of development using linkgit:git-merge"
"[1]:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1182
#, no-wrap
msgid "$ git merge branchname\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1188
msgid ""
"merges the development in the branch \"branchname\" into the current "
"branch.  If there are conflicts--for example, if the same file is modified "
"in two different ways in the remote branch and the local branch--then you "
"are warned; the output may look something like this:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1195
#, no-wrap
msgid ""
"$ git merge next\n"
" 100% (4/4) done\n"
"Auto-merged file.txt\n"
"CONFLICT (content): Merge conflict in file.txt\n"
"Automatic merge failed; fix conflicts and then commit the result.\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1201
msgid ""
"Conflict markers are left in the problematic files, and after you resolve "
"the conflicts manually, you can update the index with the contents and run "
"git commit, as you normally would when creating a new file."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1205
msgid ""
"If you examine the resulting commit using gitk, you will see that it has two "
"parents, one pointing to the top of the current branch, and one to the top "
"of the other branch."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:1208
#, no-wrap
msgid "Resolving a merge"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1213
msgid ""
"When a merge isn't resolved automatically, git leaves the index and the "
"working tree in a special state that gives you all the information you need "
"to help resolve the merge."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1217
msgid ""
"Files with conflicts are marked specially in the index, so until you resolve "
"the problem and update the index, linkgit:git-commit[1] will fail:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1221
#, no-wrap
msgid ""
"$ git commit\n"
"file.txt: needs merge\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1225
msgid ""
"Also, linkgit:git-status[1] will list those files as \"unmerged\", and the "
"files with conflicts will have conflict markers added, like this:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1232
#, no-wrap
msgid ""
"<<<<<<< HEAD:file.txt\n"
"Hello world\n"
"=======\n"
"Goodbye\n"
">>>>>>> 77976da35a11db4580b80ae27e8d65caf5208086:file.txt\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1235
msgid "All you need to do is edit the files to resolve the conflicts, and then"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1239
#, no-wrap
msgid ""
"$ git add file.txt\n"
"$ git commit\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1245
msgid ""
"Note that the commit message will already be filled in for you with some "
"information about the merge.  Normally you can just use this default message "
"unchanged, but you may add additional commentary of your own if desired."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1248
msgid ""
"The above is all you need to know to resolve a simple merge.  But git also "
"provides more information to help resolve conflicts:"
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:1251
#, no-wrap
msgid "Getting conflict-resolution help during a merge"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1256
msgid ""
"All of the changes that git was able to merge automatically are already "
"added to the index file, so linkgit:git-diff[1] shows only the conflicts.  "
"It uses an unusual syntax:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1269
#, no-wrap
msgid ""
"$ git diff\n"
"diff --cc file.txt\n"
"index 802992c,2b60207..0000000\n"
"--- a/file.txt\n"
"+++ b/file.txt\n"
"@@@ -1,1 -1,1 +1,5 @@@\n"
"++<<<<<<< HEAD:file.txt\n"
" +Hello world\n"
"++=======\n"
"+ Goodbye\n"
"++>>>>>>> 77976da35a11db4580b80ae27e8d65caf5208086:file.txt\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1275
msgid ""
"Recall that the commit which will be committed after we resolve this "
"conflict will have two parents instead of the usual one: one parent will be "
"HEAD, the tip of the current branch; the other will be the tip of the other "
"branch, which is stored temporarily in MERGE_HEAD."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1278
msgid ""
"During the merge, the index holds three versions of each file.  Each of "
"these three \"file stages\" represents a different version of the file:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1283
#, no-wrap
msgid ""
"$ git show :1:file.txt\t# the file in a common ancestor of both branches\n"
"$ git show :2:file.txt\t# the version from HEAD.\n"
"$ git show :3:file.txt\t# the version from MERGE_HEAD.\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1290
msgid ""
"When you ask linkgit:git-diff[1] to show the conflicts, it runs a three-way "
"diff between the conflicted merge results in the work tree with stages 2 and "
"3 to show only hunks whose contents come from both sides, mixed (in other "
"words, when a hunk's merge results come only from stage 2, that part is not "
"conflicting and is not shown.  Same for stage 3)."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1298
msgid ""
"The diff above shows the differences between the working-tree version of "
"file.txt and the stage 2 and stage 3 versions.  So instead of preceding each "
"line by a single \"+\" or \"-\", it now uses two columns: the first column "
"is used for differences between the first parent and the working directory "
"copy, and the second for differences between the second parent and the "
"working directory copy.  (See the \"COMBINED DIFF FORMAT\" section of "
"linkgit:git-diff-files[1] for a details of the format.)"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1301
msgid ""
"After resolving the conflict in the obvious way (but before updating the "
"index), the diff will look like:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1312
#, no-wrap
msgid ""
"$ git diff\n"
"diff --cc file.txt\n"
"index 802992c,2b60207..0000000\n"
"--- a/file.txt\n"
"+++ b/file.txt\n"
"@@@ -1,1 -1,1 +1,1 @@@\n"
"- Hello world\n"
" -Goodbye\n"
"++Goodbye world\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1317
msgid ""
"This shows that our resolved version deleted \"Hello world\" from the first "
"parent, deleted \"Goodbye\" from the second parent, and added \"Goodbye world"
"\", which was previously absent from both."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1320
msgid ""
"Some special diff options allow diffing the working directory against any of "
"these stages:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1328
#, no-wrap
msgid ""
"$ git diff -1 file.txt\t\t# diff against stage 1\n"
"$ git diff --base file.txt\t# same as the above\n"
"$ git diff -2 file.txt\t\t# diff against stage 2\n"
"$ git diff --ours file.txt\t# same as the above\n"
"$ git diff -3 file.txt\t\t# diff against stage 3\n"
"$ git diff --theirs file.txt\t# same as the above.\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1332
msgid ""
"The linkgit:git-log[1] and linkgit:gitk[1] commands also provide special "
"help for merges:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1336
#, no-wrap
msgid ""
"$ git log --merge\n"
"$ gitk --merge\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1340
msgid ""
"These will display all commits which exist only on HEAD or on MERGE_HEAD, "
"and which touch an unmerged file."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1343
msgid ""
"You may also use linkgit:git-mergetool[1], which lets you merge the unmerged "
"files using external tools such as Emacs or kdiff3."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1345
msgid "Each time you resolve the conflicts in a file and update the index:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1348
#, no-wrap
msgid "$ git add file.txt\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1352
msgid ""
"the different stages of that file will be \"collapsed\", after which `git "
"diff` will (by default) no longer show diffs for that file."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:1355
#, no-wrap
msgid "Undoing a merge"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1359
msgid ""
"If you get stuck and decide to just give up and throw the whole mess away, "
"you can always return to the pre-merge state with"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1362 ../../user-manual.txt:1400
#, no-wrap
msgid "$ git reset --hard HEAD\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1365
msgid "Or, if you've already committed the merge that you want to throw away,"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1368
#, no-wrap
msgid "$ git reset --hard ORIG_HEAD\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1374
msgid ""
"However, this last command can be dangerous in some cases--never throw away "
"a commit you have already committed if that commit may itself have been "
"merged into another branch, as doing so may confuse further merges."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:1377
#, no-wrap
msgid "Fast-forward merges"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1383
msgid ""
"There is one special case not mentioned above, which is treated "
"differently.  Normally, a merge results in a merge commit, with two parents, "
"one pointing at each of the two lines of development that were merged."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1389
msgid ""
"However, if the current branch is a descendant of the other--so every commit "
"present in the one is already contained in the other--then git just performs "
"a \"fast forward\"; the head of the current branch is moved forward to point "
"at the head of the merged-in branch, without any new commits being created."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:1392
#, no-wrap
msgid "Fixing mistakes"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1397
msgid ""
"If you've messed up the working tree, but haven't yet committed your "
"mistake, you can return the entire working tree to the last committed state "
"with"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1404
msgid ""
"If you make a commit that you later wish you hadn't, there are two "
"fundamentally different ways to fix the problem:"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1406
msgid "You can create a new commit that undoes whatever was done"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1408
msgid ""
"by the old commit.  This is the correct thing if your mistake has already "
"been made public."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1410
msgid "You can go back and modify the old commit.  You should"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1414
msgid ""
"never do this if you have already made the history public; git does not "
"normally expect the \"history\" of a project to change, and cannot correctly "
"perform repeated merges from a branch that has had its history changed."
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:1417
#, no-wrap
msgid "Fixing a mistake with a new commit"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1422
msgid ""
"Creating a new commit that reverts an earlier change is very easy; just pass "
"the linkgit:git-revert[1] command a reference to the bad commit; for "
"example, to revert the most recent commit:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1425
#, no-wrap
msgid "$ git revert HEAD\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1429
msgid ""
"This will create a new commit which undoes the change in HEAD.  You will be "
"given a chance to edit the commit message for the new commit."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1431
msgid "You can also revert an earlier change, for example, the next-to-last:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1434
#, no-wrap
msgid "$ git revert HEAD^\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1441
msgid ""
"In this case git will attempt to undo the old change while leaving intact "
"any changes made since then.  If more recent changes overlap with the "
"changes to be reverted, then you will be asked to fix conflicts manually, "
"just as in the case of <<resolving-a-merge, resolving a merge>>."
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:1444
#, no-wrap
msgid "Fixing a mistake by rewriting history"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1449
msgid ""
"If the problematic commit is the most recent commit, and you have not yet "
"made that commit public, then you may just <<undoing-a-merge,destroy it "
"using `git reset`>>."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1454
msgid ""
"Alternatively, you can edit the working directory and update the index to "
"fix your mistake, just as if you were going to <<how-to-make-a-commit,create "
"a new commit>>, then run"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1457 ../../user-manual.txt:2496
#, no-wrap
msgid "$ git commit --amend\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1461 ../../user-manual.txt:2500
msgid ""
"which will replace the old commit by a new commit incorporating your "
"changes, giving you a chance to edit the old commit message first."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1465
msgid ""
"Again, you should never do this to a commit that may already have been "
"merged into another branch; use linkgit:git-revert[1] instead in that case."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1469
msgid ""
"It is also possible to replace commits further back in the history, but this "
"is an advanced topic to be left for <<cleaning-up-history,another chapter>>."
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:1472
#, no-wrap
msgid "Checking out an old version of a file"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1479
msgid ""
"In the process of undoing a previous bad change, you may find it useful to "
"check out an older version of a particular file using linkgit:git-checkout"
"[1].  We've used `git checkout` before to switch branches, but it has quite "
"different behavior if it is given a path name: the command"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1482
#, no-wrap
msgid "$ git checkout HEAD^ path/to/file\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1486
msgid ""
"replaces path/to/file by the contents it had in the commit HEAD^, and also "
"updates the index to match.  It does not change branches."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1490
msgid ""
"If you just want to look at an old version of the file, without modifying "
"the working directory, you can do that with linkgit:git-show[1]:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1493
#, no-wrap
msgid "$ git show HEAD^:path/to/file\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1496
msgid "which will display the given version of the file."
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:1499
#, no-wrap
msgid "Temporarily setting aside work in progress"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1507
msgid ""
"While you are in the middle of working on something complicated, you find an "
"unrelated but obvious and trivial bug.  You would like to fix it before "
"continuing.  You can use linkgit:git-stash[1] to save the current state of "
"your work, and after fixing the bug (or, optionally after doing so on a "
"different branch and then coming back), unstash the work-in-progress changes."
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1510
#, no-wrap
msgid "$ git stash save \"work in progress for foo feature\"\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1515
msgid ""
"This command will save your changes away to the `stash`, and reset your "
"working tree and the index to match the tip of your current branch.  Then "
"you can make your fix as usual."
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1519
#, no-wrap
msgid ""
"... edit and test ...\n"
"$ git commit -a -m \"blorpl: typofix\"\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1523
msgid ""
"After that, you can go back to what you were working on with `git stash "
"apply`:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1526
#, no-wrap
msgid "$ git stash apply\n"
msgstr ""

#. type: Title -
#: ../../user-manual.txt:1531
#, no-wrap
msgid "Ensuring good performance"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1535
msgid ""
"On large repositories, git depends on compression to keep the history "
"information from taking up too much space on disk or in memory."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1538
msgid ""
"This compression is not performed automatically.  Therefore you should "
"occasionally run linkgit:git-gc[1]:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1541 ../../user-manual.txt:4513
#, no-wrap
msgid "$ git gc\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1545
msgid ""
"to recompress the archive.  This can be very time-consuming, so you may "
"prefer to run `git gc` when you are not doing other work."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:1549
#, no-wrap
msgid "Ensuring reliability"
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:1553
#, no-wrap
msgid "Checking the repository for corruption"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1558
msgid ""
"The linkgit:git-fsck[1] command runs a number of self-consistency checks on "
"the repository, and reports on any problems.  This may take some time.  The "
"most common warning by far is about \"dangling\" objects:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1570
#, no-wrap
msgid ""
"$ git fsck\n"
"dangling commit 7281251ddd2a61e38657c827739c57015671a6b3\n"
"dangling commit 2706a059f258c6b245f298dc4ff2ccd30ec21a63\n"
"dangling commit 13472b7c4b80851a1bc551779171dcb03655e9b5\n"
"dangling blob 218761f9d90712d37a9c5e36f406f92202db07eb\n"
"dangling commit bf093535a34a4d35731aa2bd90fe6b176302f14f\n"
"dangling commit 8e4bec7f2ddaa268bef999853c25755452100f8e\n"
"dangling tree d50bb86186bf27b681d25af89d3b5b68382e4085\n"
"dangling tree b24c2473f1fd3d91352a624795be026d64c8841f\n"
"...\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1575
msgid ""
"Dangling objects are not a problem.  At worst they may take up a little "
"extra disk space.  They can sometimes provide a last-resort method for "
"recovering lost work--see <<dangling-objects>> for details."
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:1578
#, no-wrap
msgid "Recovering lost changes"
msgstr ""

#. type: Title ^
#: ../../user-manual.txt:1582
#, no-wrap
msgid "Reflogs"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1587
msgid ""
"Say you modify a branch with `linkgit:git-reset[1] --hard`, and then realize "
"that the branch was the only reference you had to that point in history."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1591
msgid ""
"Fortunately, git also keeps a log, called a \"reflog\", of all the previous "
"values of each branch.  So in this case you can still find the old history "
"using, for example,"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1594
#, no-wrap
msgid "$ git log master@{1}\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1599
msgid ""
"This lists the commits reachable from the previous version of the \"master\" "
"branch head.  This syntax can be used with any git command that accepts a "
"commit, not just with git log.  Some other examples:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1606
#, no-wrap
msgid ""
"$ git show master@{2}\t\t# See where the branch pointed 2,\n"
"$ git show master@{3}\t\t# 3, ... changes ago.\n"
"$ gitk master@{yesterday}\t# See where it pointed yesterday,\n"
"$ gitk master@{\"1 week ago\"}\t# ... or last week\n"
"$ git log --walk-reflogs master\t# show reflog entries for master\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1609
msgid "A separate reflog is kept for the HEAD, so"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1612
#, no-wrap
msgid "$ git show HEAD@{\"1 week ago\"}\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1617
msgid ""
"will show what HEAD pointed to one week ago, not what the current branch "
"pointed to one week ago.  This allows you to see the history of what you've "
"checked out."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1622
msgid ""
"The reflogs are kept by default for 30 days, after which they may be "
"pruned.  See linkgit:git-reflog[1] and linkgit:git-gc[1] to learn how to "
"control this pruning, and see the \"SPECIFYING REVISIONS\" section of "
"linkgit:git-rev-parse[1] for details."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1627
msgid ""
"Note that the reflog history is very different from normal git history.  "
"While normal history is shared by every repository that works on the same "
"project, the reflog history is not shared: it tells you only about how the "
"branches in your local repository have changed over time."
msgstr ""

#. type: Title ^
#: ../../user-manual.txt:1630
#, no-wrap
msgid "Examining dangling objects"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1638
msgid ""
"In some situations the reflog may not be able to save you.  For example, "
"suppose you delete a branch, then realize you need the history it "
"contained.  The reflog is also deleted; however, if you have not yet pruned "
"the repository, then you may still be able to find the lost commits in the "
"dangling objects that `git fsck` reports.  See <<dangling-objects>> for the "
"details."
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1645
#, no-wrap
msgid ""
"$ git fsck\n"
"dangling commit 7281251ddd2a61e38657c827739c57015671a6b3\n"
"dangling commit 2706a059f258c6b245f298dc4ff2ccd30ec21a63\n"
"dangling commit 13472b7c4b80851a1bc551779171dcb03655e9b5\n"
"...\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1649
msgid "You can examine one of those dangling commits with, for example,"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1652
#, no-wrap
msgid "$ gitk 7281251ddd --not --all\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1661
msgid ""
"which does what it sounds like: it says that you want to see the commit "
"history that is described by the dangling commit(s), but not the history "
"that is described by all your existing branches and tags.  Thus you get "
"exactly the history reachable from that commit that is lost.  (And notice "
"that it might not be just one commit: we only report the \"tip of the line\" "
"as being dangling, but there might be a whole deep and complex commit "
"history that was dropped.)"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1664
msgid ""
"If you decide you want the history back, you can always create a new "
"reference pointing to it, for example, a new branch:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1667
#, no-wrap
msgid "$ git branch recovered-branch 7281251ddd\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1671
msgid ""
"Other types of dangling objects (blobs and trees) are also possible, and "
"dangling objects can arise in other situations."
msgstr ""

#. type: Title =
#: ../../user-manual.txt:1675
#, no-wrap
msgid "Sharing development with others"
msgstr ""

#. type: Title -
#: ../../user-manual.txt:1679
#, no-wrap
msgid "Getting updates with git pull"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1684
msgid ""
"After you clone a repository and make a few changes of your own, you may "
"wish to check the original repository for updates and merge them into your "
"own work."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1689
msgid ""
"We have already seen <<Updating-a-repository-With-git-fetch,how to keep "
"remote tracking branches up to date>> with linkgit:git-fetch[1], and how to "
"merge two branches.  So you can merge in changes from the original "
"repository's master branch with:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1693
#, no-wrap
msgid ""
"$ git fetch\n"
"$ git merge origin/master\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1697
msgid ""
"However, the linkgit:git-pull[1] command provides a way to do this in one "
"step:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1700
#, no-wrap
msgid "$ git pull origin master\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1705
msgid ""
"In fact, if you have \"master\" checked out, then by default \"git pull\" "
"merges from the HEAD branch of the origin repository.  So often you can "
"accomplish the above with just a simple"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1708
#, no-wrap
msgid "$ git pull\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1715
msgid ""
"More generally, a branch that is created from a remote branch will pull by "
"default from that branch.  See the descriptions of the branch.<name>.remote "
"and branch.<name>.merge options in linkgit:git-config[1], and the discussion "
"of the `--track` option in linkgit:git-checkout[1], to learn how to control "
"these defaults."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1719
msgid ""
"In addition to saving you keystrokes, \"git pull\" also helps you by "
"producing a default commit message documenting the branch and repository "
"that you pulled from."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1723
msgid ""
"(But note that no such commit will be created in the case of a <<fast-"
"forwards,fast forward>>; instead, your branch will just be updated to point "
"to the latest commit from the upstream branch.)"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1727
msgid ""
"The `git pull` command can also be given \".\" as the \"remote\" repository, "
"in which case it just merges in a branch from the current repository; so the "
"commands"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1731
#, no-wrap
msgid ""
"$ git pull . branch\n"
"$ git merge branch\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1734
msgid "are roughly equivalent.  The former is actually very commonly used."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:1737
#, no-wrap
msgid "Submitting patches to a project"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1741
msgid ""
"If you just have a few changes, the simplest way to submit them may just be "
"to send them as patches in email:"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1743
msgid "First, use linkgit:git-format-patch[1]; for example:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1746
#, no-wrap
msgid "$ git format-patch origin\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1750
msgid ""
"will produce a numbered series of files in the current directory, one for "
"each patch in the current branch but not in origin/HEAD."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1756
msgid ""
"You can then import these into your mail client and send them by hand.  "
"However, if you have a lot to send at once, you may prefer to use the "
"linkgit:git-send-email[1] script to automate the process.  Consult the "
"mailing list for your project first to determine how they prefer such "
"patches be handled."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:1759
#, no-wrap
msgid "Importing patches to a project"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1765
msgid ""
"Git also provides a tool called linkgit:git-am[1] (am stands for \"apply "
"mailbox\"), for importing such an emailed series of patches.  Just save all "
"of the patch-containing messages, in order, into a single mailbox file, say "
"\"patches.mbox\", then run"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1768
#, no-wrap
msgid "$ git am -3 patches.mbox\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1775
msgid ""
"Git will apply each patch in order; if any conflicts are found, it will "
"stop, and you can fix the conflicts as described in \"<<resolving-a-merge,"
"Resolving a merge>>\".  (The \"-3\" option tells git to perform a merge; if "
"you would prefer it just to abort and leave your tree and index untouched, "
"you may omit that option.)"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1778
msgid ""
"Once the index is updated with the results of the conflict resolution, "
"instead of creating a new commit, just run"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1781
#, no-wrap
msgid "$ git am --resolved\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1785
msgid ""
"and git will create the commit for you and continue applying the remaining "
"patches from the mailbox."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1789
msgid ""
"The final result will be a series of commits, one for each patch in the "
"original mailbox, with authorship and commit log message each taken from the "
"message containing each patch."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:1792
#, no-wrap
msgid "Public git repositories"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1800
msgid ""
"Another way to submit changes to a project is to tell the maintainer of that "
"project to pull the changes from your repository using linkgit:git-pull[1].  "
"In the section \"<<getting-updates-With-git-pull, Getting updates with `git "
"pull`>>\" we described this as a way to get updates from the \"main\" "
"repository, but it works just as well in the other direction."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1805
msgid ""
"If you and the maintainer both have accounts on the same machine, then you "
"can just pull changes from each other's repositories directly; commands that "
"accept repository URLs as arguments will also accept a local directory name:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1809
#, no-wrap
msgid ""
"$ git clone /path/to/repository\n"
"$ git pull /path/to/other/repository\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1812
msgid "or an ssh URL:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1815
#, no-wrap
msgid "$ git clone ssh://yourhost/~you/repository\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1819
msgid ""
"For projects with few developers, or for synchronizing a few private "
"repositories, this may be all you need."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1824
msgid ""
"However, the more common way to do this is to maintain a separate public "
"repository (usually on a different host) for others to pull changes from.  "
"This is usually more convenient, and allows you to cleanly separate private "
"work in progress from publicly visible work."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1831
msgid ""
"You will continue to do your day-to-day work in your personal repository, "
"but periodically \"push\" changes from your personal repository into your "
"public repository, allowing other developers to pull from that repository.  "
"So the flow of changes, in a situation where there is one other developer "
"with a public repository, looks like this:"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1841
#, no-wrap
msgid ""
"                        you push\n"
"  your personal repo ------------------> your public repo\n"
"\t^                                     |\n"
"\t|                                     |\n"
"\t| you pull                            | they pull\n"
"\t|                                     |\n"
"\t|                                     |\n"
"        |               they push             V\n"
"  their public repo <------------------- their repo\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1843
msgid "We explain how to do this in the following sections."
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:1846
#, no-wrap
msgid "Setting up a public repository"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1851
msgid ""
"Assume your personal repository is in the directory ~/proj.  We first create "
"a new clone of the repository and tell `git daemon` that it is meant to be "
"public:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1855
#, no-wrap
msgid ""
"$ git clone --bare ~/proj proj.git\n"
"$ touch proj.git/git-daemon-export-ok\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1860
msgid ""
"The resulting directory proj.git contains a \"bare\" git repository--it is "
"just the contents of the \".git\" directory, without any files checked out "
"around it."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1864
msgid ""
"Next, copy proj.git to the server where you plan to host the public "
"repository.  You can use scp, rsync, or whatever is most convenient."
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:1867
#, no-wrap
msgid "Exporting a git repository via the git protocol"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1870
msgid "This is the preferred method."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1876
msgid ""
"If someone else administers the server, they should tell you what directory "
"to put the repository in, and what git:// URL it will appear at.  You can "
"then skip to the section \"<<pushing-changes-to-a-public-repository,Pushing "
"changes to a public repository>>\", below."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1882
msgid ""
"Otherwise, all you need to do is start linkgit:git-daemon[1]; it will listen "
"on port 9418.  By default, it will allow access to any directory that looks "
"like a git directory and contains the magic file git-daemon-export-ok.  "
"Passing some directory paths as `git daemon` arguments will further restrict "
"the exports to those paths."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1886
msgid ""
"You can also run `git daemon` as an inetd service; see the linkgit:git-daemon"
"[1] man page for details.  (See especially the examples section.)"
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:1889
#, no-wrap
msgid "Exporting a git repository via http"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1893
msgid ""
"The git protocol gives better performance and reliability, but on a host "
"with a web server set up, http exports may be simpler to set up."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1897
msgid ""
"All you need to do is place the newly created bare git repository in a "
"directory that is exported by the web server, and make some adjustments to "
"give web clients some extra information they need:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1903
#, no-wrap
msgid ""
"$ mv proj.git /home/you/public_html/proj.git\n"
"$ cd proj.git\n"
"$ git --bare update-server-info\n"
"$ mv hooks/post-update.sample hooks/post-update\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1907
msgid ""
"(For an explanation of the last two lines, see linkgit:git-update-server-info"
"[1] and linkgit:githooks[5].)"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1910
msgid ""
"Advertise the URL of proj.git.  Anybody else should then be able to clone or "
"pull from that URL, for example with a command line like:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1913
#, no-wrap
msgid "$ git clone http://yourserver.com/~you/proj.git\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1919
msgid ""
"(See also link:howto/setup-git-server-over-http.txt[setup-git-server-over-"
"http] for a slightly more sophisticated setup using WebDAV which also allows "
"pushing over http.)"
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:1922
#, no-wrap
msgid "Pushing changes to a public repository"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1929
msgid ""
"Note that the two techniques outlined above (exporting via <<exporting-via-"
"http,http>> or <<exporting-via-git,git>>) allow other maintainers to fetch "
"your latest changes, but they do not allow write access, which you will need "
"to update the public repository with the latest changes created in your "
"private repository."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1933
msgid ""
"The simplest way to do this is using linkgit:git-push[1] and ssh; to update "
"the remote branch named \"master\" with the latest state of your branch "
"named \"master\", run"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1936
#, no-wrap
msgid "$ git push ssh://yourserver.com/~you/proj.git master:master\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1939
msgid "or just"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1942
#, no-wrap
msgid "$ git push ssh://yourserver.com/~you/proj.git master\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1947
msgid ""
"As with `git fetch`, `git push` will complain if this does not result in a "
"<<fast-forwards,fast forward>>; see the following section for details on "
"handling this case."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1953
msgid ""
"Note that the target of a \"push\" is normally a <<def_bare_repository,"
"bare>> repository.  You can also push to a repository that has a checked-out "
"working tree, but the working tree will not be updated by the push.  This "
"may lead to unexpected results if the branch you push to is the currently "
"checked-out branch!"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1956
msgid ""
"As with `git fetch`, you may also set up configuration options to save "
"typing; so, for example, after"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1962
#, no-wrap
msgid ""
"$ cat >>.git/config <<EOF\n"
"[remote \"public-repo\"]\n"
"\turl = ssh://yourserver.com/~you/proj.git\n"
"EOF\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1965
msgid "you should be able to perform the above push with just"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1968
#, no-wrap
msgid "$ git push public-repo master\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1973
msgid ""
"See the explanations of the remote.<name>.url, branch.<name>.remote, and "
"remote.<name>.push options in linkgit:git-config[1] for details."
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:1976
#, no-wrap
msgid "What to do when a push fails"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1980
msgid ""
"If a push would not result in a <<fast-forwards,fast forward>> of the remote "
"branch, then it will fail with an error like:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:1986
#, no-wrap
msgid ""
"error: remote 'refs/heads/master' is not an ancestor of\n"
" local  'refs/heads/master'.\n"
" Maybe you are not up-to-date and need to pull first?\n"
"error: failed to push to 'ssh://yourserver.com/~you/proj.git'\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1989
msgid "This can happen, for example, if you:"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1991
msgid "use `git reset --hard` to remove already-published commits, or"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1993
msgid ""
"use `git commit --amend` to replace already-published commits (as in "
"<<fixing-a-mistake-by-rewriting-history>>), or"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1995
msgid ""
"use `git rebase` to rebase any already-published commits (as in <<using-git-"
"rebase>>)."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:1998
msgid ""
"You may force `git push` to perform the update anyway by preceding the "
"branch name with a plus sign:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2001
#, no-wrap
msgid "$ git push ssh://yourserver.com/~you/proj.git +master\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2007
msgid ""
"Normally whenever a branch head in a public repository is modified, it is "
"modified to point to a descendant of the commit that it pointed to before.  "
"By forcing a push in this situation, you break that convention.  (See "
"<<problems-With-rewriting-history>>.)"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2012
msgid ""
"Nevertheless, this is a common practice for people that need a simple way to "
"publish a work-in-progress patch series, and it is an acceptable compromise "
"as long as you warn other developers that this is how you intend to manage "
"the branch."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2019
msgid ""
"It's also possible for a push to fail in this way when other people have the "
"right to push to the same repository.  In that case, the correct solution is "
"to retry the push after first updating your work: either by a pull, or by a "
"fetch followed by a rebase; see the <<setting-up-a-shared-repository,next "
"section>> and linkgit:gitcvs-migration[7] for more."
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:2022
#, no-wrap
msgid "Setting up a shared repository"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2029
msgid ""
"Another way to collaborate is by using a model similar to that commonly used "
"in CVS, where several developers with special rights all push to and pull "
"from a single shared repository.  See linkgit:gitcvs-migration[7] for "
"instructions on how to set this up."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2035
msgid ""
"However, while there is nothing wrong with git's support for shared "
"repositories, this mode of operation is not generally recommended, simply "
"because the mode of collaboration that git supports--by exchanging patches "
"and pulling from public repositories--has so many advantages over the "
"central shared repository:"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2042
msgid ""
"Git's ability to quickly import and merge patches allows a single maintainer "
"to process incoming changes even at very high rates.  And when that becomes "
"too much, `git pull` provides an easy way for that maintainer to delegate "
"this job to other maintainers while still allowing optional review of "
"incoming changes."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2047
msgid ""
"Since every developer's repository has the same complete copy of the project "
"history, no repository is special, and it is trivial for another developer "
"to take over maintenance of a project, either by mutual agreement, or "
"because a maintainer becomes unresponsive or difficult to work with."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2050
msgid ""
"The lack of a central group of \"committers\" means there is less need for "
"formal decisions about who is \"in\" and who is \"out\"."
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:2053
#, no-wrap
msgid "Allowing web browsing of a repository"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2058
msgid ""
"The gitweb cgi script provides users an easy way to browse your project's "
"files and history without having to install git; see the file gitweb/INSTALL "
"in the git source tree for instructions on setting it up."
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:2065
#, no-wrap
msgid "Maintaining topic branches for a Linux subsystem maintainer"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2069
msgid ""
"This describes how Tony Luck uses git in his role as maintainer of the IA64 "
"architecture for the Linux kernel."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2071
msgid "He uses two public branches:"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2076
msgid ""
"A \"test\" tree into which patches are initially placed so that they can get "
"some exposure when integrated with other ongoing development.  This tree is "
"available to Andrew for pulling into -mm whenever he wants."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2080
msgid ""
"A \"release\" tree into which tested patches are moved for final sanity "
"checking, and as a vehicle to send them upstream to Linus (by sending him a "
"\"please pull\" request.)"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2083
msgid ""
"He also uses a set of temporary branches (\"topic branches\"), each "
"containing a logical grouping of patches."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2086
msgid ""
"To set this up, first create your work tree by cloning Linus's public tree:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2090
#, no-wrap
msgid ""
"$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git work\n"
"$ cd work\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2097
msgid ""
"Linus's tree will be stored in the remote branch named origin/master, and "
"can be updated using linkgit:git-fetch[1]; you can track other public trees "
"using linkgit:git-remote[1] to set up a \"remote\" and linkgit:git-fetch[1] "
"to keep them up-to-date; see <<repositories-and-branches>>."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2102
msgid ""
"Now create the branches in which you are going to work; these start out at "
"the current tip of origin/master branch, and should be set up (using the --"
"track option to linkgit:git-branch[1]) to merge changes in from Linus by "
"default."
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2106
#, no-wrap
msgid ""
"$ git branch --track test origin/master\n"
"$ git branch --track release origin/master\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2109
msgid "These can be easily kept up to date using linkgit:git-pull[1]."
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2113
#, no-wrap
msgid ""
"$ git checkout test && git pull\n"
"$ git checkout release && git pull\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2122
msgid ""
"Important note! If you have any local changes in these branches, then this "
"merge will create a commit object in the history (with no local changes git "
"will simply do a \"Fast forward\" merge).  Many people dislike the \"noise\" "
"that this creates in the Linux history, so you should avoid doing this "
"capriciously in the \"release\" branch, as these noisy commits will become "
"part of the permanent history when you ask Linus to pull from the release "
"branch."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2126
msgid ""
"A few configuration variables (see linkgit:git-config[1]) can make it easy "
"to push both branches to your public tree.  (See <<setting-up-a-public-"
"repository>>.)"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2134
#, no-wrap
msgid ""
"$ cat >> .git/config <<EOF\n"
"[remote \"mytree\"]\n"
"\turl =  master.kernel.org:/pub/scm/linux/kernel/git/aegl/linux-2.6.git\n"
"\tpush = release\n"
"\tpush = test\n"
"EOF\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2138
msgid ""
"Then you can push both the test and release trees using linkgit:git-push[1]:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2141
#, no-wrap
msgid "$ git push mytree\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2144
msgid "or push just one of the test and release branches using:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2147
#, no-wrap
msgid "$ git push mytree test\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2150 ../../user-manual.txt:2208
#: ../../user-manual.txt:3574
msgid "or"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2153
#, no-wrap
msgid "$ git push mytree release\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2159
msgid ""
"Now to apply some patches from the community.  Think of a short snappy name "
"for a branch to hold this patch (or related group of patches), and create a "
"new branch from the current tip of Linus's branch:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2162
#, no-wrap
msgid "$ git checkout -b speed-up-spinlocks origin\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2167
msgid ""
"Now you apply the patch(es), run some tests, and commit the change(s).  If "
"the patch is a multi-part series, then you should apply each as a separate "
"commit to this branch."
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2170
#, no-wrap
msgid "$ ... patch ... test  ... commit [ ... patch ... test ... commit ]*\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2174
msgid ""
"When you are happy with the state of this change, you can pull it into the "
"\"test\" branch in preparation to make it public:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2177
#, no-wrap
msgid "$ git checkout test && git pull . speed-up-spinlocks\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2181
msgid ""
"It is unlikely that you would have any conflicts here ... but you might if "
"you spent a while on this step and had also pulled new versions from "
"upstream."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2186
msgid ""
"Some time later when enough time has passed and testing done, you can pull "
"the same branch into the \"release\" tree ready to go upstream.  This is "
"where you see the value of keeping each patch (or patch series) in its own "
"branch.  It means that the patches can be moved into the \"release\" tree in "
"any order."
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2189
#, no-wrap
msgid "$ git checkout release && git pull . speed-up-spinlocks\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2195
msgid ""
"After a while, you will have a number of branches, and despite the well "
"chosen names you picked for each of them, you may forget what they are for, "
"or what status they are in.  To get a reminder of what changes are in a "
"specific branch, use:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2198
#, no-wrap
msgid "$ git log linux..branchname | git shortlog\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2202
msgid ""
"To see whether it has already been merged into the test or release branches, "
"use:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2205
#, no-wrap
msgid "$ git log test..branchname\n"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2211
#, no-wrap
msgid "$ git log release..branchname\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2215
msgid ""
"(If this branch has not yet been merged, you will see some log entries.  If "
"it has been merged, then there will be no output.)"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2220
msgid ""
"Once a patch completes the great cycle (moving from test to release, then "
"pulled by Linus, and finally coming back into your local \"origin/master\" "
"branch), the branch for this change is no longer needed.  You detect this "
"when the output from:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2223
#, no-wrap
msgid "$ git log origin..branchname\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2226
msgid "is empty.  At this point the branch can be deleted:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2229
#, no-wrap
msgid "$ git branch -d branchname\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2235
msgid ""
"Some changes are so trivial that it is not necessary to create a separate "
"branch and then merge into each of the test and release branches.  For these "
"changes, just apply directly to the \"release\" branch, and then merge that "
"into the \"test\" branch."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2238
msgid ""
"To create diffstat and shortlog summaries of changes to include in a "
"\"please pull\" request to Linus you can use:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2241
#, no-wrap
msgid "$ git diff --stat origin..release\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2244
msgid "and"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2247
#, no-wrap
msgid "$ git log -p origin..release | git shortlog\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2250
msgid "Here are some of the scripts that simplify all this even further."
msgstr ""

#. type: Title ====
#: ../../user-manual.txt:2252
#, no-wrap
msgid "update script"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2256
msgid ""
"# Update a branch in my GIT tree.  If the branch to be updated # is origin, "
"then pull from kernel.org.  Otherwise merge # origin/master branch into test|"
"release branch"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2275
#, no-wrap
msgid ""
"case \"$1\" in\n"
"test|release)\n"
"\tgit checkout $1 && git pull . origin\n"
"\t;;\n"
"origin)\n"
"\tbefore=$(git rev-parse refs/remotes/origin/master)\n"
"\tgit fetch origin\n"
"\tafter=$(git rev-parse refs/remotes/origin/master)\n"
"\tif [ $before != $after ]\n"
"\tthen\n"
"\t\tgit log $before..$after | git shortlog\n"
"\tfi\n"
"\t;;\n"
"*)\n"
"\techo \"Usage: $0 origin|test|release\" 1>&2\n"
"\texit 1\n"
"\t;;\n"
"esac\n"
msgstr ""

#. type: Title ====
#: ../../user-manual.txt:2278
#, no-wrap
msgid "merge script"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2280
msgid "# Merge a branch into either the test or release branch"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2282
msgid "pname=$0"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2288
#, no-wrap
msgid ""
"usage()\n"
"{\n"
"\techo \"Usage: $pname branch test|release\" 1>&2\n"
"\texit 1\n"
"}\n"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2293
#, no-wrap
msgid ""
"git show-ref -q --verify -- refs/heads/\"$1\" || {\n"
"\techo \"Can't see branch <$1>\" 1>&2\n"
"\tusage\n"
"}\n"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2307
#, no-wrap
msgid ""
"case \"$2\" in\n"
"test|release)\n"
"\tif [ $(git log $2..$1 | wc -c) -eq 0 ]\n"
"\tthen\n"
"\t\techo $1 already merged into $2 1>&2\n"
"\t\texit 1\n"
"\tfi\n"
"\tgit checkout $2 && git pull . $1\n"
"\t;;\n"
"*)\n"
"\tusage\n"
"\t;;\n"
"esac\n"
msgstr ""

#. type: Title ====
#: ../../user-manual.txt:2310
#, no-wrap
msgid "status script"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2312
msgid "# report on status of my ia64 GIT tree"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2316
msgid "gb=$(tput setab 2)  rb=$(tput setab 1)  restore=$(tput setab 9)"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2322
#, no-wrap
msgid ""
"if [ `git rev-list test..release | wc -c` -gt 0 ]\n"
"then\n"
"\techo $rb Warning: commits in release that are not in test $restore\n"
"\tgit log test..release\n"
"fi\n"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2329
#, no-wrap
msgid ""
"for branch in `git show-ref --heads | sed 's|^.*/||'`\n"
"do\n"
"\tif [ $branch = test -o $branch = release ]\n"
"\tthen\n"
"\t\tcontinue\n"
"\tfi\n"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2358
#, no-wrap
msgid ""
"\techo -n $gb ======= $branch ====== $restore \" \"\n"
"\tstatus=\n"
"\tfor ref in test release origin/master\n"
"\tdo\n"
"\t\tif [ `git rev-list $ref..$branch | wc -c` -gt 0 ]\n"
"\t\tthen\n"
"\t\t\tstatus=$status${ref:0:1}\n"
"\t\tfi\n"
"\tdone\n"
"\tcase $status in\n"
"\ttrl)\n"
"\t\techo $rb Need to pull into test $restore\n"
"\t\t;;\n"
"\trl)\n"
"\t\techo \"In test\"\n"
"\t\t;;\n"
"\tl)\n"
"\t\techo \"Waiting for linus\"\n"
"\t\t;;\n"
"\t\"\")\n"
"\t\techo $rb All done $restore\n"
"\t\t;;\n"
"\t*)\n"
"\t\techo $rb \"<$status>\" $restore\n"
"\t\t;;\n"
"\tesac\n"
"\tgit log origin/master..$branch | git shortlog\n"
"done\n"
msgstr ""

#. type: Title =
#: ../../user-manual.txt:2363
#, no-wrap
msgid "Rewriting history and maintaining patch series"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2368
msgid ""
"Normally commits are only added to a project, never taken away or replaced.  "
"Git is designed with this assumption, and violating it will cause git's "
"merge machinery (for example) to do the wrong thing."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2371
msgid ""
"However, there is a situation in which it can be useful to violate this "
"assumption."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:2374
#, no-wrap
msgid "Creating the perfect patch series"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2380
msgid ""
"Suppose you are a contributor to a large project, and you want to add a "
"complicated feature, and to present it to the other developers in a way that "
"makes it easy for them to read your changes, verify that they are correct, "
"and understand why you made each change."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2383
msgid ""
"If you present all of your changes as a single patch (or commit), they may "
"find that it is too much to digest all at once."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2386
msgid ""
"If you present them with the entire history of your work, complete with "
"mistakes, corrections, and dead ends, they may be overwhelmed."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2388
msgid "So the ideal is usually to produce a series of patches such that:"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2390
msgid "Each patch can be applied in order."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2393
msgid ""
"Each patch includes a single logical change, together with a message "
"explaining the change."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2397
msgid ""
"No patch introduces a regression: after applying any initial part of the "
"series, the resulting project still compiles and works, and has no bugs that "
"it didn't have before."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2400
msgid ""
"The complete series produces the same end result as your own (probably much "
"messier!) development process did."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2404
msgid ""
"We will introduce some tools that can help you do this, explain how to use "
"them, and then explain some of the problems that can arise because you are "
"rewriting history."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:2407
#, no-wrap
msgid "Keeping a patch series up to date using git rebase"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2411
msgid ""
"Suppose that you create a branch \"mywork\" on a remote-tracking branch "
"\"origin\", and create some commits on top of it:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2419
#, no-wrap
msgid ""
"$ git checkout -b mywork origin\n"
"$ vi file.txt\n"
"$ git commit\n"
"$ vi otherfile.txt\n"
"$ git commit\n"
"...\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2423
msgid ""
"You have performed no merges into mywork, so it is just a simple linear "
"sequence of patches on top of \"origin\":"
msgstr ""

#. type: delimited block .
#: ../../user-manual.txt:2428
#, no-wrap
msgid ""
" o--o--o <-- origin\n"
"        \\\n"
"         o--o--o <-- mywork\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2432
msgid ""
"Some more interesting work has been done in the upstream project, and "
"\"origin\" has advanced:"
msgstr ""

#. type: delimited block .
#: ../../user-manual.txt:2437
#, no-wrap
msgid ""
" o--o--O--o--o--o <-- origin\n"
"        \\\n"
"         a--b--c <-- mywork\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2441
msgid ""
"At this point, you could use \"pull\" to merge your changes back in; the "
"result would create a new merge commit, like this:"
msgstr ""

#. type: delimited block .
#: ../../user-manual.txt:2446
#, no-wrap
msgid ""
" o--o--O--o--o--o <-- origin\n"
"        \\        \\\n"
"         a--b--c--m <-- mywork\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2451
msgid ""
"However, if you prefer to keep the history in mywork a simple series of "
"commits without any merges, you may instead choose to use linkgit:git-rebase"
"[1]:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2455
#, no-wrap
msgid ""
"$ git checkout mywork\n"
"$ git rebase origin\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2461
msgid ""
"This will remove each of your commits from mywork, temporarily saving them "
"as patches (in a directory named \".git/rebase-apply\"), update mywork to "
"point at the latest version of origin, then apply each of the saved patches "
"to the new mywork.  The result will look like:"
msgstr ""

#. type: delimited block .
#: ../../user-manual.txt:2467
#, no-wrap
msgid ""
" o--o--O--o--o--o <-- origin\n"
"\t\t \\\n"
"\t\t  a'--b'--c' <-- mywork\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2473
msgid ""
"In the process, it may discover conflicts.  In that case it will stop and "
"allow you to fix the conflicts; after fixing conflicts, use `git add` to "
"update the index with those contents, and then, instead of running `git "
"commit`, just run"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2476
#, no-wrap
msgid "$ git rebase --continue\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2479
msgid "and git will continue applying the rest of the patches."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2482
msgid ""
"At any point you may use the `--abort` option to abort this process and "
"return mywork to the state it had before you started the rebase:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2485
#, no-wrap
msgid "$ git rebase --abort\n"
msgstr ""

#. type: Title -
#: ../../user-manual.txt:2489
#, no-wrap
msgid "Rewriting a single commit"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2493
msgid ""
"We saw in <<fixing-a-mistake-by-rewriting-history>> that you can replace the "
"most recent commit using"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2505
msgid ""
"You can also use a combination of this and linkgit:git-rebase[1] to replace "
"a commit further back in your history and recreate the intervening changes "
"on top of it.  First, tag the problematic commit with"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2508
#, no-wrap
msgid "$ git tag bad mywork~5\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2511
msgid "(Either gitk or `git log` may be useful for finding the commit.)"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2515
msgid ""
"Then check out that commit, edit it, and rebase the rest of the series on "
"top of it (note that we could check out the commit on a temporary branch, "
"but instead we're using a <<detached-head,detached head>>):"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2521
#, no-wrap
msgid ""
"$ git checkout bad\n"
"$ # make changes here and update the index\n"
"$ git commit --amend\n"
"$ git rebase --onto HEAD bad mywork\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2526
msgid ""
"When you're done, you'll be left with mywork checked out, with the top "
"patches on mywork reapplied on top of your modified commit.  You can then "
"clean up with"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2529
#, no-wrap
msgid "$ git tag -d bad\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2534
msgid ""
"Note that the immutable nature of git history means that you haven't really "
"\"modified\" existing commits; instead, you have replaced the old commits "
"with new commits having new object names."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:2537
#, no-wrap
msgid "Reordering or selecting from a patch series"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2543
msgid ""
"Given one existing commit, the linkgit:git-cherry-pick[1] command allows you "
"to apply the change introduced by that commit and create a new commit that "
"records it.  So, for example, if \"mywork\" points to a series of patches on "
"top of \"origin\", you might do something like:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2547
#, no-wrap
msgid ""
"$ git checkout -b mywork-new origin\n"
"$ gitk origin..mywork &\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2555
msgid ""
"and browse through the list of patches in the mywork branch using gitk, "
"applying them (possibly in a different order) to mywork-new using cherry-"
"pick, and possibly modifying them as you go using `git commit --amend`.  The "
"linkgit:git-gui[1] command may also help as it allows you to individually "
"select diff hunks for inclusion in the index (by right-clicking on the diff "
"hunk and choosing \"Stage Hunk for Commit\")."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2558
msgid ""
"Another technique is to use `git format-patch` to create a series of "
"patches, then reset the state to before the patches:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2562
#, no-wrap
msgid ""
"$ git format-patch origin\n"
"$ git reset --hard origin\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2566
msgid ""
"Then modify, reorder, or eliminate patches as preferred before applying them "
"again with linkgit:git-am[1]."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:2569
#, no-wrap
msgid "Other tools"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2574
msgid ""
"There are numerous other tools, such as StGIT, which exist for the purpose "
"of maintaining a patch series.  These are outside of the scope of this "
"manual."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:2577
#, no-wrap
msgid "Problems with rewriting history"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2582
msgid ""
"The primary problem with rewriting the history of a branch has to do with "
"merging.  Suppose somebody fetches your branch and merges it into their "
"branch, with a result something like this:"
msgstr ""

#. type: delimited block .
#: ../../user-manual.txt:2587
#, no-wrap
msgid ""
" o--o--O--o--o--o <-- origin\n"
"        \\        \\\n"
"         t--t--t--m <-- their branch:\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2590
msgid "Then suppose you modify the last three commits:"
msgstr ""

#. type: delimited block .
#: ../../user-manual.txt:2595
#, no-wrap
msgid ""
"\t o--o--o <-- new head of origin\n"
"\t/\n"
" o--o--O--o--o--o <-- old head of origin\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2599
msgid ""
"If we examined all this history together in one repository, it will look "
"like:"
msgstr ""

#. type: delimited block .
#: ../../user-manual.txt:2606
#, no-wrap
msgid ""
"\t o--o--o <-- new head of origin\n"
"\t/\n"
" o--o--O--o--o--o <-- old head of origin\n"
"        \\        \\\n"
"         t--t--t--m <-- their branch:\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2615
msgid ""
"Git has no way of knowing that the new head is an updated version of the old "
"head; it treats this situation exactly the same as it would if two "
"developers had independently done the work on the old and new heads in "
"parallel.  At this point, if someone attempts to merge the new head in to "
"their branch, git will attempt to merge together the two (old and new) lines "
"of development, instead of trying to replace the old by the new.  The "
"results are likely to be unexpected."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2620
msgid ""
"You may still choose to publish branches whose history is rewritten, and it "
"may be useful for others to be able to fetch those branches in order to "
"examine or test them, but they should not attempt to pull such branches into "
"their own work."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2623
msgid ""
"For true distributed development that supports proper merging, published "
"branches should never be rewritten."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:2626
#, no-wrap
msgid "Why bisecting merge commits can be harder than bisecting linear history"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2632
msgid ""
"The linkgit:git-bisect[1] command correctly handles history that includes "
"merge commits.  However, when the commit that it finds is a merge commit, "
"the user may need to work harder than usual to figure out why that commit "
"introduced a problem."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2634
msgid "Imagine this history:"
msgstr ""

#. type: delimited block .
#: ../../user-manual.txt:2639
#, no-wrap
msgid ""
"      ---Z---o---X---...---o---A---C---D\n"
"          \\                       /\n"
"           o---o---Y---...---o---B\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2647
msgid ""
"Suppose that on the upper line of development, the meaning of one of the "
"functions that exists at Z is changed at commit X.  The commits from Z "
"leading to A change both the function's implementation and all calling sites "
"that exist at Z, as well as new calling sites they add, to be consistent.  "
"There is no bug at A."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2653
msgid ""
"Suppose that in the meantime on the lower line of development somebody adds "
"a new calling site for that function at commit Y.  The commits from Z "
"leading to B all assume the old semantics of that function and the callers "
"and the callee are consistent with each other.  There is no bug at B, either."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2656
msgid ""
"Suppose further that the two development lines merge cleanly at C, so no "
"conflict resolution is required."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2663
msgid ""
"Nevertheless, the code at C is broken, because the callers added on the "
"lower line of development have not been converted to the new semantics "
"introduced on the upper line of development.  So if all you know is that D "
"is bad, that Z is good, and that linkgit:git-bisect[1] identifies C as the "
"culprit, how will you figure out that the problem is due to this change in "
"semantics?"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2673
msgid ""
"When the result of a `git bisect` is a non-merge commit, you should normally "
"be able to discover the problem by examining just that commit.  Developers "
"can make this easy by breaking their changes into small self-contained "
"commits.  That won't help in the case above, however, because the problem "
"isn't obvious from examination of any single commit; instead, a global view "
"of the development is required.  To make matters worse, the change in "
"semantics in the problematic function may be just one small part of the "
"changes in the upper line of development."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2677
msgid ""
"On the other hand, if instead of merging at C you had rebased the history "
"between Z to B on top of A, you would have gotten this linear history:"
msgstr ""

#. type: delimited block .
#: ../../user-manual.txt:2680
#, no-wrap
msgid "    ---Z---o---X--...---o---A---o---o---Y*--...---o---B*--D*\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2684
msgid ""
"Bisecting between Z and D* would hit a single culprit commit Y*, and "
"understanding why Y* was broken would probably be easier."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2689
msgid ""
"Partly for this reason, many experienced git users, even when working on an "
"otherwise merge-heavy project, keep the history linear by rebasing against "
"the latest upstream version before publishing."
msgstr ""

#. type: Title =
#: ../../user-manual.txt:2692
#, no-wrap
msgid "Advanced branch management"
msgstr ""

#. type: Title -
#: ../../user-manual.txt:2696
#, no-wrap
msgid "Fetching individual branches"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2701
msgid ""
"Instead of using linkgit:git-remote[1], you can also choose just to update "
"one branch at a time, and to store it locally under an arbitrary name:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2704
#, no-wrap
msgid "$ git fetch origin todo:my-todo-work\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2710
msgid ""
"The first argument, \"origin\", just tells git to fetch from the repository "
"you originally cloned from.  The second argument tells git to fetch the "
"branch named \"todo\" from the remote repository, and to store it locally "
"under the name refs/heads/my-todo-work."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2712
msgid "You can also fetch branches from other repositories; so"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2715
#, no-wrap
msgid "$ git fetch git://example.com/proj.git master:example-master\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2722
msgid ""
"will create a new branch named \"example-master\" and store in it the branch "
"named \"master\" from the repository at the given URL.  If you already have "
"a branch named example-master, it will attempt to <<fast-forwards,fast-"
"forward>> to the commit given by example.com's master branch.  In more "
"detail:"
msgstr ""

#. type: Title -
#: ../../user-manual.txt:2725
#, no-wrap
msgid "git fetch and fast-forwards"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2732
msgid ""
"In the previous example, when updating an existing branch, \"git fetch\" "
"checks to make sure that the most recent commit on the remote branch is a "
"descendant of the most recent commit on your copy of the branch before "
"updating your copy of the branch to point at the new commit.  Git calls this "
"process a <<fast-forwards,fast forward>>."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2734
msgid "A fast forward looks something like this:"
msgstr ""

#. type: delimited block .
#: ../../user-manual.txt:2739
#, no-wrap
msgid ""
" o--o--o--o <-- old head of the branch\n"
"           \\\n"
"            o--o--o <-- new head of the branch\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2746
msgid ""
"In some cases it is possible that the new head will *not* actually be a "
"descendant of the old head.  For example, the developer may have realized "
"she made a serious mistake, and decided to backtrack, resulting in a "
"situation like:"
msgstr ""

#. type: delimited block .
#: ../../user-manual.txt:2751
#, no-wrap
msgid ""
" o--o--o--o--a--b <-- old head of the branch\n"
"           \\\n"
"            o--o--o <-- new head of the branch\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2754
msgid "In this case, \"git fetch\" will fail, and print out a warning."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2760
msgid ""
"In that case, you can still force git to update to the new head, as "
"described in the following section.  However, note that in the situation "
"above this may mean losing the commits labeled \"a\" and \"b\", unless "
"you've already created a reference of your own pointing to them."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:2763
#, no-wrap
msgid "Forcing git fetch to do non-fast-forward updates"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2767
msgid ""
"If git fetch fails because the new head of a branch is not a descendant of "
"the old head, you may force the update with:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2770
#, no-wrap
msgid "$ git fetch git://example.com/proj.git +master:refs/remotes/example/master\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2774
msgid ""
"Note the addition of the \"+\" sign.  Alternatively, you can use the \"-f\" "
"flag to force updates of all the fetched branches, as in:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2777
#, no-wrap
msgid "$ git fetch -f origin\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2781
msgid ""
"Be aware that commits that the old version of example/master pointed at may "
"be lost, as we saw in the previous section."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:2784
#, no-wrap
msgid "Configuring remote branches"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2790
msgid ""
"We saw above that \"origin\" is just a shortcut to refer to the repository "
"that you originally cloned from.  This information is stored in git "
"configuration variables, which you can see using linkgit:git-config[1]:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2800
#, no-wrap
msgid ""
"$ git config -l\n"
"core.repositoryformatversion=0\n"
"core.filemode=true\n"
"core.logallrefupdates=true\n"
"remote.origin.url=git://git.kernel.org/pub/scm/git/git.git\n"
"remote.origin.fetch=+refs/heads/*:refs/remotes/origin/*\n"
"branch.master.remote=origin\n"
"branch.master.merge=refs/heads/master\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2805
msgid ""
"If there are other repositories that you also use frequently, you can create "
"similar configuration options to save typing; for example, after"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2808
#, no-wrap
msgid "$ git config remote.example.url git://example.com/proj.git\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2811
msgid "then the following two commands will do the same thing:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2815
#, no-wrap
msgid ""
"$ git fetch git://example.com/proj.git master:refs/remotes/example/master\n"
"$ git fetch example master:refs/remotes/example/master\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2818
msgid "Even better, if you add one more option:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2821
#, no-wrap
msgid "$ git config remote.example.fetch master:refs/remotes/example/master\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2824
msgid "then the following commands will all do the same thing:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2829
#, no-wrap
msgid ""
"$ git fetch git://example.com/proj.git master:refs/remotes/example/master\n"
"$ git fetch example master:refs/remotes/example/master\n"
"$ git fetch example\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2832
msgid "You can also add a \"+\" to force the update each time:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2835
#, no-wrap
msgid "$ git config remote.example.fetch +master:ref/remotes/example/master\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2839
msgid ""
"Don't do this unless you're sure you won't mind \"git fetch\" possibly "
"throwing away commits on 'example/master'."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2843
msgid ""
"Also note that all of the above configuration can be performed by directly "
"editing the file .git/config instead of using linkgit:git-config[1]."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2846
msgid ""
"See linkgit:git-config[1] for more details on the configuration options "
"mentioned above."
msgstr ""

#. type: Title =
#: ../../user-manual.txt:2850
#, no-wrap
msgid "Git concepts"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2855
msgid ""
"Git is built on a small number of simple but powerful ideas.  While it is "
"possible to get things done without understanding them, you will find git "
"much more intuitive if you do."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2858
msgid ""
"We start with the most important, the <<def_object_database,object "
"database>> and the <<def_index,index>>."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:2861
#, no-wrap
msgid "The Object Database"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2872
msgid ""
"We already saw in <<understanding-commits>> that all commits are stored "
"under a 40-digit \"object name\".  In fact, all the information needed to "
"represent the history of a project is stored in objects with such names.  In "
"each case the name is calculated by taking the SHA-1 hash of the contents of "
"the object.  The SHA-1 hash is a cryptographic hash function.  What that "
"means to us is that it is impossible to find two different objects with the "
"same name.  This has a number of advantages; among others:"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2875
msgid ""
"Git can quickly determine whether two objects are identical or not, just by "
"comparing names."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2878
msgid ""
"Since object names are computed the same way in every repository, the same "
"content stored in two repositories will always be stored under the same name."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2880
msgid ""
"Git can detect errors when it reads an object, by checking that the object's "
"name is still the SHA-1 hash of its contents."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2883
msgid ""
"(See <<object-details>> for the details of the object formatting and SHA-1 "
"calculation.)"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2886
msgid ""
"There are four different types of objects: \"blob\", \"tree\", \"commit\", "
"and \"tag\"."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2888
msgid "A <<def_blob_object,\"blob\" object>> is used to store file data."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2891
msgid ""
"A <<def_tree_object,\"tree\" object>> ties one or more \"blob\" objects into "
"a directory structure. In addition, a tree object can refer to other tree "
"objects, thus creating a directory hierarchy."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2897
msgid ""
"A <<def_commit_object,\"commit\" object>> ties such directory hierarchies "
"together into a <<def_DAG,directed acyclic graph>> of revisions--each commit "
"contains the object name of exactly one tree designating the directory "
"hierarchy at the time of the commit. In addition, a commit refers to \"parent"
"\" commit objects that describe the history of how we arrived at that "
"directory hierarchy."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2901
msgid ""
"A <<def_tag_object,\"tag\" object>> symbolically identifies and can be used "
"to sign other objects. It contains the object name and type of another "
"object, a symbolic name (of course!) and, optionally, a signature."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2903
msgid "The object types in some more detail:"
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:2906
#, no-wrap
msgid "Commit Object"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2912
msgid ""
"The \"commit\" object links a physical state of a tree with a description of "
"how we got there and why.  Use the --pretty=raw option to linkgit:git-show"
"[1] or linkgit:git-log[1] to examine your favorite commit:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2920
#, no-wrap
msgid ""
"$ git show -s --pretty=raw 2be7fcb476\n"
"commit 2be7fcb4764f2dbcee52635b91fedb1b3dcf7ab4\n"
"tree fb3a8bdd0ceddd019615af4d57a53f43d8cee2bf\n"
"parent 257a84d9d02e90447b149af58b271c19405edb6a\n"
"author Dave Watson <dwatson@mimvista.com> 1187576872 -0400\n"
"committer Junio C Hamano <gitster@pobox.com> 1187591163 -0700\n"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2922
#, no-wrap
msgid "    Fix misspelling of 'suppress' in docs\n"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2924
#, no-wrap
msgid "    Signed-off-by: Junio C Hamano <gitster@pobox.com>\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2927
msgid "As you can see, a commit is defined by:"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2930
msgid ""
"a tree: The SHA-1 name of a tree object (as defined below), representing the "
"contents of a directory at a certain point in time."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2937
msgid ""
"parent(s): The SHA-1 name of some number of commits which represent the "
"immediately previous step(s) in the history of the project.  The example "
"above has one parent; merge commits may have more than one.  A commit with "
"no parents is called a \"root\" commit, and represents the initial revision "
"of a project.  Each project must have at least one root.  A project can also "
"have multiple roots, though that isn't common (or necessarily a good idea)."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2939
msgid ""
"an author: The name of the person responsible for this change, together with "
"its date."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2943
msgid ""
"a committer: The name of the person who actually created the commit, with "
"the date it was done.  This may be different from the author, for example, "
"if the author was someone who wrote a patch and emailed it to the person who "
"used it to create the commit."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2944
msgid "a comment describing this commit."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2952
msgid ""
"Note that a commit does not itself contain any information about what "
"actually changed; all changes are calculated by comparing the contents of "
"the tree referred to by this commit with the trees associated with its "
"parents.  In particular, git does not attempt to record file renames "
"explicitly, though it can identify cases where the existence of the same "
"file data at changing paths suggests a rename.  (See, for example, the -M "
"option to linkgit:git-diff[1])."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2956
msgid ""
"A commit is usually created by linkgit:git-commit[1], which creates a commit "
"whose parent is normally the current HEAD, and whose tree is taken from the "
"content currently stored in the index."
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:2959
#, no-wrap
msgid "Tree Object"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2964
msgid ""
"The ever-versatile linkgit:git-show[1] command can also be used to examine "
"tree objects, but linkgit:git-ls-tree[1] will give you more details:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:2976
#, no-wrap
msgid ""
"$ git ls-tree fb3a8bdd0ce\n"
"100644 blob 63c918c667fa005ff12ad89437f2fdc80926e21c    .gitignore\n"
"100644 blob 5529b198e8d14decbe4ad99db3f7fb632de0439d    .mailmap\n"
"100644 blob 6ff87c4664981e4397625791c8ea3bbb5f2279a3    COPYING\n"
"040000 tree 2fb783e477100ce076f6bf57e4a6f026013dc745    Documentation\n"
"100755 blob 3c0032cec592a765692234f1cba47dfdcc3a9200    GIT-VERSION-GEN\n"
"100644 blob 289b046a443c0647624607d471289b2c7dcd470b    INSTALL\n"
"100644 blob 4eb463797adc693dc168b926b6932ff53f17d0b1    Makefile\n"
"100644 blob 548142c327a6790ff8821d67c2ee1eff7a656b52    README\n"
"...\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2981
msgid ""
"As you can see, a tree object contains a list of entries, each with a mode, "
"object type, SHA-1 name, and name, sorted by name.  It represents the "
"contents of a single directory tree."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2990
msgid ""
"The object type may be a blob, representing the contents of a file, or "
"another tree, representing the contents of a subdirectory.  Since trees and "
"blobs, like all other objects, are named by the SHA-1 hash of their "
"contents, two trees have the same SHA-1 name if and only if their contents "
"(including, recursively, the contents of all subdirectories)  are "
"identical.  This allows git to quickly determine the differences between two "
"related tree objects, since it can ignore any entries with identical object "
"names."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2993
msgid ""
"(Note: in the presence of submodules, trees may also have commits as "
"entries.  See <<submodules>> for documentation.)"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:2996
msgid ""
"Note that the files all have mode 644 or 755: git actually only pays "
"attention to the executable bit."
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:2999
#, no-wrap
msgid "Blob Object"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3003
msgid ""
"You can use linkgit:git-show[1] to examine the contents of a blob; take, for "
"example, the blob in the entry for \"COPYING\" from the tree above:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3006
#, no-wrap
msgid "$ git show 6ff87c4664\n"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3011
#, no-wrap
msgid ""
" Note that the only valid version of the GPL as far as this project\n"
" is concerned is _this_ particular version of the license (ie v2, not\n"
" v2.2 or v3.x or whatever), unless explicitly otherwise stated.\n"
"...\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3015
msgid ""
"A \"blob\" object is nothing but a binary blob of data.  It doesn't refer to "
"anything else or have attributes of any kind."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3021
msgid ""
"Since the blob is entirely defined by its data, if two files in a directory "
"tree (or in multiple different versions of the repository)  have the same "
"contents, they will share the same blob object. The object is totally "
"independent of its location in the directory tree, and renaming a file does "
"not change the object that file is associated with."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3026
msgid ""
"Note that any tree or blob object can be examined using linkgit:git-show[1] "
"with the <revision>:<path> syntax.  This can sometimes be useful for "
"browsing the contents of a tree that is not currently checked out."
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:3029
#, no-wrap
msgid "Trust"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3036
msgid ""
"If you receive the SHA-1 name of a blob from one source, and its contents "
"from another (possibly untrusted) source, you can still trust that those "
"contents are correct as long as the SHA-1 name agrees.  This is because the "
"SHA-1 is designed so that it is infeasible to find different contents that "
"produce the same hash."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3043
msgid ""
"Similarly, you need only trust the SHA-1 name of a top-level tree object to "
"trust the contents of the entire directory that it refers to, and if you "
"receive the SHA-1 name of a commit from a trusted source, then you can "
"easily verify the entire history of commits reachable through parents of "
"that commit, and all of those contents of the trees referred to by those "
"commits."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3049
msgid ""
"So to introduce some real trust in the system, the only thing you need to do "
"is to digitally sign just 'one' special note, which includes the name of a "
"top-level commit.  Your digital signature shows others that you trust that "
"commit, and the immutability of the history of commits tells others that "
"they can trust the whole history."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3054
msgid ""
"In other words, you can easily validate a whole archive by just sending out "
"a single email that tells the people the name (SHA-1 hash)  of the top "
"commit, and digitally sign that email using something like GPG/PGP."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3056
msgid "To assist in this, git also provides the tag object..."
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:3059
#, no-wrap
msgid "Tag Object"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3064
msgid ""
"A tag object contains an object, object type, tag name, the name of the "
"person (\"tagger\") who created the tag, and a message, which may contain a "
"signature, as can be seen using linkgit:git-cat-file[1]:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3071
#, no-wrap
msgid ""
"$ git cat-file tag v1.5.0\n"
"object 437b1b20df4b356c9342dac8d38849f24ef44f27\n"
"type commit\n"
"tag v1.5.0\n"
"tagger Junio C Hamano <junkio@cox.net> 1171411200 +0000\n"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3075
#, no-wrap
msgid ""
"GIT 1.5.0\n"
"-----BEGIN PGP SIGNATURE-----\n"
"Version: GnuPG v1.4.6 (GNU/Linux)\n"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3080
#, no-wrap
msgid ""
"iD8DBQBF0lGqwMbZpPMRm5oRAuRiAJ9ohBLd7s2kqjkKlq1qqC57SbnmzQCdG4ui\n"
"nLE/L9aUXdWeTFPron96DLA=\n"
"=2E+0\n"
"-----END PGP SIGNATURE-----\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3086
msgid ""
"See the linkgit:git-tag[1] command to learn how to create and verify tag "
"objects.  (Note that linkgit:git-tag[1] can also be used to create "
"\"lightweight tags\", which are not tag objects at all, but just simple "
"references whose names begin with \"refs/tags/\")."
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:3089
#, no-wrap
msgid "How git stores objects efficiently: pack files"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3093
msgid ""
"Newly created objects are initially created in a file named after the "
"object's SHA-1 hash (stored in .git/objects)."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3096
msgid ""
"Unfortunately this system becomes inefficient once a project has a lot of "
"objects.  Try this on an old project:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3100
#, no-wrap
msgid ""
"$ git count-objects\n"
"6930 objects, 47620 kilobytes\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3105
msgid ""
"The first number is the number of objects which are kept in individual "
"files.  The second is the amount of space taken up by those \"loose\" "
"objects."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3110
msgid ""
"You can save space and make git faster by moving these loose objects in to a "
"\"pack file\", which stores a group of objects in an efficient compressed "
"format; the details of how pack files are formatted can be found in link:"
"technical/pack-format.txt[technical/pack-format.txt]."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3112
msgid "To put the loose objects into a pack, just run git repack:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3123
#, no-wrap
msgid ""
"$ git repack\n"
"Generating pack...\n"
"Done counting 6020 objects.\n"
"Deltifying 6020 objects.\n"
" 100% (6020/6020) done\n"
"Writing 6020 objects.\n"
" 100% (6020/6020) done\n"
"Total 6020, written 6020 (delta 4070), reused 0 (delta 0)\n"
"Pack pack-3e54ad29d5b2e05838c75df582c65257b8d08e1c created.\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3126
msgid "You can then run"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3129 ../../user-manual.txt:3220
#, no-wrap
msgid "$ git prune\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3135
msgid ""
"to remove any of the \"loose\" objects that are now contained in the pack.  "
"This will also remove any unreferenced objects (which may be created when, "
"for example, you use \"git reset\" to remove a commit).  You can verify that "
"the loose objects are gone by looking at the .git/objects directory or by "
"running"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3139
#, no-wrap
msgid ""
"$ git count-objects\n"
"0 objects, 0 kilobytes\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3143
msgid ""
"Although the object files are gone, any commands that refer to those objects "
"will work exactly as they did before."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3146
msgid ""
"The linkgit:git-gc[1] command performs packing, pruning, and more for you, "
"so is normally the only high-level command you need."
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:3149
#, no-wrap
msgid "Dangling objects"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3153
msgid ""
"The linkgit:git-fsck[1] command will sometimes complain about dangling "
"objects.  They are not a problem."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3159
msgid ""
"The most common cause of dangling objects is that you've rebased a branch, "
"or you have pulled from somebody else who rebased a branch--see <<cleaning-"
"up-history>>.  In that case, the old head of the original branch still "
"exists, as does everything it pointed to. The branch pointer itself just "
"doesn't, since you replaced it with another one."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3167
msgid ""
"There are also other situations that cause dangling objects. For example, a "
"\"dangling blob\" may arise because you did a \"git add\" of a file, but "
"then, before you actually committed it and made it part of the bigger "
"picture, you changed something else in that file and committed that "
"*updated* thing--the old state that you added originally ends up not being "
"pointed to by any commit or tree, so it's now a dangling blob object."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3175
msgid ""
"Similarly, when the \"recursive\" merge strategy runs, and finds that there "
"are criss-cross merges and thus more than one merge base (which is fairly "
"unusual, but it does happen), it will generate one temporary midway tree (or "
"possibly even more, if you had lots of criss-crossing merges and more than "
"two merge bases) as a temporary internal merge base, and again, those are "
"real objects, but the end result will not end up pointing to them, so they "
"end up \"dangling\" in your repository."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3181
msgid ""
"Generally, dangling objects aren't anything to worry about. They can even be "
"very useful: if you screw something up, the dangling objects can be how you "
"recover your old tree (say, you did a rebase, and realized that you really "
"didn't want to--you can look at what dangling objects you have, and decide "
"to reset your head to some old dangling state)."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3183
msgid "For commits, you can just use:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3186
#, no-wrap
msgid "$ gitk <dangling-commit-sha-goes-here> --not --all\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3191
msgid ""
"This asks for all the history reachable from the given commit but not from "
"any branch, tag, or other reference.  If you decide it's something you want, "
"you can always create a new reference to it, e.g.,"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3194
#, no-wrap
msgid "$ git branch recovered-branch <dangling-commit-sha-goes-here>\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3198
msgid ""
"For blobs and trees, you can't do the same, but you can still examine them.  "
"You can just do"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3201
#, no-wrap
msgid "$ git show <dangling-blob/tree-sha-goes-here>\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3206
msgid ""
"to show what the contents of the blob were (or, for a tree, basically what "
"the \"ls\" for that directory was), and that may give you some idea of what "
"the operation was that left that dangling object."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3214
msgid ""
"Usually, dangling blobs and trees aren't very interesting. They're almost "
"always the result of either being a half-way mergebase (the blob will often "
"even have the conflict markers from a merge in it, if you have had "
"conflicting merges that you fixed up by hand), or simply because you "
"interrupted a \"git fetch\" with ^C or something like that, leaving _some_ "
"of the new objects in the object database, but just dangling and useless."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3217
msgid ""
"Anyway, once you are sure that you're not interested in any dangling state, "
"you can just prune all unreachable objects:"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3225
msgid ""
"and they'll be gone. But you should only run \"git prune\" on a quiescent "
"repository--it's kind of like doing a filesystem fsck recovery: you don't "
"want to do that while the filesystem is mounted."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3233
msgid ""
"(The same is true of \"git fsck\" itself, btw, but since `git fsck` never "
"actually *changes* the repository, it just reports on what it found, `git "
"fsck` itself is never 'dangerous' to run.  Running it while somebody is "
"actually changing the repository can cause confusing and scary messages, but "
"it won't actually do anything bad. In contrast, running \"git prune\" while "
"somebody is actively changing the repository is a *BAD* idea)."
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:3236
#, no-wrap
msgid "Recovering from repository corruption"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3241
msgid ""
"By design, git treats data trusted to it with caution.  However, even in the "
"absence of bugs in git itself, it is still possible that hardware or "
"operating system errors could corrupt data."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3245
msgid ""
"The first defense against such problems is backups.  You can back up a git "
"directory using clone, or just using cp, tar, or any other backup mechanism."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3249
msgid ""
"As a last resort, you can search for the corrupted objects and attempt to "
"replace them by hand.  Back up your repository before attempting this in "
"case you corrupt things even more in the process."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3253
msgid ""
"We'll assume that the problem is a single missing or corrupted blob, which "
"is sometimes a solvable problem.  (Recovering missing trees and especially "
"commits is *much* harder)."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3256
msgid ""
"Before starting, verify that there is corruption, and figure out where it is "
"with linkgit:git-fsck[1]; this may be time-consuming."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3258
msgid "Assume the output looks like this:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3264
#, no-wrap
msgid ""
"$ git fsck --full\n"
"broken link from    tree 2d9263c6d23595e7cb2a21e5ebbb53655278dff8\n"
"              to    blob 4b9458b3786228369c63936db65827de3cc06200\n"
"missing blob 4b9458b3786228369c63936db65827de3cc06200\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3268
msgid ""
"(Typically there will be some \"dangling object\" messages too, but they "
"aren't interesting.)"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3272
msgid ""
"Now you know that blob 4b9458b3 is missing, and that the tree 2d9263c6 "
"points to it.  If you could find just one copy of that missing blob object, "
"possibly in some other repository, you could move it into"
msgstr ""

#. type: Block title
#: ../../user-manual.txt:3272
#, no-wrap
msgid "git/objects/4b/9458b3... and be done.  Suppose you can't.  You can"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3275
msgid ""
"still examine the tree that pointed to it with linkgit:git-ls-tree[1], which "
"might output something like:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3284
#, no-wrap
msgid ""
"$ git ls-tree 2d9263c6d23595e7cb2a21e5ebbb53655278dff8\n"
"100644 blob 8d14531846b95bfa3564b58ccfb7913a034323b8\t.gitignore\n"
"100644 blob ebf9bf84da0aab5ed944264a5db2a65fe3a3e883\t.mailmap\n"
"100644 blob ca442d313d86dc67e0a2e5d584b465bd382cbf5c\tCOPYING\n"
"...\n"
"100644 blob 4b9458b3786228369c63936db65827de3cc06200\tmyfile\n"
"...\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3292
msgid ""
"So now you know that the missing blob was the data for a file named \"myfile"
"\".  And chances are you can also identify the directory--let's say it's in "
"\"somedirectory\".  If you're lucky the missing copy might be the same as "
"the copy you have checked out in your working tree at \"somedirectory/myfile"
"\"; you can test whether that's right with linkgit:git-hash-object[1]:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3295
#, no-wrap
msgid "$ git hash-object -w somedirectory/myfile\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3301
msgid ""
"which will create and store a blob object with the contents of somedirectory/"
"myfile, and output the SHA-1 of that object.  if you're extremely lucky it "
"might be 4b9458b3786228369c63936db65827de3cc06200, in which case you've "
"guessed right, and the corruption is fixed!"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3304
msgid ""
"Otherwise, you need more information.  How do you tell which version of the "
"file has been lost?"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3306
msgid "The easiest way to do this is with:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3309
#, no-wrap
msgid "$ git log --raw --all --full-history -- somedirectory/myfile\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3312
msgid "Because you're asking for raw output, you'll now get something like"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3319
#, no-wrap
msgid ""
"commit abc\n"
"Author:\n"
"Date:\n"
"...\n"
":100644 100644 4b9458b... newsha... M somedirectory/myfile\n"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3324
#, no-wrap
msgid ""
"commit xyz\n"
"Author:\n"
"Date:\n"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3327
#, no-wrap
msgid ""
"...\n"
":100644 100644 oldsha... 4b9458b... M somedirectory/myfile\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3333
msgid ""
"This tells you that the immediately preceding version of the file was "
"\"newsha\", and that the immediately following version was \"oldsha\".  You "
"also know the commit messages that went with the change from oldsha to "
"4b9458b and with the change from 4b9458b to newsha."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3336
msgid ""
"If you've been committing small enough changes, you may now have a good shot "
"at reconstructing the contents of the in-between state 4b9458b."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3338
msgid "If you can do that, you can now recreate the missing object with"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3341
#, no-wrap
msgid "$ git hash-object -w <recreated-file>\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3344
msgid "and your repository is good again!"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3346
msgid "(Btw, you could have ignored the fsck, and started with doing a"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3349
#, no-wrap
msgid "$ git log --raw --all\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3354
msgid ""
"and just looked for the sha of the missing object (4b9458b..) in that whole "
"thing. It's up to you - git does *have* a lot of information, it is just "
"missing one particular blob version."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:3357
#, no-wrap
msgid "The index"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3362
msgid ""
"The index is a binary file (generally kept in .git/index) containing a "
"sorted list of path names, each with permissions and the SHA-1 of a blob "
"object; linkgit:git-ls-files[1] can show you the contents of the index:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3374
#, no-wrap
msgid ""
"$ git ls-files --stage\n"
"100644 63c918c667fa005ff12ad89437f2fdc80926e21c 0\t.gitignore\n"
"100644 5529b198e8d14decbe4ad99db3f7fb632de0439d 0\t.mailmap\n"
"100644 6ff87c4664981e4397625791c8ea3bbb5f2279a3 0\tCOPYING\n"
"100644 a37b2152bd26be2c2289e1f57a292534a51a93c7 0\tDocumentation/.gitignore\n"
"100644 fbefe9a45b00a54b58d94d06eca48b03d40a50e0 0\tDocumentation/Makefile\n"
"...\n"
"100644 2511aef8d89ab52be5ec6a5e46236b4b6bcd07ea 0\txdiff/xtypes.h\n"
"100644 2ade97b2574a9f77e7ae4002a4e07a6a38e46d07 0\txdiff/xutils.c\n"
"100644 d5de8292e05e7c36c4b68857c1cf9855e3d2f70a 0\txdiff/xutils.h\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3379
msgid ""
"Note that in older documentation you may see the index called the \"current "
"directory cache\" or just the \"cache\".  It has three important properties:"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3382
msgid ""
"The index contains all the information necessary to generate a single "
"(uniquely determined) tree object."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3386
msgid ""
"For example, running linkgit:git-commit[1] generates this tree object from "
"the index, stores it in the object database, and uses it as the tree object "
"associated with the new commit."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3389
msgid ""
"The index enables fast comparisons between the tree object it defines and "
"the working tree."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3396
msgid ""
"It does this by storing some additional data for each entry (such as the "
"last modified time).  This data is not displayed above, and is not stored in "
"the created tree object, but it can be used to determine quickly which files "
"in the working directory differ from what was stored in the index, and thus "
"save git from having to read all of the data from such files to look for "
"changes."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3401
msgid ""
"It can efficiently represent information about merge conflicts between "
"different tree objects, allowing each pathname to be associated with "
"sufficient information about the trees involved that you can create a three-"
"way merge between them."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3407
msgid ""
"We saw in <<conflict-resolution>> that during a merge the index can store "
"multiple versions of a single file (called \"stages\").  The third column in "
"the linkgit:git-ls-files[1] output above is the stage number, and will take "
"on values other than 0 for files with merge conflicts."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3410
msgid ""
"The index is thus a sort of temporary staging area, which is filled with a "
"tree which you are in the process of working on."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3413
msgid ""
"If you blow the index away entirely, you generally haven't lost any "
"information as long as you have the name of the tree that it described."
msgstr ""

#. type: Title =
#: ../../user-manual.txt:3416
#, no-wrap
msgid "Submodules"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3424
msgid ""
"Large projects are often composed of smaller, self-contained modules.  For "
"example, an embedded Linux distribution's source tree would include every "
"piece of software in the distribution with some local modifications; a movie "
"player might need to build against a specific, known-working version of a "
"decompression library; several independent programs might all share the same "
"build scripts."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3430
msgid ""
"With centralized revision control systems this is often accomplished by "
"including every module in one single repository.  Developers can check out "
"all modules or only the modules they need to work with.  They can even "
"modify files across several modules in a single commit while moving things "
"around or updating APIs and translations."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3436
msgid ""
"Git does not allow partial checkouts, so duplicating this approach in Git "
"would force developers to keep a local copy of modules they are not "
"interested in touching.  Commits in an enormous checkout would be slower "
"than you'd expect as Git would have to scan every directory for changes.  If "
"modules have a lot of local history, clones would take forever."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3444
msgid ""
"On the plus side, distributed revision control systems can much better "
"integrate with external sources.  In a centralized model, a single arbitrary "
"snapshot of the external project is exported from its own revision control "
"and then imported into the local revision control on a vendor branch.  All "
"the history is hidden.  With distributed revision control you can clone the "
"entire external history and much more easily follow development and re-merge "
"local changes."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3452
msgid ""
"Git's submodule support allows a repository to contain, as a subdirectory, a "
"checkout of an external project.  Submodules maintain their own identity; "
"the submodule support just stores the submodule repository location and "
"commit ID, so other developers who clone the containing project "
"(\"superproject\") can easily clone all the submodules at the same "
"revision.  Partial checkouts of the superproject are possible: you can tell "
"Git to clone none, some or all of the submodules."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3457
msgid ""
"The linkgit:git-submodule[1] command is available since Git 1.5.3.  Users "
"with Git 1.5.2 can look up the submodule commits in the repository and "
"manually check them out; earlier versions won't recognize the submodules at "
"all."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3460
msgid ""
"To see how submodule support works, create (for example) four example "
"repositories that can be used later as a submodule:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3474
#, no-wrap
msgid ""
"$ mkdir ~/git\n"
"$ cd ~/git\n"
"$ for i in a b c d\n"
"do\n"
"\tmkdir $i\n"
"\tcd $i\n"
"\tgit init\n"
"\techo \"module $i\" > $i.txt\n"
"\tgit add $i.txt\n"
"\tgit commit -m \"Initial commit, submodule $i\"\n"
"\tcd ..\n"
"done\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3477
msgid "Now create the superproject and add all the submodules:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3486
#, no-wrap
msgid ""
"$ mkdir super\n"
"$ cd super\n"
"$ git init\n"
"$ for i in a b c d\n"
"do\n"
"\tgit submodule add ~/git/$i $i\n"
"done\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3489
msgid "Do not use local URLs here if you plan to publish your superproject!"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3491
msgid "See what files `git submodule` created:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3495
#, no-wrap
msgid ""
"$ ls -a\n"
".  ..  .git  .gitmodules  a  b  c  d\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3498
msgid "The `git submodule add <repo> <path>` command does a couple of things:"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3501
msgid ""
"It clones the submodule from <repo> to the given <path> under the current "
"directory and by default checks out the master branch."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3503
msgid ""
"It adds the submodule's clone path to the linkgit:gitmodules[5] file and "
"adds this file to the index, ready to be committed."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3505
msgid ""
"It adds the submodule's current commit ID to the index, ready to be "
"committed."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3507
msgid "Commit the superproject:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3510
#, no-wrap
msgid "$ git commit -m \"Add submodules a, b, c and d.\"\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3513
msgid "Now clone the superproject:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3518
#, no-wrap
msgid ""
"$ cd ..\n"
"$ git clone super cloned\n"
"$ cd cloned\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3521
msgid "The submodule directories are there, but they're empty:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3530
#, no-wrap
msgid ""
"$ ls -a a\n"
".  ..\n"
"$ git submodule status\n"
"-d266b9873ad50488163457f025db7cdd9683d88b a\n"
"-e81d457da15309b4fef4249aba9b50187999670d b\n"
"-c1536a972b9affea0f16e0680ba87332dc059146 c\n"
"-d96249ff5d57de5de093e6baff9e0aafa5276a74 d\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3535
msgid ""
"The commit object names shown above would be different for you, but they "
"should match the HEAD commit object names of your repositories.  You can "
"check it by running `git ls-remote ../a`."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3538
msgid ""
"Pulling down the submodules is a two-step process. First run `git submodule "
"init` to add the submodule repository URLs to `.git/config`:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3541
#, no-wrap
msgid "$ git submodule init\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3545
msgid ""
"Now use `git submodule update` to clone the repositories and check out the "
"commits specified in the superproject:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3551
#, no-wrap
msgid ""
"$ git submodule update\n"
"$ cd a\n"
"$ ls -a\n"
".  ..  .git  a.txt\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3557
msgid ""
"One major difference between `git submodule update` and `git submodule add` "
"is that `git submodule update` checks out a specific commit, rather than the "
"tip of a branch. It's like checking out a tag: the head is detached, so "
"you're not working on a branch."
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3562
#, no-wrap
msgid ""
"$ git branch\n"
"* (no branch)\n"
"  master\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3568
msgid ""
"If you want to make a change within a submodule and you have a detached "
"head, then you should create or checkout a branch, make your changes, "
"publish the change within the submodule, and then update the superproject to "
"reference the new commit:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3571
#, no-wrap
msgid "$ git checkout master\n"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3577
#, no-wrap
msgid "$ git checkout -b fix-up\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3580
msgid "then"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3597
#, no-wrap
msgid ""
"$ echo \"adding a line again\" >> a.txt\n"
"$ git commit -a -m \"Updated the submodule from within the superproject.\"\n"
"$ git push\n"
"$ cd ..\n"
"$ git diff\n"
"diff --git a/a b/a\n"
"index d266b98..261dfac 160000\n"
"--- a/a\n"
"+++ b/a\n"
"@@ -1 +1 @@\n"
"-Subproject commit d266b9873ad50488163457f025db7cdd9683d88b\n"
"+Subproject commit 261dfac35cb99d380eb966e102c1197139f7fa24\n"
"$ git add a\n"
"$ git commit -m \"Updated submodule a.\"\n"
"$ git push\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3601
msgid ""
"You have to run `git submodule update` after `git pull` if you want to "
"update submodules, too."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:3603
#, no-wrap
msgid "Pitfalls with submodules"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3608
msgid ""
"Always publish the submodule change before publishing the change to the "
"superproject that references it. If you forget to publish the submodule "
"change, others won't be able to clone the repository:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3623
#, no-wrap
msgid ""
"$ cd ~/git/super/a\n"
"$ echo i added another line to this file >> a.txt\n"
"$ git commit -a -m \"doing it wrong this time\"\n"
"$ cd ..\n"
"$ git add a\n"
"$ git commit -m \"Updated submodule a again.\"\n"
"$ git push\n"
"$ cd ~/git/cloned\n"
"$ git pull\n"
"$ git submodule update\n"
"error: pathspec '261dfac35cb99d380eb966e102c1197139f7fa24' did not match any file(s) known to git.\n"
"Did you forget to 'git add'?\n"
"Unable to checkout '261dfac35cb99d380eb966e102c1197139f7fa24' in submodule path 'a'\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3627
msgid ""
"You also should not rewind branches in a submodule beyond commits that were "
"ever recorded in any superproject."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3631
msgid ""
"It's not safe to run `git submodule update` if you've made and committed "
"changes within a submodule without checking out a branch first. They will be "
"silently overwritten:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3643
#, no-wrap
msgid ""
"$ cat a.txt\n"
"module a\n"
"$ echo line added from private2 >> a.txt\n"
"$ git commit -a -m \"line added inside private2\"\n"
"$ cd ..\n"
"$ git submodule update\n"
"Submodule path 'a': checked out 'd266b9873ad50488163457f025db7cdd9683d88b'\n"
"$ cd a\n"
"$ cat a.txt\n"
"module a\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3646
msgid "The changes are still visible in the submodule's reflog."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3648
msgid "This is not the case if you did not commit your changes."
msgstr ""

#. type: Title =
#: ../../user-manual.txt:3651
#, no-wrap
msgid "Low-level git operations"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3657
msgid ""
"Many of the higher-level commands were originally implemented as shell "
"scripts using a smaller core of low-level git commands.  These can still be "
"useful when doing unusual things with git, or just as a way to understand "
"its inner workings."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:3660
#, no-wrap
msgid "Object access and manipulation"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3664
msgid ""
"The linkgit:git-cat-file[1] command can show the contents of any object, "
"though the higher-level linkgit:git-show[1] is usually more useful."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3667
msgid ""
"The linkgit:git-commit-tree[1] command allows constructing commits with "
"arbitrary parents and trees."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3671
msgid ""
"A tree can be created with linkgit:git-write-tree[1] and its data can be "
"accessed by linkgit:git-ls-tree[1].  Two trees can be compared with linkgit:"
"git-diff-tree[1]."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3675
msgid ""
"A tag is created with linkgit:git-mktag[1], and the signature can be "
"verified by linkgit:git-verify-tag[1], though it is normally simpler to use "
"linkgit:git-tag[1] for both."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:3678
#, no-wrap
msgid "The Workflow"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3685
msgid ""
"High-level operations such as linkgit:git-commit[1], linkgit:git-checkout[1] "
"and linkgit:git-reset[1] work by moving data between the working tree, the "
"index, and the object database.  Git provides low-level operations which "
"perform each of these steps individually."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3691
msgid ""
"Generally, all \"git\" operations work on the index file. Some operations "
"work *purely* on the index file (showing the current state of the index), "
"but most operations move data between the index file and either the database "
"or the working directory. Thus there are four main combinations:"
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:3694
#, no-wrap
msgid "working directory -> index"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3700
msgid ""
"The linkgit:git-update-index[1] command updates the index with information "
"from the working directory.  You generally update the index information by "
"just specifying the filename you want to update, like so:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3703
#, no-wrap
msgid "$ git update-index filename\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3708
msgid ""
"but to avoid common mistakes with filename globbing etc, the command will "
"not normally add totally new entries or remove old entries, i.e. it will "
"normally just update existing cache entries."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3712
msgid ""
"To tell git that yes, you really do realize that certain files no longer "
"exist, or that new files should be added, you should use the `--remove` and "
"`--add` flags respectively."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3719
msgid ""
"NOTE! A `--remove` flag does 'not' mean that subsequent filenames will "
"necessarily be removed: if the files still exist in your directory "
"structure, the index will be updated with their new status, not removed. The "
"only thing `--remove` means is that update-index will be considering a "
"removed file to be a valid thing, and if the file really does not exist any "
"more, it will update the index accordingly."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3725
msgid ""
"As a special case, you can also do `git update-index --refresh`, which will "
"refresh the \"stat\" information of each index to match the current stat "
"information. It will 'not' update the object status itself, and it will only "
"update the fields that are used to quickly test whether an object still "
"matches its old backing store object."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3728
msgid ""
"The previously introduced linkgit:git-add[1] is just a wrapper for linkgit:"
"git-update-index[1]."
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:3731
#, no-wrap
msgid "index -> object database"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3734
msgid "You write your current index file to a \"tree\" object with the program"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3737
#, no-wrap
msgid "$ git write-tree\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3744
msgid ""
"that doesn't come with any options--it will just write out the current index "
"into the set of tree objects that describe that state, and it will return "
"the name of the resulting top-level tree. You can use that tree to re-"
"generate the index at any time by going in the other direction:"
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:3747
#, no-wrap
msgid "object database -> index"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3753
msgid ""
"You read a \"tree\" file from the object database, and use that to populate "
"(and overwrite--don't do this if your index contains any unsaved state that "
"you might want to restore later!) your current index.  Normal operation is "
"just"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3756
#, no-wrap
msgid "$ git read-tree <SHA-1 of tree>\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3761
msgid ""
"and your index file will now be equivalent to the tree that you saved "
"earlier. However, that is only your 'index' file: your working directory "
"contents have not been modified."
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:3764
#, no-wrap
msgid "index -> working directory"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3771
msgid ""
"You update your working directory from the index by \"checking out\" files. "
"This is not a very common operation, since normally you'd just keep your "
"files updated, and rather than write to your working directory, you'd tell "
"the index files about the changes in your working directory (i.e. `git "
"update-index`)."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3776
msgid ""
"However, if you decide to jump to a new version, or check out somebody "
"else's version, or just restore a previous tree, you'd populate your index "
"file with read-tree, and then you need to check out the result with"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3779
#, no-wrap
msgid "$ git checkout-index filename\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3782
msgid "or, if you want to check out all of the index, use `-a`."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3787
msgid ""
"NOTE! `git checkout-index` normally refuses to overwrite old files, so if "
"you have an old version of the tree already checked out, you will need to "
"use the \"-f\" flag ('before' the \"-a\" flag or the filename) to 'force' "
"the checkout."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3791
msgid ""
"Finally, there are a few odds and ends which are not purely moving from one "
"representation to the other:"
msgstr ""

#. type: Title ~
#: ../../user-manual.txt:3794
#, no-wrap
msgid "Tying it all together"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3800
msgid ""
"To commit a tree you have instantiated with \"git write-tree\", you'd create "
"a \"commit\" object that refers to that tree and the history behind it--most "
"notably the \"parent\" commits that preceded it in history."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3806
msgid ""
"Normally a \"commit\" has one parent: the previous state of the tree before "
"a certain change was made. However, sometimes it can have two or more parent "
"commits, in which case we call it a \"merge\", due to the fact that such a "
"commit brings together (\"merges\") two or more previous states represented "
"by other commits."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3810
msgid ""
"In other words, while a \"tree\" represents a particular directory state of "
"a working directory, a \"commit\" represents that state in \"time\", and "
"explains how we got there."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3813
msgid ""
"You create a commit object by giving it the tree that describes the state at "
"the time of the commit, and a list of parents:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3816
#, no-wrap
msgid "$ git commit-tree <tree> -p <parent> [-p <parent2> ..]\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3820
msgid ""
"and then giving the reason for the commit on stdin (either through "
"redirection from a pipe or file, or by just typing it at the tty)."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3827
msgid ""
"`git commit-tree` will return the name of the object that represents that "
"commit, and you should save it away for later use. Normally, you'd commit a "
"new `HEAD` state, and while git doesn't care where you save the note about "
"that state, in practice we tend to just write the result to the file pointed "
"at by `.git/HEAD`, so that we can always see what the last committed state "
"was."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3830
msgid ""
"Here is an ASCII art by Jon Loeliger that illustrates how various pieces fit "
"together."
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3864
#, no-wrap
msgid ""
"                     commit-tree\n"
"                      commit obj\n"
"                       +----+\n"
"                       |    |\n"
"                       |    |\n"
"                       V    V\n"
"                    +-----------+\n"
"                    | Object DB |\n"
"                    |  Backing  |\n"
"                    |   Store   |\n"
"                    +-----------+\n"
"                       ^\n"
"           write-tree  |     |\n"
"             tree obj  |     |\n"
"                       |     |  read-tree\n"
"                       |     |  tree obj\n"
"                             V\n"
"                    +-----------+\n"
"                    |   Index   |\n"
"                    |  \"cache\"  |\n"
"                    +-----------+\n"
"         update-index  ^\n"
"             blob obj  |     |\n"
"                       |     |\n"
"    checkout-index -u  |     |  checkout-index\n"
"             stat      |     |  blob obj\n"
"                             V\n"
"                    +-----------+\n"
"                    |  Working  |\n"
"                    | Directory |\n"
"                    +-----------+\n"
msgstr ""

#. type: Title -
#: ../../user-manual.txt:3870
#, no-wrap
msgid "Examining the data"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3876
msgid ""
"You can examine the data represented in the object database and the index "
"with various helper tools. For every object, you can use linkgit:git-cat-file"
"[1] to examine details about the object:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3879
#, no-wrap
msgid "$ git cat-file -t <objectname>\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3883
msgid ""
"shows the type of the object, and once you have the type (which is usually "
"implicit in where you find the object), you can use"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3886
#, no-wrap
msgid "$ git cat-file blob|tree|commit|tag <objectname>\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3892
msgid ""
"to show its contents. NOTE! Trees have binary content, and as a result there "
"is a special helper for showing that content, called `git ls-tree`, which "
"turns the binary content into a more easily readable form."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3897
msgid ""
"It's especially instructive to look at \"commit\" objects, since those tend "
"to be small and fairly self-explanatory. In particular, if you follow the "
"convention of having the top commit name in `.git/HEAD`, you can do"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3900
#, no-wrap
msgid "$ git cat-file commit HEAD\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3903
msgid "to see what the top commit was."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:3906
#, no-wrap
msgid "Merging multiple trees"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3913
msgid ""
"Git helps you do a three-way merge, which you can expand to n-way by "
"repeating the merge procedure arbitrary times until you finally \"commit\" "
"the state.  The normal situation is that you'd only do one three-way merge "
"(two parents), and commit it, but if you like to, you can do multiple "
"parents in one go."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3918
msgid ""
"To do a three-way merge, you need the two sets of \"commit\" objects that "
"you want to merge, use those to find the closest common parent (a third "
"\"commit\" object), and then use those commit objects to find the state of "
"the directory (\"tree\" object) at these points."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3921
msgid ""
"To get the \"base\" for the merge, you first look up the common parent of "
"two commits with"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3924
#, no-wrap
msgid "$ git merge-base <commit1> <commit2>\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3929
msgid ""
"which will return you the commit they are both based on.  You should now "
"look up the \"tree\" objects of those commits, which you can easily do with "
"(for example)"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3932
#, no-wrap
msgid "$ git cat-file commit <commitname> | head -1\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3936
msgid ""
"since the tree object information is always the first line in a commit "
"object."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3944
msgid ""
"Once you know the three trees you are going to merge (the one \"original\" "
"tree, aka the common tree, and the two \"result\" trees, aka the branches "
"you want to merge), you do a \"merge\" read into the index. This will "
"complain if it has to throw away your old index contents, so you should make "
"sure that you've committed those--in fact you would normally always do a "
"merge against your last commit (which should thus match what you have in "
"your current index anyway)."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3946
msgid "To do the merge, do"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3949
#, no-wrap
msgid "$ git read-tree -m -u <origtree> <yourtree> <targettree>\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3954
msgid ""
"which will do all trivial merge operations for you directly in the index "
"file, and you can just write the result out with `git write-tree`."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:3958
#, no-wrap
msgid "Merging multiple trees, continued"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3966
msgid ""
"Sadly, many merges aren't trivial. If there are files that have been added, "
"moved or removed, or if both branches have modified the same file, you will "
"be left with an index tree that contains \"merge entries\" in it. Such an "
"index tree can 'NOT' be written out to a tree object, and you will have to "
"resolve any such merge clashes using other tools before you can write out "
"the result."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3969
msgid ""
"You can examine such index state with `git ls-files --unmerged` command.  An "
"example:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:3976
#, no-wrap
msgid ""
"$ git read-tree -m $orig HEAD $target\n"
"$ git ls-files --unmerged\n"
"100644 263414f423d0e4d70dae8fe53fa34614ff3e2860 1\thello.c\n"
"100644 06fa6a24256dc7e560efa5687fa84b51f0263c3a 2\thello.c\n"
"100644 cc44c73eb783565da5831b4d820c962954019b69 3\thello.c\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3983
msgid ""
"Each line of the `git ls-files --unmerged` output begins with the blob mode "
"bits, blob SHA-1, 'stage number', and the filename.  The 'stage number' is "
"git's way to say which tree it came from: stage 1 corresponds to `$orig` "
"tree, stage 2 `HEAD` tree, and stage3 `$target` tree."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:3994
msgid ""
"Earlier we said that trivial merges are done inside `git read-tree -m`.  For "
"example, if the file did not change from `$orig` to `HEAD` nor `$target`, or "
"if the file changed from `$orig` to `HEAD` and `$orig` to `$target` the same "
"way, obviously the final outcome is what is in `HEAD`.  What the above "
"example shows is that file `hello.c` was changed from `$orig` to `HEAD` and `"
"$orig` to `$target` in a different way.  You could resolve this by running "
"your favorite 3-way merge program, e.g.  `diff3`, `merge`, or git's own "
"merge-file, on the blob objects from these three stages yourself, like this:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4000
#, no-wrap
msgid ""
"$ git cat-file blob 263414f... >hello.c~1\n"
"$ git cat-file blob 06fa6a2... >hello.c~2\n"
"$ git cat-file blob cc44c73... >hello.c~3\n"
"$ git merge-file hello.c~2 hello.c~1 hello.c~3\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4006
msgid ""
"This would leave the merge result in `hello.c~2` file, along with conflict "
"markers if there are conflicts.  After verifying the merge result makes "
"sense, you can tell git what the final merge result for this file is by:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4010
#, no-wrap
msgid ""
"$ mv -f hello.c~2 hello.c\n"
"$ git update-index hello.c\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4014
msgid ""
"When a path is in the \"unmerged\" state, running `git update-index` for "
"that path tells git to mark the path resolved."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4020
msgid ""
"The above is the description of a git merge at the lowest level, to help you "
"understand what conceptually happens under the hood.  In practice, nobody, "
"not even git itself, runs `git cat-file` three times for this.  There is a "
"`git merge-index` program that extracts the stages to temporary files and "
"calls a \"merge\" script on it:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4023
#, no-wrap
msgid "$ git merge-index git-merge-one-file hello.c\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4026
msgid ""
"and that is what higher level `git merge -s resolve` is implemented with."
msgstr ""

#. type: Title =
#: ../../user-manual.txt:4029
#, no-wrap
msgid "Hacking git"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4033
msgid ""
"This chapter covers internal details of the git implementation which "
"probably only git developers need to understand."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:4036
#, no-wrap
msgid "Object storage format"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4042
msgid ""
"All objects have a statically determined \"type\" which identifies the "
"format of the object (i.e. how it is used, and how it can refer to other "
"objects).  There are currently four different object types: \"blob\", \"tree"
"\", \"commit\", and \"tag\"."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4052
msgid ""
"Regardless of object type, all objects share the following characteristics: "
"they are all deflated with zlib, and have a header that not only specifies "
"their type, but also provides size information about the data in the "
"object.  It's worth noting that the SHA-1 hash that is used to name the "
"object is the hash of the original data plus this header, so `sha1sum` "
"'file' does not match the object name for 'file'.  (Historical note: in the "
"dawn of the age of git the hash was the SHA-1 of the 'compressed' object.)"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4059
msgid ""
"As a result, the general consistency of an object can always be tested "
"independently of the contents or the type of the object: all objects can be "
"validated by verifying that (a) their hashes match the content of the file "
"and (b) the object successfully inflates to a stream of bytes that forms a "
"sequence of <ascii type without space> {plus} <space> {plus} <ascii decimal "
"size> {plus} <byte\\0> {plus} <binary object data>."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4065
msgid ""
"The structured objects can further have their structure and connectivity to "
"other objects verified. This is generally done with the `git fsck` program, "
"which generates a full dependency graph of all objects, and verifies their "
"internal consistency (in addition to just verifying their superficial "
"consistency through the hash)."
msgstr ""

#. type: Title -
#: ../../user-manual.txt:4068
#, no-wrap
msgid "A birds-eye view of Git's source code"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4073
msgid ""
"It is not always easy for new developers to find their way through Git's "
"source code.  This section gives you a little guidance to show where to "
"start."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4075
msgid "A good place to start is with the contents of the initial commit, with:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4078
#, no-wrap
msgid "$ git checkout e83c5163\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4082
msgid ""
"The initial revision lays the foundation for almost everything git has "
"today, but is small enough to read in one sitting."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4086
msgid ""
"Note that terminology has changed since that revision.  For example, the "
"README in that revision uses the word \"changeset\" to describe what we now "
"call a <<def_commit_object,commit>>."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4091
msgid ""
"Also, we do not call it \"cache\" any more, but rather \"index\"; however, "
"the file is still called `cache.h`.  Remark: Not much reason to change it "
"now, especially since there is no good single name for it anyway, because it "
"is basically _the_ header file which is included by _all_ of Git's C sources."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4094
msgid ""
"If you grasp the ideas in that initial commit, you should check out a more "
"recent version and skim `cache.h`, `object.h` and `commit.h`."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4102
msgid ""
"In the early days, Git (in the tradition of UNIX) was a bunch of programs "
"which were extremely simple, and which you used in scripts, piping the "
"output of one into another. This turned out to be good for initial "
"development, since it was easier to test new things.  However, recently many "
"of these parts have become builtins, and some of the core has been \"libified"
"\", i.e. put into libgit.a for performance, portability reasons, and to "
"avoid code duplication."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4109
msgid ""
"By now, you know what the index is (and find the corresponding data "
"structures in `cache.h`), and that there are just a couple of object types "
"(blobs, trees, commits and tags) which inherit their common structure from "
"`struct object`, which is their first member (and thus, you can cast e.g.  `"
"(struct object *)commit` to achieve the _same_ as `&commit->object`, i.e.  "
"get at the object name and flags)."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4111
msgid "Now is a good point to take a break to let this information sink in."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4117
msgid ""
"Next step: get familiar with the object naming.  Read <<naming-commits>>.  "
"There are quite a few ways to name an object (and not only revisions!).  All "
"of these are handled in `sha1_name.c`. Just have a quick look at the "
"function `get_sha1()`. A lot of the special handling is done by functions "
"like `get_sha1_basic()` or the likes."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4120
msgid ""
"This is just to get you into the groove for the most libified part of Git: "
"the revision walker."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4122
msgid "Basically, the initial version of `git log` was a shell script:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4126
#, no-wrap
msgid ""
"$ git-rev-list --pretty $(git-rev-parse --default HEAD \"$@\") | \\\n"
"\tLESS=-S ${PAGER:-less}\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4129
msgid "What does this mean?"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4134
msgid ""
"`git rev-list` is the original version of the revision walker, which "
"_always_ printed a list of revisions to stdout.  It is still functional, and "
"needs to, since most new Git programs start out as scripts using `git rev-"
"list`."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4138
msgid ""
"`git rev-parse` is not as important any more; it was only used to filter out "
"options that were relevant for the different plumbing commands that were "
"called by the script."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4142
msgid ""
"Most of what `git rev-list` did is contained in `revision.c` and `revision."
"h`.  It wraps the options in a struct named `rev_info`, which controls how "
"and what revisions are walked, and more."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4150
msgid ""
"The original job of `git rev-parse` is now taken by the function "
"`setup_revisions()`, which parses the revisions and the common command line "
"options for the revision walker. This information is stored in the struct "
"`rev_info` for later consumption. You can do your own command line option "
"parsing after calling `setup_revisions()`. After that, you have to call "
"`prepare_revision_walk()` for initialization, and then you can get the "
"commits one by one with the function `get_revision()`."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4155
msgid ""
"If you are interested in more details of the revision walking process, just "
"have a look at the first implementation of `cmd_log()`; call `git show v1.3.0"
"{tilde}155^2{tilde}4` and scroll down to that function (note that you no "
"longer need to call `setup_pager()` directly)."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4158
msgid ""
"Nowadays, `git log` is a builtin, which means that it is _contained_ in the "
"command `git`.  The source side of a builtin is"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4161
msgid ""
"a function called `cmd_<bla>`, typically defined in `builtin-<bla>.c`, and "
"declared in `builtin.h`,"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4163
msgid "an entry in the `commands[]` array in `git.c`, and"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4165
msgid "an entry in `BUILTIN_OBJECTS` in the `Makefile`."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4171
msgid ""
"Sometimes, more than one builtin is contained in one source file.  For "
"example, `cmd_whatchanged()` and `cmd_log()` both reside in `builtin-log.c`, "
"since they share quite a bit of code.  In that case, the commands which are "
"_not_ named like the `.c` file in which they live have to be listed in "
"`BUILT_INS` in the `Makefile`."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4174
msgid ""
"`git log` looks more complicated in C than it does in the original script, "
"but that allows for a much greater flexibility and performance."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4176
msgid "Here again it is a good point to take a pause."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4179
msgid ""
"Lesson three is: study the code.  Really, it is the best way to learn about "
"the organization of Git (after you know the basic concepts)."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4184
msgid ""
"So, think about something which you are interested in, say, \"how can I "
"access a blob just knowing the object name of it?\".  The first step is to "
"find a Git command with which you can do it.  In this example, it is either "
"`git show` or `git cat-file`."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4186
msgid "For the sake of clarity, let's stay with `git cat-file`, because it"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4188
msgid "is plumbing, and"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4192
msgid ""
"was around even in the initial commit (it literally went only through some "
"20 revisions as `cat-file.c`, was renamed to `builtin-cat-file.c` when made "
"a builtin, and then saw less than 10 versions)."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4195
msgid ""
"So, look into `builtin-cat-file.c`, search for `cmd_cat_file()` and look "
"what it does."
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4202
#, no-wrap
msgid ""
"        git_config(git_default_config);\n"
"        if (argc != 3)\n"
"\t\tusage(\"git cat-file [-t|-s|-e|-p|<type>] <sha1>\");\n"
"        if (get_sha1(argv[2], sha1))\n"
"                die(\"Not a valid object name %s\", argv[2]);\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4208
msgid ""
"Let's skip over the obvious details; the only really interesting part here "
"is the call to `get_sha1()`.  It tries to interpret `argv[2]` as an object "
"name, and if it refers to an object which is present in the current "
"repository, it writes the resulting SHA-1 into the variable `sha1`."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4210
msgid "Two things are interesting here:"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4214
msgid ""
"`get_sha1()` returns 0 on _success_.  This might surprise some new Git "
"hackers, but there is a long tradition in UNIX to return different negative "
"numbers in case of different errors--and 0 on success."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4221
msgid ""
"the variable `sha1` in the function signature of `get_sha1()` is `unsigned "
"char \\*`, but is actually expected to be a pointer to `unsigned char[20]`.  "
"This variable will contain the 160-bit SHA-1 of the given commit.  Note that "
"whenever a SHA-1 is passed as `unsigned char \\*`, it is the binary "
"representation, as opposed to the ASCII representation in hex characters, "
"which is passed as `char *`."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4223
msgid "You will see both of these things throughout the code."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4225
msgid "Now, for the meat:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4229
#, no-wrap
msgid ""
"        case 0:\n"
"                buf = read_object_with_reference(sha1, argv[1], &size, NULL);\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4236
msgid ""
"This is how you read a blob (actually, not only a blob, but any type of "
"object).  To know how the function `read_object_with_reference()` actually "
"works, find the source code for it (something like `git grep "
"read_object_with | grep \":[a-z]\"` in the git repository), and read the "
"source."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4238
msgid ""
"To find out how the result can be used, just read on in `cmd_cat_file()`:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4241
#, no-wrap
msgid "        write_or_die(1, buf, size);\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4246
msgid ""
"Sometimes, you do not know where to look for a feature.  In many such cases, "
"it helps to search through the output of `git log`, and then `git show` the "
"corresponding commit."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4250
msgid ""
"Example: If you know that there was some test case for `git bundle`, but do "
"not remember where it was (yes, you _could_ `git grep bundle t/`, but that "
"does not illustrate the point!):"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4253
#, no-wrap
msgid "$ git log --no-merges t/\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4258
msgid ""
"In the pager (`less`), just search for \"bundle\", go a few lines back, and "
"see that it is in commit 18449ab0...  Now just copy this object name, and "
"paste it into the command line"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4261
#, no-wrap
msgid "$ git show 18449ab0\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4264
msgid "Voila."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4267
msgid ""
"Another example: Find out what to do in order to make some script a builtin:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4270
#, no-wrap
msgid "$ git log --no-merges --diff-filter=A builtin-*.c\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4274
msgid ""
"You see, Git is actually the best tool to find out about the source of Git "
"itself!"
msgstr ""

#. type: Title =
#: ../../user-manual.txt:4277
#, no-wrap
msgid "GIT Glossary"
msgstr ""

#. type: Title =
#: ../../user-manual.txt:4283
#, no-wrap
msgid "Appendix A: Git Quick Reference"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4287
msgid ""
"This is a quick summary of the major commands; the previous chapters explain "
"how these work in more detail."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4293
msgid "From a tarball:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4301
#, no-wrap
msgid ""
"$ tar xzf project.tar.gz\n"
"$ cd project\n"
"$ git init\n"
"Initialized empty Git repository in .git/\n"
"$ git add .\n"
"$ git commit\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4304
msgid "From a remote repository:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4308
#, no-wrap
msgid ""
"$ git clone git://example.com/pub/project.git\n"
"$ cd project\n"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4319
#, no-wrap
msgid ""
"$ git branch\t     # list all local branches in this repo\n"
"$ git checkout test  # switch working directory to branch \"test\"\n"
"$ git branch new     # create branch \"new\" starting at current HEAD\n"
"$ git branch -d new  # delete branch \"new\"\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4322
msgid "Instead of basing a new branch on current HEAD (the default), use:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4329
#, no-wrap
msgid ""
"$ git branch new test    # branch named \"test\"\n"
"$ git branch new v2.6.15 # tag named v2.6.15\n"
"$ git branch new HEAD^   # commit before the most recent\n"
"$ git branch new HEAD^^  # commit before that\n"
"$ git branch new test~10 # ten commits before tip of branch \"test\"\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4332
msgid "Create and switch to a new branch at the same time:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4335
#, no-wrap
msgid "$ git checkout -b new v2.6.15\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4338
msgid "Update and examine branches from the repository you cloned from:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4346
#, no-wrap
msgid ""
"$ git fetch\t\t# update\n"
"$ git branch -r\t\t# list\n"
"  origin/master\n"
"  origin/next\n"
"  ...\n"
"$ git checkout -b masterwork origin/master\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4350
msgid ""
"Fetch a branch from a different repository, and give it a new name in your "
"repository:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4354
#, no-wrap
msgid ""
"$ git fetch git://example.com/project.git theirbranch:mybranch\n"
"$ git fetch git://example.com/project.git v2.6.15:mybranch\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4357
msgid "Keep a list of repositories you work with regularly:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4372
#, no-wrap
msgid ""
"$ git remote add example git://example.com/project.git\n"
"$ git remote\t\t\t# list remote repositories\n"
"example\n"
"origin\n"
"$ git remote show example\t# get details\n"
"* remote example\n"
"  URL: git://example.com/project.git\n"
"  Tracked remote branches\n"
"    master\n"
"    next\n"
"    ...\n"
"$ git fetch example\t\t# update branches from example\n"
"$ git branch -r\t\t\t# list all remote branches\n"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4396
#, no-wrap
msgid ""
"$ gitk\t\t\t    # visualize and browse history\n"
"$ git log\t\t    # list all commits\n"
"$ git log src/\t\t    # ...modifying src/\n"
"$ git log v2.6.15..v2.6.16  # ...in v2.6.16, not in v2.6.15\n"
"$ git log master..test\t    # ...in branch test, not in branch master\n"
"$ git log test..master\t    # ...in branch master, but not in test\n"
"$ git log test...master\t    # ...in one branch, not in both\n"
"$ git log -S'foo()'\t    # ...where difference contain \"foo()\"\n"
"$ git log --since=\"2 weeks ago\"\n"
"$ git log -p\t\t    # show patches as well\n"
"$ git show\t\t    # most recent commit\n"
"$ git diff v2.6.15..v2.6.16 # diff between two tagged versions\n"
"$ git diff v2.6.15..HEAD    # diff with current head\n"
"$ git grep \"foo()\"\t    # search working directory for \"foo()\"\n"
"$ git grep v2.6.15 \"foo()\"  # search old tree for \"foo()\"\n"
"$ git show v2.6.15:a.txt    # look at old version of a.txt\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4399
msgid "Search for regressions:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4409
#, no-wrap
msgid ""
"$ git bisect start\n"
"$ git bisect bad\t\t# current version is bad\n"
"$ git bisect good v2.6.13-rc2\t# last known good revision\n"
"Bisecting: 675 revisions left to test after this\n"
"\t\t\t\t# test here, then:\n"
"$ git bisect good\t\t# if this revision is good, or\n"
"$ git bisect bad\t\t# if this revision is bad.\n"
"\t\t\t\t# repeat until done.\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4416
msgid "Make sure git knows who to blame:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4423
#, no-wrap
msgid ""
"$ cat >>~/.gitconfig <<\\EOF\n"
"[user]\n"
"\tname = Your Name Comes Here\n"
"\temail = you@yourdomain.example.com\n"
"EOF\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4427
msgid ""
"Select file contents to include in the next commit, then make the commit:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4433
#, no-wrap
msgid ""
"$ git add a.txt    # updated file\n"
"$ git add b.txt    # new file\n"
"$ git rm c.txt     # old file\n"
"$ git commit\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4436
msgid "Or, prepare and create the commit in one step:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4440
#, no-wrap
msgid ""
"$ git commit d.txt # use latest content only of d.txt\n"
"$ git commit -a\t   # use latest content of all tracked files\n"
msgstr ""

#. type: Title -
#: ../../user-manual.txt:4444
#, no-wrap
msgid "Merging"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4451
#, no-wrap
msgid ""
"$ git merge test   # merge branch \"test\" into the current branch\n"
"$ git pull git://example.com/project.git master\n"
"\t\t   # fetch and merge in remote branch\n"
"$ git pull . test  # equivalent to git merge test\n"
msgstr ""

#. type: Title -
#: ../../user-manual.txt:4455
#, no-wrap
msgid "Sharing your changes"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4458
msgid "Importing or exporting patches:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4463
#, no-wrap
msgid ""
"$ git format-patch origin..HEAD # format a patch for each commit\n"
"\t\t\t\t# in HEAD but not in origin\n"
"$ git am mbox # import patches from the mailbox \"mbox\"\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4467
msgid ""
"Fetch a branch in a different git repository, then merge into the current "
"branch:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4470
#, no-wrap
msgid "$ git pull git://example.com/project.git theirbranch\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4474
msgid ""
"Store the fetched branch into a local branch before merging into the current "
"branch:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4477
#, no-wrap
msgid "$ git pull git://example.com/project.git theirbranch:mybranch\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4481
msgid ""
"After creating commits on a local branch, update the remote branch with your "
"commits:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4484
#, no-wrap
msgid "$ git push ssh://example.com/project.git mybranch:theirbranch\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4487
msgid "When remote and local branch are both named \"test\":"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4490
#, no-wrap
msgid "$ git push ssh://example.com/project.git test\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4493
msgid "Shortcut version for a frequently used remote repository:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4497
#, no-wrap
msgid ""
"$ git remote add example ssh://example.com/project.git\n"
"$ git push example test\n"
msgstr ""

#. type: Title -
#: ../../user-manual.txt:4501
#, no-wrap
msgid "Repository maintenance"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4504
msgid "Check for corruption:"
msgstr ""

#. type: delimited block -
#: ../../user-manual.txt:4507
#, no-wrap
msgid "$ git fsck\n"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4510
msgid "Recompress, remove unused cruft:"
msgstr ""

#. type: Title =
#: ../../user-manual.txt:4518
#, no-wrap
msgid "Appendix B: Notes and todo list for this manual"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4521
msgid "This is a work in progress."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4523
msgid "The basic requirements:"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4528
msgid ""
"It must be readable in order, from beginning to end, by someone intelligent "
"with a basic grasp of the UNIX command line, but without any special "
"knowledge of git.  If necessary, any other prerequisites should be "
"specifically mentioned as they arise."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4532
msgid ""
"Whenever possible, section headings should clearly describe the task they "
"explain how to do, in language that requires no more knowledge than "
"necessary: for example, \"importing patches into a project\" rather than "
"\"the `git am` command\""
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4536
msgid ""
"Think about how to create a clear chapter dependency graph that will allow "
"people to get to important topics without necessarily reading everything in "
"between."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4538
msgid "Scan Documentation/ for other stuff left out; in particular:"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4540
msgid "howto's"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4541
msgid "some of technical/?"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4542
msgid "hooks"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4543
msgid "list of commands in linkgit:git[1]"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4545
msgid "Scan email archives for other stuff left out"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4548
msgid ""
"Scan man pages to see if any assume more background than this manual "
"provides."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4551
msgid ""
"Simplify beginning by suggesting disconnected head instead of temporary "
"branch creation?"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4555
msgid ""
"Add more good examples.  Entire sections of just cookbook examples might be "
"a good idea; maybe make an \"advanced examples\" section a standard end-of-"
"chapter section?"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4557
msgid "Include cross-references to the glossary, where appropriate."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4560
msgid ""
"Document shallow clones? See draft 1.5.0 release notes for some "
"documentation."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4563
msgid ""
"Add a section on working with other version control systems, including CVS, "
"Subversion, and just imports of series of release tarballs."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4565
msgid "More details on gitweb?"
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4567
msgid "Write a chapter on using plumbing and writing scripts."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4569
msgid "Alternates, clone -reference, etc."
msgstr ""

#. type: Plain text
#: ../../user-manual.txt:4572
#, no-wrap
msgid ""
"More on recovery from repository corruption.  See:\n"
"\thttp://marc.theaimsgroup.com/?l=git&m=117263864820799&w=2\n"
"\thttp://marc.theaimsgroup.com/?l=git&m=117147855503798&w=2\n"
msgstr ""
